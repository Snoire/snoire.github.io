<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="Snoire" />
  
  
  <title>zsh guide | Snoire&#39; Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="记录,zsh," />
  

  
  <meta name="description" content="author: 陌辞寒link: https://github.com/goreliu/zshguide">

  

  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>
  

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  
    <script src="//unpkg.com/valine/dist/Valine.min.js" async></script>
  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"53Hsawr9k3ISwmY0drKzCs2F-gzGzoHsz","appkey":"SjrIApaUKrCn5iS0dmM0qJ8L","comment":true,"count":true},
    welcome: {"enable":false,"interval":30},
    start_time: "2019-10-08 20:01:24",
    passwords: ["cc8f2b7a1d1a757235e2c7b58b0b1dc1a721eb34c8d06a386d50b654522393d1", ],
    is_post: true,
    lock: true,
    author: "Snoire",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  
<script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>


  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  
<link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">


  
<meta name="generator" content="Hexo 5.2.0"></head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Snoire</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 观察改变世界</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/snoire/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2020-05-28
    </span>
    
      <span>
        | <a href="/categories/%E8%AE%B0%E5%BD%95/"><i class="fa fa-bookmark"></i>记录</a>
      </span>
    
    
      <span>
        | <i class="fa fa-lock"></i>LOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    zsh guide
  </h1>
  
  <article class="passage-article">
    <h1 id="第一篇-变量和语句"><a href="#第一篇-变量和语句" class="headerlink" title="第一篇 变量和语句"></a>第一篇 变量和语句</h1><h3 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h3><p>网上关于 zsh 的文章有很多，但其中超过 95% 的文章讲如何使用和配置，写如何用 zsh 编程的文章很少，能找到的多数也是只言片语，不成系统。国外有几本讲 zsh 的书，其中也有很多内容是配置、使用、编写补全脚本等等，对编程有用的篇幅占比并不多，而且比较零散不便于查询。至于<a target="_blank" rel="noopener" href="http://zsh.sourceforge.net/Doc/">官方文档</a>？那是让即使有多年编程经验的开发者也会抓狂的神奇存在。可读性极差，而且基本没有例子，不熟悉文档结构和内容的话，很难找到自己想要的东西。但内容覆盖很全面，洋洋洒洒近 500 页，耐心去看总会找到的。还有一份<a target="_blank" rel="noopener" href="http://zsh.sourceforge.net/Guide/">官方“入门”文档</a>，上次更新时间是 2002 年，也要 300 多页，至于可读性，比官网文档要稍微好一些吧，还是有一定的参考价值的。<a target="_blank" rel="noopener" href="http://zsh.sourceforge.net/">官网</a>上还有一些链接，里边内容比较零散，也可以看看。</p>
<p>很多人在 zsh 中用 bash 语法写脚本，虽然也可以正常运行，但这样无法利用 zsh 的众多优秀特性，还是非常遗憾的。熟悉下 zsh 下独有的特性，对写脚本的帮助是很大的。</p>
<p>本系列文章无关 zsh 的安装、使用、配置（如果需要配置文件，可以参考<a target="_blank" rel="noopener" href="https://github.com/goreliu/zshguide/wiki/.zshrc">我的 .zshrc</a>，里边有比较详细的注释），更无 oh-my-zsh 相关内容，安装 zsh 后无需配置即可开始学习编写脚本。读者不需要有 bash 的基础（最好了解一些），但需要接触过任何一门编程语言，对编程的一些基础概念要有了解。</p>
<h3 id="为什么用-zsh-写脚本"><a href="#为什么用-zsh-写脚本" class="headerlink" title="为什么用 zsh 写脚本"></a>为什么用 zsh 写脚本</h3><p>很多人对 zsh 的了解停留在界面漂亮、主题多、插件多、补全强等等，而对 zsh 的语言特性了解并不多。因为 zsh 基本兼容 bash，不少人使用 bash 语法写 zsh 脚本，或者偶尔使用一些 zsh 特有的小技巧，很难体会出 zsh 作为一门编程语言的强大之处。</p>
<p>另外有些人认为 bash 几乎在所有类 Unix 系统都有默认安装，而 zsh 往往要自己安装，为了通用性而用 bash 写脚本比较好。这个说法也有一定的道理，但并不是对所有开发者来说都有影响。如果是开源软件的开发者，为了避免洁癖用户因为不想安装他用不到的 zsh 而不使用自己的软件，而避免使用 zsh，是有一定道理的（但现在 zsh 的用户量也有一定的积累了）。除此之外，自己平时写脚本、公司内部使用等多数场景，都是不需要考虑这个因素的。</p>
<p>如果在公司使用，还涉及其他因素。</p>
<p>第一个是 zsh 的部署成本。但因为多数情况都需要部署其他软件，甚至自己的脚本可以和 zsh 打包部署（去掉用不到的文件后的 zsh 只有 1M 多），所以基本不成问题。而且如果使用系统默认的 bash 的话，还涉及版本不同导致的问题，比如不同系统的 bash 版本不一样，或者系统升级后，bash 的升级导致之前的脚本挂掉等等。所以即使使用 bash，最好也是统一部署或者自带一个特定的版本，而不是使用系统默认的，以减少不必要的麻烦。</p>
<p>第二个就是非常重要的学习成本。因为会写 bash 的人很多，但会写 zsh 的比较少，如果只有自己会写，那么和别人合作会出问题。但 zsh  的学习成本并没有那么大，尤其是对会 bash 开发者来说，要大致看懂 zsh 脚本基本只需要几十分钟的学习，而编写的话，循序渐进也是很自然的事情，而且想不起来的时候还可以用 bash 的语法写。所以学习成本没有那么可观。</p>
<p>第三个是使用 zsh 开发的好处。如果 zsh 和 bash 相比，没有明显的好处，为什么要学习和使用它呢？那么就要从 bash 痛点讲起了。我想经常写 bash 脚本的人，很少有人会举大拇指说 bash 真好用啊。相反，我曾经多次听某些开发者说我写过一个超过 2000（或者其他行数）行的 shell（bash）脚本。但几乎没有人会认为写一个超过 2000 行的 Python 脚本是一件多么特别的事情。蹩脚的语法（几乎所有从任何其他语言迁移过来的开发者，都要重新熟悉和习惯它的语法）、严重依赖外部命令（因为文件系统错误等问题，挂掉一个外部命令，脚本就休克了。命令版本不同会有用法上的微秒差别，调试测试困难。频繁起新进程性能低下）、功能孱弱蹩脚（很多需要频繁使用的功能不全面或者不好用，比如字符串处理和数组的用法）等等，让很多开发者非常头疼，其中有些人甚至主张禁止使用 shell 脚本，一律改用 Python 等等，但 Python 并非适用所有场景，而且也有另外的一些问题，这样做也是因噎废食。Zsh 并非将这些问题全部解决了，但和 bash 相比，有很大的改善。比如 zsh 支持多种风格的语法，开发者很容易找到亲切感；对外部命令的依赖比 bash 要轻很多，多数常用的功能不需要使用外部命令，性能更好，调试也更加方便；功能上和 bash 相比也有比较大的提升，处理不那么复杂的场景已经比较够用了。</p>
<p>有人可能会说，不如“一步到位”，使用 Powershell。Powershell 的确比 Python 更适合作为一种 shell 脚本语言，但使用它的话会有其他问题。</p>
<p>首先 Powershell 的学习成本是绝对要比 zsh 高的，如果想省点事，这并不是好的选择。</p>
<p>其次 Linux 下的 Powershell 目前还是 beta 版，以后会不会有很多人用也很难说，如果很少有人用，那么生态环境就成问题。比如遇到问题后找不到解决办法，配套的软件和库不完善等等。</p>
<p>再次 Powershell 解释器的启动速度非常感人，在我的机器上，Windows 下的 Powershell 空脚本要执行将近 200 毫秒，Linux 下的要更长一些（我只在 WSL 里安装试用过，时间翻了几倍），而 zsh 的话，在 Linux 下不超过 5 毫秒，在 WSL 下也不超过 20 毫秒。如果写一个简单的脚本，运行时都要卡一下，是非常影响体验的。</p>
<p>最后如果平时就使用 Powershell 作为交互 shell，那么虽然脚本的启动时间问题有所缓解，但用户体验会差很多，而且以后也很难提升上来，很容易得不偿失。</p>
<h3 id="Zsh-脚本样例"><a href="#Zsh-脚本样例" class="headerlink" title="Zsh 脚本样例"></a>Zsh 脚本样例</h3><p>可以通过一个例子直观感受下用 zsh 写的脚本。这是一个删除当前目录以及所有子目录下重复文件的脚本，通过 md5 判断文件是否相同（不严谨）。熟悉 bash 的读者可以尝试用 bash 完成相同的功能，然后对比一下代码（我之前写过一个 bash 版本的，不贴上来了），就能比较直观地感受到 bash 和 zsh 的区别了。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> files=(<span class="string">&quot;<span class="variable">$&#123;(f)$(md5sum **/*(.D))&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">local</span> files_to_delete=()</span><br><span class="line"><span class="built_in">local</span> -A md5s</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i (<span class="variable">$files</span>) &#123;</span><br><span class="line">    <span class="built_in">local</span> md5=<span class="variable">$i</span>[1,32]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (($+md5s[<span class="variable">$md5</span>])) &#123;</span><br><span class="line">        files_to_delete+=(<span class="variable">$i</span>[35,-1])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        md5s[<span class="variable">$md5</span>]=1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((<span class="variable">$#files_to_delete</span>)) &amp;&amp; rm -v <span class="variable">$files_to_delete</span></span><br></pre></td></tr></table></figure>

<h3 id="为什么要使用-shell-脚本语言"><a href="#为什么要使用-shell-脚本语言" class="headerlink" title="为什么要使用 shell 脚本语言"></a>为什么要使用 shell 脚本语言</h3><p>对于没有接触过 shell 脚本的开发者或者用户来说，有一个更重要的问题，我为什么要学习和使用 shell 脚本呢？</p>
<p>那么要从 shell 脚本的使用场景说起。Shell 是一种和计算机系统交互的文本界面（CLI），简单说就是输入命令后返回结果（也有比较复杂的操作）。CLI 在某些场景要比图形界面（GUI）方便和高效很多，是不可取代的（即使有一天语音识别取代了文本输入，CLI 也会换汤不换药地继续存在）。那么使用 CLI 就必须约定好指令格式，而 shell 脚本就是一种用于 CLI 交互的指令格式。</p>
<p>因为这个比较特别的场景，shell  脚本有一些与其他编程语言不同的特点。一个很重要的特点，shell 脚本要比较简洁，容易输入。如果发送一条简单指令就要打几十个字符，那恐怕谁也无法接受。而为了达到可以接受的简洁程度，shell 脚本的语法，往往比其他编程语言的更加怪异。</p>
<p>有人可能会说，这搞混了两个事情。在 CLI 输入命令和写脚本文件然后执行命令是两回事，不需要使用同一种语言，而只是在 CLI 交互中，通常是没有必要写复杂逻辑的，也就是说 shell 脚本基本没有必要学习。</p>
<p>是两回事不假，但二者并不是不相关的。比如有人这么想后，决定在 shell 里只使用最简单的命令，不学习较为复杂的语法，如果需要写脚本，就用 Python 之类的语言写。那么有什么问题吗？</p>
<p>Python 是为通用的场景设计的，虽然也能处理 shell 脚本所做的事情，但往往要写出多几倍甚至几十倍（如果对 Python 也不甚了解的话）的代码出来。而很多时候，shell 脚本做的是一次性工作，运行完就直接删除，或者直接在一行敲完，回车即可，这样的场景用 Python 写成本要高出很多。而且并不是一个 Python 初学者就能用 Python 实现 shell 脚本的功能的，甚至熟练的 Python 开发者也很可能一时想不好怎么实现某个用 shell 脚本能很容易实现的功能。Shell 脚本的很多工作是和字符串和目录文件打交道，特点是要实现的功能复杂多样，没有固定模式，无论用什么语言写，都不容易。Python 自带的字符串和目录文件等类库功能非常基础，基本只能实现功能很单一的操作，稍微复杂点的功能都需要自己写。如果去找某些功能复杂的第三方库，那就会涉及一堆问题，比如同样有学习和部署成本，可能因为用户少所以有 bug 未被发现，可能已经没有人维护了，Python 的语法决定库怎么写都不能让语法太简洁等等。</p>
<p>而初步熟悉一门 shell 脚本只需要几十分钟，用多了自然就熟悉了，成本收益的权衡不言而喻。</p>
<h3 id="格式约定"><a href="#格式约定" class="headerlink" title="格式约定"></a>格式约定</h3><p>文中行首的 <code>%</code> 代表 zsh 的命令提示符（类似 bash 的 <code>$</code>，这个是可以自由定义的，具体是什么不重要），行首的 <code>&gt;</code> 代表此行是换行后的输入内容，以 <code>#</code> 开头的为注释（非 root 用户的命令提示符，本系列文章不需要 root 用户），其余的是命令的输出内容。另外某些地方会贴成段的 zsh 代码，那样就省略开头的 <code>%</code>，比较容易分辨。</p>
<p>一个样例：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前两行是输入内容，第三行是输出内容</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&quot;Hello \</span></span><br><span class="line"><span class="string">&gt; World&quot;</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>

<p>本系列文章使用的 zsh 版本是 5.4.1（写这篇文章时的最新版本），代码在老版本中可能运行不了或者结果有出入，尽量使用最新版本。</p>
<p>下面直接进入正题。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>接触一门新的编程语言，运行完 Hello World 后，首先要了解的基本就是如何定义和使用变量了。有了变量后可以比较变量内容，进而可以接触条件、循环、分支等语句，继而了解函数的用法，更高级的数据结构的使用，更多库函数，等等。这样就大概了解了一门面向过程的语言的基本用法，剩下的可以等到用的时候再查手册。</p>
<p>所以这一篇讲最基本的变量和语句。</p>
<p>zsh 有 5 种变量：整数、浮点数（bash 不支持）、字符串、数组、哈希表（或者叫关联数组或者字典，本系列文章统一使用“哈希表”这一名词），另外还有一些其他语言少有的东西，比如 alias（但主要是交互时使用，编程时基本用不到）。此篇只涉及整数、浮点数、字符串，并且不涉及数值计算和字符串处理等内容。</p>
<h4 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h4><p>Zsh 的变量多数情况不需要提前声明或者指定类型，可以直接赋值和使用（但哈希表是一个例外）。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 等号两端不能有空格</span></span><br><span class="line">% num1=123</span><br><span class="line">% num2=123.456</span><br><span class="line">% str1=abcde</span><br><span class="line"><span class="comment"># 如果字符串中包含空格等特殊字符，需要加引号</span></span><br><span class="line">% str2=<span class="string">&#x27;abc def&#x27;</span></span><br><span class="line"><span class="comment"># 也可以用双引号，但和单引号有区别，比如双引号里可以使用变量，而单引号不可以</span></span><br><span class="line">% str3=<span class="string">&quot;abc def <span class="variable">$num1</span>&quot;</span></span><br><span class="line"><span class="comment"># 在字符串中可以使用转义字符，单双引号均可</span></span><br><span class="line">% str4=<span class="string">&quot;abc\tdef\ng&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出变量，也可以使用 print</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line">abcde</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的数值计算</span></span><br><span class="line">% num3=$((<span class="variable">$num1</span> + <span class="variable">$num2</span>))</span><br><span class="line"><span class="comment"># (( 中的变量名可以不用 $</span></span><br><span class="line">% num3=$((num1 + num2))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单的字符串操作</span></span><br><span class="line">% str=abcdef</span><br><span class="line"><span class="comment"># 2 和 4 都是字符在数组的位置，从 1 开始数，逗号两边不能有空格</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[2,4]</span><br><span class="line">bcd</span><br><span class="line"><span class="comment"># -1 是最后一个字符</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[4,-1]</span><br><span class="line">def</span><br></pre></td></tr></table></figure>

<h4 id="变量比较"><a href="#变量比较" class="headerlink" title="变量比较"></a>变量比较</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较数值</span></span><br><span class="line">% num=123</span><br><span class="line"><span class="comment"># (( )) 用于数值比较等操作，如果为真返回 0，否则返回 1</span></span><br><span class="line"><span class="comment"># &amp;&amp; 后边的语句在前边的语句为真时才执行</span></span><br><span class="line"><span class="comment"># 注意这里只能使用双等号来比较</span></span><br><span class="line">% ((num == 123)) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"><span class="comment"># (( 里边可以使用与（&amp;&amp;）或（||）非（!）操作符，同 c 系列语言</span></span><br><span class="line">% ((num == 1 || num == 2)) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较字符串</span></span><br><span class="line">% str=abc</span><br><span class="line"><span class="comment"># 比较字符串要用 [[，内侧要有空格，[[ 的具体用法之后会讲到</span></span><br><span class="line"><span class="comment"># 这里双等号可以替换成单等号，可以根据自己的习惯选用</span></span><br><span class="line"><span class="comment"># 本系列文章统一使用双等号，因为和 (( )) 一致，并且使用双等号的常用编程语言更多些</span></span><br><span class="line"><span class="comment"># $str 两侧不需要加双引号，即使 str 未定义或者 $str 中含空格和特殊符号</span></span><br><span class="line">% [[ <span class="variable">$str</span> == abc ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"><span class="comment"># 可以和空字符串 &quot;&quot; 比较，未定义的字符串和空字符串比较结果为真</span></span><br><span class="line"><span class="comment"># [[ 里也可以用 &amp;&amp; || !</span></span><br><span class="line">% [[ <span class="variable">$str</span> == <span class="string">&quot;&quot;</span> || <span class="variable">$str</span> == 123 ]] &amp;&amp; <span class="built_in">echo</span> good</span><br></pre></td></tr></table></figure>

<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>稍微了解下简单变量的使用后，快速进入语句部分。</p>
<p>zsh 支持多种风格的语法，包括经典的 posix shell （bash 的语法和它类似，但有一些扩展，可以归为一类）的，以及 csh 风格的等等。但 posix shell 的语法并不好用，我们没必要一定使用这个。我只选用一种我认为最方便简洁的语法，没有 <code>fi</code>、<code>then</code>、<code>do</code>、<code>done</code>、<code>esac</code>、<code>in</code> 等的关键字（虽然其中某些关键字其他编程语言也有，但基本用法都各异，而且容易混淆），也不需要多余的分号。如果不确定语法是否符合预期，可以定义一个函数然后使用 <code>which</code> 查看，内容会被转化成原始（posix shell 风格）的样子。熟悉 bash 并且喜欢使用 bash 语法的读者可以跳过这部分内容，语法的不同并不影响后续内容的阅读，继续使用 bash 风格语法写 zsh 也是没有问题的。</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="keyword">if</span> [[ ]] &#123;</span><br><span class="line">&#125; <span class="keyword">elif</span> &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大括号也可以另起一行，本系列文章统一使用这种风格，缩进为 4 个空格。注意 <code>elif</code> 不可写作 <code>else if</code>。</p>
<p><code>[[ ]]</code> 用于比较字符串、判断文件等，功能比较复杂多样，这里先使用最基础的用法。注意尽量不要用 <code>[[ ]]</code> 比较数值，因为不留神的话，数值会被转化成字符串来比较，没有任何错误提示，但结果可能不符合预期，导致不必要的麻烦。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$str</span>&quot;</span> == <span class="string">&quot;name&quot;</span> || <span class="string">&quot;<span class="variable">$str</span>&quot;</span> == <span class="string">&quot;value&quot;</span> ]] &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>(( ))</code> 用于比较数值，里边可以调用各种数值相关的函数，格式类似 c 语言，变量前的 <code>$</code> 可省略。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="keyword">if</span> (( )) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例</span></span><br><span class="line"><span class="keyword">if</span> ((num &gt; 3 &amp;&amp; num + 3 &lt; 10)) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>&#123; &#125;</code> 用于在当前 shell 运行命令并且判断运行结果。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="keyword">if</span> &#123; &#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例</span></span><br><span class="line"><span class="keyword">if</span> &#123;grep sd1 /etc/fstab&#125; &#123;</span><br><span class="line">    <span class="built_in">echo</span> good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>( )</code> 用于在子 shell 运行命令并且判断运行结果，用法和 {} 类似，不再举例。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="function"><span class="title">if</span></span> ( ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几种括号可以一起使用，这样可以同时判断字符串、数值、文件、命令结果等等。最好不要混合使用 <code>&amp;&amp;</code> <code>||</code>，会导致可读性变差和容易出错。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="keyword">if</span> [[ ]] &amp;&amp; (( )) &amp;&amp; &#123; &#125; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="keyword">while</span> [[ ]] &#123;</span><br><span class="line">    <span class="built_in">break</span>/<span class="built_in">continue</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和 <code>if</code> 一样，这里的 <code>[[ ]]</code> 可以替换成其他几种括号，功能也是一样的，不再依次举例。<code>break</code> 用于结束循环，<code>continue</code> 用于直接进入下一次循环。所有的循环语句中都可以使用 <code>break</code> 和 <code>continue</code>，下边不再赘述。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例 死循环</span></span><br><span class="line"> <span class="keyword">while</span> ((1)) &#123;</span><br><span class="line">    <span class="built_in">echo</span> good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>until</code> 和 <code>while</code> 相反，不满足条件时运行，一旦满足则停止，其他的用法和 <code>while</code> 相同，不再举例。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">until [[ ]] &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code> 循环主要用于枚举，这里的括号是 <code>for</code> 的特有用法，不是在子 shell 执行。括号内是字符串（可放多个，空格隔开）、数组（可放多个）或者哈希表（可放多个，哈希表是枚举值而不是键）。<code>i</code> 是用于枚举内容的变量名，变量名随意。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="keyword">for</span> <span class="function"><span class="title">i</span></span> ( ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例</span></span><br><span class="line"><span class="keyword">for</span> i (aa bb cc) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举当前目录的 txt 文件</span></span><br><span class="line"><span class="keyword">for</span> i (*.txt) &#123; </span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举数组</span></span><br><span class="line">array=(aa bb cc)</span><br><span class="line"><span class="keyword">for</span> i (<span class="variable">$array</span>) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经典的 c 风格 <code>for</code> 循环。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line"><span class="keyword">for</span> (( ; ; )) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例</span></span><br><span class="line"><span class="keyword">for</span> ((i=0; i &lt; 10; i++)) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个样例只是举例，实际上多数情况不需要使用这种 <code>for</code> 循环，可以这样。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例，&#123;1..10&#125; 可以生成一个 1 到 10 的数组</span></span><br><span class="line"><span class="keyword">for</span> i (&#123;1..10&#125;) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>repeat</code> 语句用于循环固定次数，<code>n</code> 是一个整数或者内容为整数的变量。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">repeat n &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例</span></span><br><span class="line">repeat 5 &#123;</span><br><span class="line">    <span class="built_in">echo</span> good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h4><p>分支逻辑用 <code>if</code> 也可以实现，但 <code>case</code> 更适合这种场景，并且功能更强大。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式 + 样例</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$i</span> &#123;</span><br><span class="line">    (a)</span><br><span class="line">    <span class="built_in">echo</span> 1</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (b)</span><br><span class="line">    <span class="built_in">echo</span> 2</span><br><span class="line">    <span class="comment"># 继续执行下一个</span></span><br><span class="line">    ;&amp;</span><br><span class="line"></span><br><span class="line">    (c)</span><br><span class="line">    <span class="built_in">echo</span> 3</span><br><span class="line">    <span class="comment"># 继续向下匹配</span></span><br><span class="line">    ;|</span><br><span class="line"></span><br><span class="line">    (c)</span><br><span class="line">    <span class="built_in">echo</span> 33</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (d)</span><br><span class="line">    <span class="built_in">echo</span> 4</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (*)</span><br><span class="line">    <span class="built_in">echo</span> other</span><br><span class="line">    ;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>;;</code> 代表结束 <code>case</code> 语句，<code>;&amp;</code> 代表继续执行紧接着的下一个匹配的语句（不再进行匹配），<code>;|</code> 代表继续往下匹配看是否有满足条件的分支。</p>
<h4 id="用户输入选择语句"><a href="#用户输入选择语句" class="headerlink" title="用户输入选择语句"></a>用户输入选择语句</h4><p><code>select</code> 语句是用于根据用户的选择决定分支的语句，语法和 <code>for</code> 语句差不多，如果不 <code>break</code>，会循环让用户选择。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">select <span class="function"><span class="title">i</span></span> ( ) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 样例</span></span><br><span class="line">select i (aa bb cc) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出是这样的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1) aa  2) bb  3) cc</span><br><span class="line">?<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<p>按上边的数字加回车来选择。</p>
<h4 id="异常处理语句"><a href="#异常处理语句" class="headerlink" title="异常处理语句"></a>异常处理语句</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 格式</span></span><br><span class="line">&#123;</span><br><span class="line">    语句 1</span><br><span class="line">&#125; always &#123;</span><br><span class="line">    语句 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论语句 1 是否出错，都执行语句 2。</p>
<h4 id="简化的条件语句"><a href="#简化的条件语句" class="headerlink" title="简化的条件语句"></a>简化的条件语句</h4><p><code>if</code> 语句的简化版，在只有一个分支的情况下更简洁，功能和 <code>if</code> 语句类似，不赘述。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">[[ ]] || &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[[ ]] &amp;&amp; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好不要连续混合使用 <code>&amp;&amp;</code> <code>||</code>，比如。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa &amp;&amp; bb || cc &amp;&amp; dd</span><br></pre></td></tr></table></figure>

<p>容易导致逻辑错误或者误解，可以用 <code>&#123; &#125;</code> 把语句包含起来。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aa &amp;&amp; &#123; bb || &#123; cc &amp;&amp; dd &#125; &#125;</span><br></pre></td></tr></table></figure>

<p>比较复杂的判断还是用 <code>if</code> 可读写更好，<code>&amp;&amp;</code> <code>||</code> 通常只适用于简单的场景。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本篇简单介绍了变量和语句的使用方法。变量部分只涉及了最基础常用的部分，后续文章会详细介绍。语句部分已经覆盖了所有需要使用的语句，实际上这些语句都不只有这一种语法，但本系列文章统一使用这个语法。但涉及到的几种括号的用法比较复杂，之后的文章也会详细介绍。</p>
<h1 id="第二篇-字符串处理之常用操作"><a href="#第二篇-字符串处理之常用操作" class="headerlink" title="第二篇 字符串处理之常用操作"></a>第二篇 字符串处理之常用操作</h1><h3 id="导读-1"><a href="#导读-1" class="headerlink" title="导读"></a>导读</h3><p>字符串处理是 shell 脚本的重点部分，因为 shell 脚本主要的工作是和文件或者其他程序打交道，数据格式通常是文本，而处理没有统一格式的文本文件出奇地复杂，shell 命令中也有很多都是处理文本的。用 bash 处理文本的话，因为自身的功能有限，经常需要调用像 <code>awk</code>、<code>sed</code>、<code>grep</code>、<code>cat</code>、<code>cut</code>、<code>comm</code>、<code>dirname</code>、<code>basename</code>、<code>expr</code>、<code>sort</code>、<code>uniq</code>、<code>head</code>、<code>tail</code>、<code>tac</code>、<code>tr</code>、<code>wc</code> 这样命令，不留神脚本就成了命令大聚会。命令用法各异，有的很简单（比如 <code>cut</code>、<code>tr</code>、<code>wc</code>），看一眼 man 就会用；有的很复杂（比如 <code>awk</code>、<code>sed</code>、<code>grep</code>），用了好多年基本也只会用很少一部分功能。互相配合也容易出现各种各样的问题（比如要命的空格和换行符问题），难以调试，调用命令的开销也很大。而用好了 zsh 的话，可以大幅减少这些命令的使用（并不能完全避免，因为某些场景确实比较适合用这样的命令处理，比如处理一个大文本文件），并且大幅提升脚本的性能（主要因为减少了进程启动的开销，比如一次简单的字符串替换，调用外部命令实现比内部实现的时间要多好几个数量级）。</p>
<p>但也因此 zsh 的字符串处理功能很复杂，可以说 zsh 的字符串处理功能，要比绝大多数编程语言自带的字符串函数库或者类库要强大（在不依赖外部命令的情况）。同时各种用法也比较怪异，很多时候简洁性和可读性是有矛盾的，很难兼顾。而 shell 的使用场景决定简洁性是不能被牺牲掉的，即使用 Python 这样比较简洁的语言来处理字符串，很多时候也只能写出冗长的代码，而 zsh 经常可以一行搞定（可能有人想到了 Perl，Perl 在处理文本方面确实有比较明显的优势，但使用 Perl 的话也要承担更多的成本），如果再加上适当地使用外部命令，基本可以应付大多数字符串处理场景。因为字符串处理的内容比较丰富，我会分多篇文章写。本篇只涉及最基础和常用的字符串操作，包括字符串的拼接、切片、截断、查找、遍历、替换、匹配、大小写转换、分隔等等。</p>
<p>字符串定义和简单比较，我已经在前一篇文章提过了，现在直接进入正题。</p>
<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% str=abcde</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$#str</span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取函数或者脚本的第一个参数的长度</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$#1</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% str1=abc</span><br><span class="line">% str2=def</span><br><span class="line"></span><br><span class="line">% str2+=<span class="variable">$str1</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line">defabc</span><br><span class="line"></span><br><span class="line">% str3=<span class="variable">$str1</span><span class="variable">$str2</span></span><br><span class="line">abcdefabc</span><br></pre></td></tr></table></figure>

<h3 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h3><p>字符串切片之前也提过，这里简单复习一下。逗号前后不能有空格。字符位置是从 1 开始算起的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% str=abcdef</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[2,4]</span><br><span class="line">bcd</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[2,-1]</span><br><span class="line">bcdef</span><br><span class="line"></span><br><span class="line"><span class="comment"># $1 是文件或者函数的第一个参数</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;1[2,4]&#125;</span></span><br></pre></td></tr></table></figure>

<p>字符串切片还有另一种风格的方法，即 bash 风格，功能大同小异。通常没有必要用这个，而且因为字符位置是从 0 开始算，容易混淆。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% str=abcdef</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str:1:3&#125;</span></span><br><span class="line">bcd</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str:1:-1&#125;</span></span><br><span class="line">bcde</span><br></pre></td></tr></table></figure>

<h3 id="字符串截断"><a href="#字符串截断" class="headerlink" title="字符串截断"></a>字符串截断</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">% str=abcdeabcde</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除左端匹配到的内容，最小匹配</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str#*b&#125;</span></span><br><span class="line">cdeabcde</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除右端匹配到的内容，最小匹配</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str%d*&#125;</span></span><br><span class="line">abcdeabc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除左端匹配到的内容，最大匹配</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str##*b&#125;</span></span><br><span class="line">cde</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除右端匹配到的内容</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str%%d*&#125;</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<h3 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h3><p>子字符串定位。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">% str=abcdef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里用的是 i 的大写，不是 L 的小写</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[(I)<span class="built_in">cd</span>]</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment"># I 是从右往左找，如果找不到则为 0, 方便用来判断</span></span><br><span class="line">% ((<span class="variable">$str</span>[(I)<span class="built_in">cd</span>])) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找不到则为 0</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[(I)cdd]</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用小 i，小 i 是从左往右找，找不到则返回数组大小 + 1</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[(i)<span class="built_in">cd</span>]</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span>[(i)cdd]</span><br><span class="line">7</span><br></pre></td></tr></table></figure>

<h3 id="遍历字符"><a href="#遍历字符" class="headerlink" title="遍历字符"></a>遍历字符</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% str=abcd</span><br><span class="line"></span><br><span class="line">% <span class="keyword">for</span> i (&#123;1..<span class="variable">$#str</span>&#125;) &#123;</span><br><span class="line">&gt;    <span class="built_in">echo</span> <span class="variable">$str</span>[i]</span><br><span class="line">&gt;&#125;</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<h3 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h3><p>按内容替换和删除字符。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">% str=abcabc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只替换找到的第一个</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str/bc/ef&#125;</span></span><br><span class="line">aefabc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配到的第一个</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str/bc&#125;</span></span><br><span class="line">aabc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换所有找到的</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str//bc/ef&#125;</span></span><br><span class="line">aefaef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除匹配到的所有的</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str//bc&#125;</span></span><br><span class="line">aa</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% str=abcABCabcABCabc</span><br><span class="line"></span><br><span class="line"><span class="comment"># /# 只从字符串开头开始匹配，$&#123;str/#abc&#125; 也同理</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str/#abc/123&#125;</span></span><br><span class="line">123ABCabcABCabc</span><br><span class="line"></span><br><span class="line"><span class="comment"># /% 只从字符串结尾开始匹配，echo $&#123;str/%abc&#125; 也同理</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str/%abc/123&#125;</span></span><br><span class="line">abcABCabcABC123</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% str=abc</span><br><span class="line"><span class="comment"># 如果匹配到了则输出空字符串</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str:#ab*&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果匹配不到，则输出原字符串</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str:#ab&#125;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加 (M) 后效果反转</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(M)str:#ab&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>按位置删除字符。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">%str=abcdef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定位置字符</span></span><br><span class="line">% str[1]=</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">bcdef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以删除多个</span></span><br><span class="line">% str[2,4]=</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">bf</span><br></pre></td></tr></table></figure>

<p>按位置替换字符。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">% str=abcdefg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一对一地替换</span></span><br><span class="line">% str[2]=1</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">a1cdefg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以多对多（也包括一对多和多对一）地替换字符，两边的字符数量不需要一致。</span></span><br><span class="line"><span class="comment"># 把第二、三个字符替换成 2345</span></span><br><span class="line">% str[2,3]=2345</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">a2345defg</span><br></pre></td></tr></table></figure>

<h3 id="判断字符串变量是否存在"><a href="#判断字符串变量是否存在" class="headerlink" title="判断字符串变量是否存在"></a>判断字符串变量是否存在</h3><p>如果用 <code>[[ &quot;$strxx&quot; == &quot;&quot; ]]</code> ，那无法区分变量是没有定义还是内容为空，在某些情况是需要区分二者的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% (($+strxx)) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br><span class="line">% strxx=<span class="string">&quot;&quot;</span></span><br><span class="line">% (($+strxx)) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<p><code>(($+var))</code> 的用法也可以用来判断其他类型的变量，如果变量存在则返回真（0），否则返回假（1）。</p>
<h3 id="字符串匹配判断"><a href="#字符串匹配判断" class="headerlink" title="字符串匹配判断"></a>字符串匹配判断</h3><p>判断是否包含字符串。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% str1=abcd</span><br><span class="line">% str2=bc</span><br><span class="line"></span><br><span class="line">% [[ <span class="variable">$str1</span> == *<span class="variable">$str2</span>* ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<p>正则表达式匹配。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% str=abc55def</span><br><span class="line"></span><br><span class="line"><span class="comment"># 少量字符串的话，尽量不要用 grep</span></span><br><span class="line"><span class="comment"># 本文不讲正则表达式格式相关内容</span></span><br><span class="line"><span class="comment"># 另外 zsh 有专门的正则表达式模块</span></span><br><span class="line">% [[ <span class="variable">$str</span> =~ <span class="string">&quot;c[0-9]&#123;2&#125;\de&quot;</span> ]] &amp;&amp; <span class="built_in">echo</span> a</span><br><span class="line">a</span><br></pre></td></tr></table></figure>

<h3 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% str=<span class="string">&quot;ABCDE abcde&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成大写，(U) 和 :u 两种用法效果一样</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(U)str&#125;</span> --- <span class="variable">$&#123;str:u&#125;</span></span><br><span class="line">ABCDE ABCDE --- ABCDE ABCDE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成小写，(L) 和 :l 两种用法效果一样</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(L)str&#125;</span> --- <span class="variable">$&#123;str:l&#125;</span></span><br><span class="line">abcde abcde --- abcde abcde</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成首字母大写</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(C)str&#125;</span> </span><br><span class="line">Abcde Abcde</span><br></pre></td></tr></table></figure>

<h3 id="目录文件名截取"><a href="#目录文件名截取" class="headerlink" title="目录文件名截取"></a>目录文件名截取</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">% filepath=/a/b/c.x</span><br><span class="line"></span><br><span class="line"><span class="comment"># :h 是取目录名，即最后一个 / 之前的部分，如果没有 / 则为 .</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;filepath:h&#125;</span></span><br><span class="line">/a/b</span><br><span class="line"></span><br><span class="line"><span class="comment"># :t 是取文件名，即最后一个 / 之后的部分，如果没有 / 则为字符串本身</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;filepath:t&#125;</span></span><br><span class="line">c.x</span><br><span class="line"></span><br><span class="line"><span class="comment"># :e 是取文件扩展名，即文件名中最后一个点之后的部分，如果没有点则为空</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;filepath:e&#125;</span></span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="comment"># :r 是去掉末尾扩展名的路径</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;filepath:r&#125;</span></span><br><span class="line">/a/b/c</span><br></pre></td></tr></table></figure>

<h3 id="相对路径转绝对路径"><a href="#相对路径转绝对路径" class="headerlink" title="相对路径转绝对路径"></a>相对路径转绝对路径</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $&#123;filepath:A&#125; 功能相当于 $(readlink -f $filepath)</span></span><br><span class="line">% <span class="built_in">pwd</span></span><br><span class="line">/tmp/<span class="built_in">test</span></span><br><span class="line">% ls -lF</span><br><span class="line">-rw-r--r-- 1 goreliu goreliu  0 Feb 15 13:14 a.txt</span><br><span class="line">lrwxrwxrwx 1 goreliu goreliu 11 Feb 15 13:16 b -&gt; /usr/bin/ls*</span><br><span class="line">% filepath1=a.txt</span><br><span class="line">% filepath2=b</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;filepath1:A&#125;</span> <span class="variable">$&#123;filepath2:A&#125;</span></span><br><span class="line">/tmp/<span class="built_in">test</span>/a.txt /usr/bin/ls</span><br></pre></td></tr></table></figure>

<h3 id="字符串分隔"><a href="#字符串分隔" class="headerlink" title="字符串分隔"></a>字符串分隔</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用空格作为分隔符，多个空格也只算一个分隔符</span></span><br><span class="line">% str=<span class="string">&#x27;aa bb cc dd&#x27;</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str[(w)2]&#125;</span></span><br><span class="line">bb</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str[(w)3]&#125;</span></span><br><span class="line">cc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定分隔符</span></span><br><span class="line">% str=<span class="string">&#x27;aa--bb--cc&#x27;</span></span><br><span class="line"><span class="comment"># 如果分隔符是 : 就用别的字符作为左右界，比如 ws.:.</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;str[(ws:--:)3]&#125;</span></span><br><span class="line">cc</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 或者先转换成数组</span></span><br><span class="line">% str=<span class="string">&quot;1:2::4&quot;</span></span><br><span class="line">% str_array=(<span class="variable">$&#123;(s/:/)str&#125;</span>)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str_array</span></span><br><span class="line">1 2 4</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str_array</span>[2]</span><br><span class="line">2</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str_array</span>[3]</span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保留其中的空字符串</span></span><br><span class="line">% str_array=(<span class="string">&quot;<span class="variable">$&#123;(@s/:/)str&#125;</span>&quot;</span>)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str_array</span>[3]</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str_array</span>[4]</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h3 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h3><p>字符串定义可以跨行。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% str=<span class="string">&quot;line1</span></span><br><span class="line"><span class="string">&gt; line2&quot;</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">line1</span><br><span class="line">line2</span><br></pre></td></tr></table></figure>

<h3 id="读取文件内容到字符串"><a href="#读取文件内容到字符串" class="headerlink" title="读取文件内容到字符串"></a>读取文件内容到字符串</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比用 str=$(cat filename) 性能好很多</span></span><br><span class="line">str=$(&lt;filename)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比用 cat filename 性能好很多，引号不能省略</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(&lt;filename)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历每行，引号不能省略</span></span><br><span class="line"><span class="keyword">for</span> i (<span class="variable">$&#123;(f)&quot;$(&lt;filename)&quot;&#125;</span>) &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取文件指定行。</p>
<p>文件 test.txt 内容如下：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">line 1. apple</span><br><span class="line">line 2. orange</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 小文件或者需要频繁调用时，尽量不要用 sed</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;&quot;$(&lt;test.txt)&quot;[(f)2]&#125;</span></span><br><span class="line">line 2. orange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出包含 “ang” 的第一行</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;&quot;$(&lt;test.txt)&quot;[(fr)*ang*]&#125;</span></span><br><span class="line">line 2. orange</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出包含 pp 的第一行，但从左截掉 “line” 4个字符。</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;&quot;$(&lt;test.txt)&quot;[(fr)*pp*]#line&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="读取进程输出到字符串"><a href="#读取进程输出到字符串" class="headerlink" title="读取进程输出到字符串"></a>读取进程输出到字符串</h3><p>读进程输出和读文件类似。</p>
<p>上边字符串相关的处理，直接把 <code>$(&lt;test.txt)</code> 换成 <code>$(命令)</code> 即可。如果一定需要一个文件名，可以这样。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回 fd 路径，优先使用，但某些场景会出错</span></span><br><span class="line">% wc -l &lt;(ps)</span><br><span class="line">4 /proc/self/fd/11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时文件，会自动删除，适合上边用法出错的情况</span></span><br><span class="line">% wc -l =(ps)</span><br><span class="line">3 /tmp/zshMWDpqD</span><br></pre></td></tr></table></figure>

<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://tim.vanwerkhoven.org/post/2012/10/28/ZSH/Bash-string-manipulation">http://tim.vanwerkhoven.org/post/2012/10/28/ZSH/Bash-string-manipulation</a></p>
<h1 id="第三篇-字符串处理之转义字符和格式化输出"><a href="#第三篇-字符串处理之转义字符和格式化输出" class="headerlink" title="第三篇 字符串处理之转义字符和格式化输出"></a>第三篇 字符串处理之转义字符和格式化输出</h1><h3 id="导读-2"><a href="#导读-2" class="headerlink" title="导读"></a>导读</h3><p>上一篇讲了 zsh 的常用字符串操作，这篇开始讲更为琐碎的转义字符和格式化输出相关内容。包括转义字符、引号、<code>print</code>、<code>printf</code> 的使用等等。其中很多内容没有必要记忆，作为手册参考即可。</p>
<h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符是很多编程语言中都有的概念，它主要解决某些字符因为没有对应键盘按键无法直接输出、字符本身有特殊含义（比如 <code>\</code>、<code>&quot;</code>）或者显示不直观（比如难以区别多个空格和一个 tab）等问题。</p>
<p>最常用的转义字符是 <code>\n</code>（换行）、<code>\r</code>（回车）、<code>\t</code>（tab）。</p>
<p>直接用 <code>echo</code>、<code>print</code> 或者 <code>printf</code> 内置命令都可以正常输出转义字符，但包括转义字符的字符串需要用引号（单双引号都可以）扩起来。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> <span class="string">&#x27;Hello\n\tWorld&#x27;</span></span><br><span class="line">Hello</span><br><span class="line">        World</span><br></pre></td></tr></table></figure>

<p>常用转义字符对照表，不常用的可以去查 ASCII 码表，然后使用 <code>\xnn</code>（如 <code>\x14</code>）。</p>
<table>
<thead>
<tr>
<th>转义字符</th>
<th>含义</th>
<th>ASCII 码值（十六进制）</th>
</tr>
</thead>
<tbody><tr>
<td>\n</td>
<td>换行</td>
<td>0a</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>0d</td>
</tr>
<tr>
<td>\t</td>
<td>tab</td>
<td>09</td>
</tr>
<tr>
<td>\\</td>
<td>\</td>
<td>5c</td>
</tr>
<tr>
<td>\`</td>
<td>`</td>
<td>60</td>
</tr>
<tr>
<td>\xnn</td>
<td>取决于 nn</td>
<td>nn</td>
</tr>
</tbody></table>
<p>可以用 <code>hexdump</code> 命令查看字符的 ASCII 码值。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> ab= | hexdump -C</span><br><span class="line">00000000  61 62 3d 0a                                       |ab=.|</span><br><span class="line">00000004</span><br></pre></td></tr></table></figure>

<p>还有一些字符是可选转义（通常有特殊含义的字符都是如此）的，比如空格、<code>&quot;</code>、<code>&#39;</code>、<code>*</code>、<code>~</code>、<code>$</code>、<code>&amp;</code>、<code>(</code>、<code>)</code>、<code>[</code>、<code>]</code>、<code>&#123;</code>、<code>&#125;</code>、<code>;</code>、<code>?</code> 等等，即如果在引号里边则无需转义（即使转义也不出错，转义方法都说前边加一个 <code>\</code>），但如果在引号外边则需要转义。谨慎起见，包含半角符号的字符串全部用引号包含即可，可以避免不必要的麻烦。</p>
<p>可以这样检查一个字符在空格外是否需要转义，输出的字符中前边带 <code>\</code> 的都是需要的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% str=<span class="string">&#x27;~!@#$%^&amp;*()_+-=&#123;&#125;|[]:;&lt;&gt;?,./&quot;&#x27;</span></span><br><span class="line"><span class="comment"># -r 选项代表忽略字符串中的转义符合</span></span><br><span class="line"><span class="comment"># $&#123;(q)str&#125; 功能是为字符串中的特殊符号添加转义符号</span></span><br><span class="line">% <span class="built_in">print</span> -r <span class="variable">$&#123;(q)str&#125;</span></span><br><span class="line">\~\!@\<span class="comment">#\$%\^\&amp;\*\(\)_+-=\&#123;\&#125;\|\[\]:\;\&lt;\&gt;\?,./\&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="单引号"><a href="#单引号" class="headerlink" title="单引号"></a>单引号</h3><p>单引号的左右主要是为了避免字符串里的特殊字符起作用。在单引号中，只有一个字符需要转义，转义符号 <code>\</code> 。所以如果字符串里包含特殊符号时，最好使用单引号包含起来，避免不必要的麻烦。如果字符串需要包含单引号，可以使用这几种方法。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用双引号包含</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&quot;a&#x27;b&quot;</span></span><br><span class="line">a<span class="string">&#x27;b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 用转义符号</span></span><br><span class="line"><span class="string">% echo a\&#x27;</span>b</span><br><span class="line">a<span class="string">&#x27;b</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 同时使用单引号和转义符号，用于包含单引号和其他特殊符号的场景</span></span><br><span class="line"><span class="string">% echo &#x27;</span>a<span class="string">&quot;\&#x27;\&#x27;&#x27;b*?&#x27;</span></span><br><span class="line"><span class="string">a&quot;</span>\<span class="string">&#x27;b*?</span></span><br></pre></td></tr></table></figure>

<h3 id="双引号"><a href="#双引号" class="headerlink" title="双引号"></a>双引号</h3><p>双引号的作用类似单引号，但没有单引号那么严格，有些特殊字符在双引号里可以继续起作用。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以使用变量</span></span><br><span class="line">% str=abc</span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$str</span>&quot;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用 $( ) 运行命令</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$(ls)</span>&quot;</span></span><br><span class="line">git</span><br><span class="line">tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用 ` ` 运行命令，不建议在脚本里使用 ` `</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&quot;`date`&quot;</span></span><br><span class="line">Mon Aug 28 09:49:11 CST 2017</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用 $(( )) 计算数值</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&quot;<span class="subst">$((1 + 2)</span>)&quot;</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用 $[ ] 计算数值</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&quot;$[1 + 2]&quot;</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>简单说，<code>$</code> 加各种东西的用法在双引号里都是可以正常使用的，而其他特殊符号（比如 <code>*</code>、<code>?</code>、<code>&gt;</code>）的功能通常不可用。</p>
<h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号"></a>反引号</h3><p>反引号是用来运行命令的，它会返回命令结果，以便保存到变量等等。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% str=`ls`</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">git</span><br><span class="line">tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 完全可以用 $( ) 取代</span></span><br><span class="line">% str=$(ls)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">git</span><br><span class="line">tmp</span><br></pre></td></tr></table></figure>

<p>反引号的功能和 <code>$( )</code> 功能基本一样，但 <code>$( )</code> 可以嵌套，而反引号不可以，而且反引号看起来更费事，某些字体中的反引号和单引号差别不大。所以在脚本里不建议使用反引号。</p>
<h3 id="print-命令用法"><a href="#print-命令用法" class="headerlink" title="print 命令用法"></a>print 命令用法</h3><p><code>print</code> 是类似 <code>echo</code> 的内部命令（<code>echo</code> 命令很简单，不作介绍），但功能比 <code>echo</code> 强大很多。完全可以使用 <code>print</code> 代替 <code>echo</code>。</p>
<p>不加参数的 <code>print</code> 和 <code>echo</code> 的功能基本一样，但如果字符串里包含转义字符，某些情况可能不一致。如果需要输出转义字符，尽量统一使用 <code>print</code>，避免不一致导致的麻烦。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> <span class="string">&#x27;Line\tone\n\Line\ttwo&#x27;</span></span><br><span class="line">Line    one</span><br><span class="line">Line    two</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo 的输出和 print 不一致</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="string">&#x27;Line\tone\n\Line\ttwo&#x27;</span></span><br><span class="line">Line    one</span><br><span class="line">\Line   two</span><br></pre></td></tr></table></figure>

<p><code>print</code> 有很多参数，在 zsh 里输入 <code>print -</code> 然后按 tab 即可查看选项帮助（如果没有效果，需要配置 <code>~/.zshrc</code> 里的补全选项，网上有很多现成的配置）。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># - 后直接按 tab，C 是补全上去的</span></span><br><span class="line">% <span class="built_in">print</span> -C</span><br><span class="line"> -- option --</span><br><span class="line">-C  -- <span class="built_in">print</span> arguments <span class="keyword">in</span> specified number of columns</span><br><span class="line">-D  -- substitute any arguments <span class="built_in">which</span> are named directories using ~ notation</span><br><span class="line">-N  -- <span class="built_in">print</span> arguments separated and terminated by nulls</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="print-命令选项功能介绍"><a href="#print-命令选项功能介绍" class="headerlink" title="print 命令选项功能介绍"></a>print 命令选项功能介绍</h3><p>这里以常用程度的顺序依次介绍所有的选项，另外文末有“<code>print</code> 选项列表”方便查询。</p>
<p><code>-l</code> 用于分行输出字符串：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每个字符串一行，字符串列表是用空格隔开的</span></span><br><span class="line">% <span class="built_in">print</span> -l aa bb</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以接数组，数组相关的内容之后会讲到</span></span><br><span class="line"><span class="comment"># 命令后的多个字符串都可以用数组取代，效果是相同的</span></span><br><span class="line">% array=(aa bb)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">aa</span><br><span class="line">bb</span><br></pre></td></tr></table></figure>

<p><code>-n</code> 用于不在输出内容的末尾自动添加换行符（<code>echo</code> 命令也有这个用法）：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> abc</span><br><span class="line">abc</span><br><span class="line"><span class="comment"># 下面输出 abc 后的 % 高亮显示，代表这一行末尾没有换行符</span></span><br><span class="line">% <span class="built_in">print</span> -n abc</span><br><span class="line">abc%</span><br></pre></td></tr></table></figure>

<p><code>-m</code> 用于只输出匹配到的字符串：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -m <span class="string">&quot;aa*&quot;</span> aabb abc aac</span><br><span class="line">aabb aac</span><br></pre></td></tr></table></figure>

<p><code>-o/-O/-i</code> 用于对字符串排序：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print -o 对字符串升序排列</span></span><br><span class="line">% <span class="built_in">print</span> -o a d c 1 b g 3 s</span><br><span class="line">1 3 a b c d g s</span><br><span class="line"></span><br><span class="line"><span class="comment"># print -O 对字符串降序排列</span></span><br><span class="line">% <span class="built_in">print</span> -O a d c 1 b g 3 s</span><br><span class="line">s g d c b a 3 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加 -i 参数后，对大小写不敏感</span></span><br><span class="line">% <span class="built_in">print</span> -oi A B C a c A B C</span><br><span class="line">A a A B B C c C</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不加 -i 的话小写排在大写的前面</span></span><br><span class="line">% <span class="built_in">print</span> -o A B C a c A B C</span><br><span class="line">a A A B B c C C</span><br></pre></td></tr></table></figure>

<p><code>-r</code> 用于不对字符串进行转义。<code>print</code> 默认是会对转义字符进行转义的，加 <code>-r</code> 后会原样输出：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -r <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">\n</span><br></pre></td></tr></table></figure>

<p><code>-c</code> 用于将字符串按列输出。如果对自动决定的列数不满意，可以用 <code>-C</code> 指定列数：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -c a bbbbb ccc ddddd ee ffffff gg hhhhhh ii jj kk</span><br><span class="line">a       ccc     ee      gg      ii      kk</span><br><span class="line">bbbbb   ddddd   ffffff  hhhhhh  jj</span><br></pre></td></tr></table></figure>

<p><code>-C</code> 用于按指定列数输出字符串：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从上到下</span></span><br><span class="line">% <span class="built_in">print</span> -C 3 a bb ccc dddd ee f</span><br><span class="line">a     ccc   ee</span><br><span class="line">bb    dddd  f</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> -C 3 a bb ccc dddd ee f g</span><br><span class="line">a     dddd  g</span><br><span class="line">bb    ee</span><br><span class="line">ccc   f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加 -a 后，改成从左向右</span></span><br><span class="line">% <span class="built_in">print</span> -a -C 3 a bb ccc dddd ee f g</span><br><span class="line">a     bb    ccc</span><br><span class="line">dddd  ee    f</span><br><span class="line">g</span><br></pre></td></tr></table></figure>

<p><code>-D</code> 用于将符合条件的路径名转化成带 ~ 的格式（~ 是家目录）：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -D /home/goreliu/git</span><br><span class="line">~/git</span><br><span class="line"></span><br><span class="line"><span class="comment"># mine 是这样定义的 hash -d mine=&#x27;/mnt/c/mine&#x27;</span></span><br><span class="line">% <span class="built_in">print</span> -D /mnt/c/mine</span><br><span class="line">~mine</span><br></pre></td></tr></table></figure>

<p><code>-N</code> 用于将输出的字符串以 <code>\x00</code>（null）分隔，而不是空格。这样可能方便处理包含空格的字符串，<code>xargs</code> 等命令也可以接受以 <code>\x00</code> 分隔的字符串：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -N aa bb cc</span><br><span class="line">aabbcc%</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> -N aa bb cc | hexdump -C</span><br><span class="line">00000000  61 61 00 62 62 00 63 63  00                       |aa.bb.cc.|</span><br><span class="line">00000009</span><br></pre></td></tr></table></figure>

<p><code>-x</code> 用于将行首的 tab 替换成空格。<code>-x</code> 是将行首的 tab 展开成空格，<code>-x</code> 后的参数是一个 tab 对应的空格数：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -x 2 <span class="string">&#x27;\t\tabc&#x27;</span> | hexdump -C</span><br><span class="line">00000000  20 20 20 20 61 62 63 0a                           |    abc.|</span><br><span class="line">00000008</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> -x 4 <span class="string">&#x27;\t\tabc&#x27;</span> | hexdump -C</span><br><span class="line">00000000  20 20 20 20 20 20 20 20  61 62 63 0a              |        abc.|</span><br><span class="line">0000000c</span><br></pre></td></tr></table></figure>

<p><code>-X</code> 用于将所有的 tab 补全成空格。注意不是简单地替换成空格。比如每行有一个 tab，<code>-X 8</code>，那么如果 tab 前（到行首或者上一个 tab）有 5 个字符，就补全 3 个空格，凑够 8，这么做是为了对齐每一列的。但如果前边有 8 个或者 8 个以上字符，那么依然是一个 tab 替换成 8 个字符，因为 tab 不能凭空消失，一定要转成至少一个空格才行。如果没理解就自己多试试找规律吧。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -X 2 <span class="string">&#x27;ab\t\tabc&#x27;</span> | hexdump -C</span><br><span class="line">00000000  61 62 20 20 20 20 61 62  63 0a                    |ab    abc.|</span><br><span class="line">0000000a</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> -X 4 <span class="string">&#x27;ab\t\tabc&#x27;</span> | hexdump -C</span><br><span class="line">00000000  61 62 20 20 20 20 20 20  61 62 63 0a              |ab      abc.|</span><br><span class="line">0000000c</span><br></pre></td></tr></table></figure>

<p><code>-u</code> 用于指定文件描述符（fd）输出。<code>print</code> 默认输出到 fd 1，即 stdout，可以指定成其他 fd（2 是 stderr，其他的可以运行 <code>ls -l /proc/$$/fd</code> 查看。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -u 2 good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 和重定向输出效果一样</span></span><br><span class="line">% <span class="built_in">print</span> good &gt;&amp;2</span><br></pre></td></tr></table></figure>

<p><code>-v</code> 用于把输出内容保存到变量：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和 str=&quot;$(print aa bb cc)&quot; 效果一样</span></span><br><span class="line">% <span class="built_in">print</span> -v str aa bb cc</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">aa bb cc</span><br></pre></td></tr></table></figure>

<p><code>-s/-S</code> 用于把字符串保存到历史记录：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -s ls -a</span><br><span class="line">% <span class="built_in">history</span> | tail -n 1</span><br><span class="line"> 2222  ls -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># -S 也类似，但需要用引号把命令引起来</span></span><br><span class="line">% <span class="built_in">print</span> -S <span class="string">&quot;ls -a&quot;</span></span><br><span class="line">% <span class="built_in">history</span> | tail -n 1</span><br><span class="line"> 2339  ls -a</span><br></pre></td></tr></table></figure>

<p><code>-z</code> 用于把字符串输出到命令行编辑区：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _是光标位置</span></span><br><span class="line">% <span class="built_in">print</span> -z aa bb cc</span><br><span class="line">% aa bb cc_</span><br></pre></td></tr></table></figure>

<p><code>-f</code> 用于按指定格式化字符串输出，同 <code>printf</code>，用法见“<code>printf</code> 命令用法”。</p>
<p><code>-P</code> 用于输出带颜色和特殊样式的字符串，见“输出带颜色和特殊样式的字符串”。</p>
<p><code>-b</code> 用于辨认出 bindkey 中的转义字符串，bindkey 是 Zle 的快捷键配置内容，写脚本用不到，不作介绍。</p>
<p><code>-R</code> 用于模拟 <code>echo</code> 命令，只支持 <code>-n</code> 和 <code>-e</code> 选项，通常用不到。</p>
<h3 id="printf-命令用法"><a href="#printf-命令用法" class="headerlink" title="printf 命令用法"></a>printf 命令用法</h3><p><code>printf</code> 命令很像 c 语言的 <code>printf</code> 函数，用于输出格式化后的字符串：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 末尾输出高亮的 % 代表该行末尾没有换行符</span></span><br><span class="line"><span class="comment"># printf 不会在输出末尾自动添加换行符</span></span><br><span class="line"><span class="comment"># 为了避免误解，之后的例子省略该 % 符号</span></span><br><span class="line">% <span class="built_in">printf</span> <span class="string">&quot;:%d %f:&quot;</span> 12 34.56</span><br><span class="line">:12 34.560000:%</span><br></pre></td></tr></table></figure>

<p><code>printf</code> 的第一个参数是格式化字符串，在 zsh 里输入 <code>printf %</code> 后按 tab，可以看到所有支持的用法。下面只举几个比较常用的例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整数 浮点数 字符串</span></span><br><span class="line">% <span class="built_in">printf</span> <span class="string">&quot;%d %f %s&quot;</span> 12 12.34 abcd</span><br><span class="line">12 12.340000 abcd%</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取小数点后 1 位</span></span><br><span class="line">% <span class="built_in">printf</span> <span class="string">&quot;%.1f&quot;</span> 12.34</span><br><span class="line">12.3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 科学计数法输出浮点数</span></span><br><span class="line">% <span class="built_in">printf</span> <span class="string">&quot;%e&quot;</span> 12.34</span><br><span class="line">1.234000e+01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将十进制数字转成十六进制输出</span></span><br><span class="line">% <span class="built_in">printf</span> <span class="string">&quot;%x&quot;</span> 12</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 补齐空格或者补齐 0</span></span><br><span class="line">% <span class="built_in">printf</span> <span class="string">&quot;%5d\n%05d&quot;</span> 12 12</span><br><span class="line">   12</span><br><span class="line">00012</span><br></pre></td></tr></table></figure>

<p>我把完整的格式贴在这里，方便搜索：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> -- <span class="built_in">print</span> format specifier --</span><br><span class="line">      -- leave one space <span class="keyword">in</span> front of positive number from signed conversion</span><br><span class="line">-     -- left adjust result</span><br><span class="line">.     -- precision</span><br><span class="line"><span class="string">&#x27;     -- thousand separators</span></span><br><span class="line"><span class="string">*     -- field width in next argument</span></span><br><span class="line"><span class="string">#     -- alternate form</span></span><br><span class="line"><span class="string">%     -- a percent sign</span></span><br><span class="line"><span class="string">+     -- always place sign before a number from signed conversion</span></span><br><span class="line"><span class="string">0     -- zero pad to length</span></span><br><span class="line"><span class="string">b     -- as %s but interpret escape sequences in argument</span></span><br><span class="line"><span class="string">c     -- print the first character of the argument</span></span><br><span class="line"><span class="string">E  e  -- double number in scientific notation</span></span><br><span class="line"><span class="string">f     -- double number</span></span><br><span class="line"><span class="string">G  g  -- double number as %f or %e depending on size</span></span><br><span class="line"><span class="string">i  d  -- signed decimal number or with leading &quot; numeric value of following character</span></span><br><span class="line"><span class="string">n     -- store number of printed bytes in parameter specified by argument</span></span><br><span class="line"><span class="string">o     -- unsigned octal number</span></span><br><span class="line"><span class="string">q     -- as %s but shell quote result</span></span><br><span class="line"><span class="string">s     -- print the argument as a string</span></span><br><span class="line"><span class="string">u     -- unsigned decimal number</span></span><br><span class="line"><span class="string">X  x  -- unsigned hexadecimal number, letters capitalized as x</span></span><br></pre></td></tr></table></figure>

<h3 id="输出带颜色和特殊样式的字符串"><a href="#输出带颜色和特殊样式的字符串" class="headerlink" title="输出带颜色和特殊样式的字符串"></a>输出带颜色和特殊样式的字符串</h3><p>用 zsh 的 <code>print -P</code> 可以方便地输出带颜色和特殊样式的字符串，不用再和 <code>\033[41;36;1m</code> 之类莫名其妙的字符串打交道了。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %B 加粗 %b 取消加粗</span></span><br><span class="line"><span class="comment"># %F&#123;red&#125; 前景色 %f 取消前景色</span></span><br><span class="line"><span class="comment"># %K&#123;red&#125; 背景色 %k 取消背景色</span></span><br><span class="line"><span class="comment"># %U 下滑线 %u 取消下滑线</span></span><br><span class="line"><span class="comment"># %S 反色 %s 取消反色</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># black or 0  red     or 1</span></span><br><span class="line"><span class="comment"># green or 2  yellow  or 3</span></span><br><span class="line"><span class="comment"># blue  or 4  magenta or 5</span></span><br><span class="line"><span class="comment"># cyan  or 6  white   or 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示加粗的红色 abc</span></span><br><span class="line">% <span class="built_in">print</span> -P <span class="string">&#x27;%B%F&#123;red&#125;abc&#x27;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没覆盖到的功能可以用原始的转义符号，可读性比较差</span></span><br><span class="line"><span class="comment"># 4[0-7] 背景色</span></span><br><span class="line"><span class="comment"># 3[0-7] 前景色</span></span><br><span class="line"><span class="comment"># 0m 正常 1m 加粗 2m 变灰 3m 斜体 4m 下滑钱 5m 闪烁 6m 快速闪烁 7m 反色</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示闪烁的红底绿字 abc</span></span><br><span class="line">% <span class="built_in">print</span> <span class="string">&quot;\033[41;32;5mabc\033[0m&quot;</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<h3 id="print-选项列表"><a href="#print-选项列表" class="headerlink" title="print 选项列表"></a>print 选项列表</h3><p>为了方便查询，我把 <code>print</code> 的选项列表放在这里：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>功能</th>
<th>参数</th>
</tr>
</thead>
<tbody><tr>
<td>-C</td>
<td>按列输出</td>
<td>列数</td>
</tr>
<tr>
<td>-D</td>
<td>替换路径成带 <code>~</code> 的版本</td>
<td>无</td>
</tr>
<tr>
<td>-N</td>
<td>使用 <code>\x00</code> 作为字符串的间隔</td>
<td>无</td>
</tr>
<tr>
<td>-O</td>
<td>降序排列</td>
<td>无</td>
</tr>
<tr>
<td>-P</td>
<td>输出颜色和特殊样式</td>
<td>无</td>
</tr>
<tr>
<td>-R</td>
<td>模拟 <code>echo</code> 命令</td>
<td>无</td>
</tr>
<tr>
<td>-S</td>
<td>放命令放入历史命令文件（要加引号）</td>
<td>无</td>
</tr>
<tr>
<td>-X</td>
<td>替换所有 tab 为空格</td>
<td>tab 对应空格数</td>
</tr>
<tr>
<td>-a</td>
<td>和 <code>-c</code>/<code>-C</code> 一起使用时，改为从左到右</td>
<td>无</td>
</tr>
<tr>
<td>-b</td>
<td>识别出 bindkey 转义字符串</td>
<td>无</td>
</tr>
<tr>
<td>-c</td>
<td>按列输出（自动决定列数）</td>
<td>无</td>
</tr>
<tr>
<td>-f</td>
<td>同 <code>printf</code></td>
<td>无</td>
</tr>
<tr>
<td>-i</td>
<td>和 <code>-o</code>/<code>-O</code> 一起用时，大小写不敏感排序</td>
<td>无</td>
</tr>
<tr>
<td>-l</td>
<td>使用换行符作为字符串分隔符</td>
<td>无</td>
</tr>
<tr>
<td>-m</td>
<td>只输出匹配的字符串</td>
<td>匹配模式字符串</td>
</tr>
<tr>
<td>-n</td>
<td>不自动添加最后的换行符</td>
<td>无</td>
</tr>
<tr>
<td>-o</td>
<td>升序排列</td>
<td>无</td>
</tr>
<tr>
<td>-r</td>
<td>不处理转义字符</td>
<td>无</td>
</tr>
<tr>
<td>-s</td>
<td>放命令放入历史命令文件（不加引号）</td>
<td>无</td>
</tr>
<tr>
<td>-u</td>
<td>指定 fd 输出</td>
<td>fd 号</td>
</tr>
<tr>
<td>-v</td>
<td>把内容保存到变量</td>
<td>变量名</td>
</tr>
<tr>
<td>-x</td>
<td>替换行首的 tab 为空格</td>
<td>tab 对应空格数</td>
</tr>
<tr>
<td>-z</td>
<td>把内容放置到命令行编辑区</td>
<td>无</td>
</tr>
</tbody></table>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://zsh.sourceforge.net/Guide/zshguide05.html">http://zsh.sourceforge.net/Guide/zshguide05.html</a></p>
<h1 id="第四篇-字符串处理之通配符"><a href="#第四篇-字符串处理之通配符" class="headerlink" title="第四篇 字符串处理之通配符"></a>第四篇 字符串处理之通配符</h1><h3 id="导读-3"><a href="#导读-3" class="headerlink" title="导读"></a>导读</h3><p>这是字符串处理系列的第三篇文章。前两篇基本覆盖了字符串处理中的常用操作，但在字符串匹配方面，没有详细展开。</p>
<p>通配符（glob）是 shell 中的一个比较重要的概念，可以认为是正则表达式的简化版本。通配符在字符串匹配和文件名搜索等方面非常有用。本篇只讲它在字符串匹配上的用法。</p>
<h3 id="通配符的基本用法"><a href="#通配符的基本用法" class="headerlink" title="通配符的基本用法"></a>通配符的基本用法</h3><p>之前在讲字符串匹配判断时，通配符出现过，就是 <code>*$str*</code> 两边的星号。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% str1=abcd</span><br><span class="line">% str2=bc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 星号要在引号外边</span></span><br><span class="line">% [[ <span class="variable">$str1</span> == *<span class="variable">$str2</span>* ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意带通配符的字符串必须放在右边</span></span><br><span class="line">% [[ *<span class="variable">$str2</span>* == <span class="variable">$str1</span> ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>星号是最常用的通配符，用于匹配任意数量（包括 0 个）的任意字符。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 问号用于匹配一个任意字符</span></span><br><span class="line">% [[ abcd == ab?? ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中括号用于匹配出现在其中的单个字符</span></span><br><span class="line">% [[ abcd == abc[bcd] ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果中括号里第一个字符是 ^，则匹配除了除了中括号里的单个字符</span></span><br><span class="line">% [[ abcd == abc[^de] ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">% [[ abcd == abc[^ce] ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中括号里可以指定字符的范围</span></span><br><span class="line">% [[ a4 == [a-b][2-5] ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以指定多个字符范围，并且可以掺杂其他字符</span></span><br><span class="line">% [[ B4 == [a-cdddA-B][2-5] ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尖括号用于匹配一定范围的单个整数</span></span><br><span class="line">% [[ 123 == 12&lt;3-4&gt; ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以匹配整个整数</span></span><br><span class="line">% [[ 123 == &lt;100-200&gt; ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以没有上下界，默认的下界是 0，上界是正无穷</span></span><br><span class="line">% [[ 123 == &lt;100-&gt; &amp;&amp; 123 == &lt;-200&gt; ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以上下界都没有，那么会匹配任意正整数和 0</span></span><br><span class="line"><span class="comment"># 这个可以用来判断字符串是否构成整数</span></span><br><span class="line"><span class="comment"># [[ 123 == &lt;-&gt; ]] &amp;&amp; echo good</span></span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># ( 1 | 2 | ... ) 用于同时判断多个条件，满足一个即可</span></span><br><span class="line">%  [[ ab == (aa|ab) ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果中括号里要用 - 或者 ^，放在最后即可，不需要转义</span></span><br><span class="line">% [[ -^3 == [a-c-][3^-][3^-] ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上是通配符的基本用法，总结一下。</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>任意数量的任意字符</td>
<td></td>
</tr>
<tr>
<td>?</td>
<td>任意一个字符</td>
<td></td>
</tr>
<tr>
<td>[abcd]</td>
<td>abcd 中的任意一个字符</td>
<td></td>
</tr>
<tr>
<td>[^abcd]</td>
<td>除 abcd 外的任意一个字符</td>
<td></td>
</tr>
<tr>
<td>[a-c]</td>
<td>a 和 c 之间的一个字符</td>
<td></td>
</tr>
<tr>
<td>[a-cB-Dxyz]</td>
<td>a 和 c 之间、B 和 D 之间以及 xyz 中的一个字符</td>
<td></td>
</tr>
<tr>
<td>&lt;1-100&gt;</td>
<td>1 和 100 之间的整数</td>
<td></td>
</tr>
<tr>
<td>&lt;-50&gt;</td>
<td>0 和 50 之间的整数</td>
<td></td>
</tr>
<tr>
<td>&lt;100-&gt;</td>
<td>大于 100 的整数</td>
<td></td>
</tr>
<tr>
<td>&lt;-&gt;</td>
<td>任意正整数和 0</td>
<td></td>
</tr>
<tr>
<td>([a-c]|&lt;1-100&gt;)</td>
<td>a 和 c 之间的一个字符或者 1 和 100 之间的整数</td>
<td></td>
</tr>
</tbody></table>
<h3 id="加强版通配符"><a href="#加强版通配符" class="headerlink" title="加强版通配符"></a>加强版通配符</h3><p>Zsh 还支持加强版通配符，功能更多一些。如果使用加强版的通配符，需要先在代码里加上 <code>setopt EXTENDED_GLOB</code>。</p>
<table>
<thead>
<tr>
<th>通配符</th>
<th>含义</th>
<th>匹配的样例</th>
</tr>
</thead>
<tbody><tr>
<td>^abc</td>
<td>除了 abc 外的任意字符串</td>
<td>aaa</td>
</tr>
<tr>
<td>abc^abc</td>
<td>以 abc 开头，但后边不是 abc 的字符串</td>
<td>abcabd</td>
</tr>
<tr>
<td>a*c~abc</td>
<td>符合 a*c 但不是 abc 的字符串</td>
<td>adc</td>
</tr>
<tr>
<td>a#</td>
<td>任意数量（包括 0）个 a</td>
<td>aaa</td>
</tr>
<tr>
<td>b##</td>
<td>一个或者多个 b</td>
<td>b</td>
</tr>
<tr>
<td>(ab)##</td>
<td>一个或者多个 ab</td>
<td>abab</td>
</tr>
<tr>
<td>(#i)abc</td>
<td>忽略大小写的 abc</td>
<td>AbC</td>
</tr>
<tr>
<td>(#i)ab(#I)c</td>
<td>忽略大小写的 ab 接着 c</td>
<td>ABc</td>
</tr>
<tr>
<td>(#l)aBc</td>
<td>a 和 c 忽略大小写，但 B 必须大写 的 aBc</td>
<td>aBC</td>
</tr>
<tr>
<td>(#a1)abc</td>
<td>最多错（多或缺也算）一个字符的 abc</td>
<td>a2c 或 ab 或 abcd</td>
</tr>
</tbody></table>
<p>此外还有一些更高级的用法，暂时先略过。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>字符串的内容先告一段落，但之后的文章依然会不断地涉及字符串，因为数组和哈希表里的内容通常是字符串，处理目录文件时也涉及大量的字符串操作等等，届时会有新的字符串处理方法。此外，如果我发现新的处理字符串的方法或者技巧，也会更新这几篇文章。</p>
<h3 id="参考-2"><a href="#参考-2" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></p>
<h1 id="第五篇-数组"><a href="#第五篇-数组" class="headerlink" title="第五篇 数组"></a>第五篇 数组</h1><h3 id="导读-4"><a href="#导读-4" class="headerlink" title="导读"></a>导读</h3><p>了解完结构比较简单的字符串后，我们来看更复杂一些的数组。其实字符串在 zsh 中也可以当字符数组操作，但很少有需要把字符串当数组来处理的场景。本篇中主要讲的是字符串数组，复杂度要比单个字符串高一些。</p>
<p>在实际的脚本编写中，较少需要处理单个的字符串。往往需要处理从各个地方过来的大量文本，不可避免会用到数组。用好数组，会让文本处理工作事半功倍。</p>
<p>本篇只涉及数组的基础用法。</p>
<h3 id="数组定义"><a href="#数组定义" class="headerlink" title="数组定义"></a>数组定义</h3><p>数组可以直接赋值使用，不需要提前声明。等号和小括号之间不能有空格，小括号中的元素以空格隔开。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">% array=(a bc ccc dddd)</span><br><span class="line"><span class="comment"># 用 $array 即可访问数组全部元素，输出时元素以空格分隔</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">a bc ccc dddd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 print -l 可以每行输出一个元素</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">a</span><br><span class="line">bc</span><br><span class="line">ccc</span><br><span class="line">dddd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出数组中的元素个数，用法和取字符串长度一样</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$#array</span></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含带空格的字符串</span></span><br><span class="line">% array=(a <span class="string">&quot;bc ccc&quot;</span> dddd)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">a</span><br><span class="line">bc ccc</span><br><span class="line">dddd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以换行赋值，但如果行中间有空格，依然需要加引号</span></span><br><span class="line">% array=(</span><br><span class="line">&gt; a</span><br><span class="line">&gt; bb</span><br><span class="line">&gt; <span class="string">&quot;c c c&quot;</span></span><br><span class="line">&gt; dddd</span><br><span class="line">&gt; )</span><br></pre></td></tr></table></figure>

<h3 id="元素读写"><a href="#元素读写" class="headerlink" title="元素读写"></a>元素读写</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">% array=(a bc ccc dddd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用法和取字符串的第几个字符一样，从 1 开始算</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span>[3]</span><br><span class="line">ccc</span><br><span class="line"><span class="comment"># -1 依然是最后一个元素，-2 是倒数第二个，以此类推</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span>[-1]</span><br><span class="line">dddd</span><br><span class="line"></span><br><span class="line">% array[3]=CCC</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果赋值的内容是一个空的小括号，则删除该元素</span></span><br><span class="line">% array[2]=()</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">a</span><br><span class="line">CCC</span><br><span class="line">dddd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 += 为数组添加一个新元素</span></span><br><span class="line">% array+=eeeee</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">a</span><br><span class="line">CCC</span><br><span class="line">dddd</span><br><span class="line">eeeee</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 unset 可以删除整个数组</span></span><br><span class="line">% <span class="built_in">unset</span> array</span><br><span class="line"></span><br><span class="line"><span class="comment"># array 变量变成未定义状态</span></span><br><span class="line">% <span class="built_in">echo</span> $+array</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h3 id="数组拼接"><a href="#数组拼接" class="headerlink" title="数组拼接"></a>数组拼接</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">% array1=(a b c d)</span><br><span class="line">% array2=(1 2 3 4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 += 拼接数组</span></span><br><span class="line">% array1+=(e f g)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array1</span></span><br><span class="line">a b c d e f g</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接另一个数组，小括号不可以省略，否则 array1 会被转成一个字符串</span></span><br><span class="line">% array2+=(<span class="variable">$array1</span>)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$#array2</span></span><br><span class="line">11</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉小扩号后，array1 被转成了一个字符串</span></span><br><span class="line">% array2+=<span class="variable">$array1</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$#array2</span></span><br><span class="line">12</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array2</span>[12]</span><br><span class="line">a b c d e f g</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串可以直接拼接数组而转化成数组</span></span><br><span class="line">% str=abcd</span><br><span class="line">% str+=(1234)</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$#str</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">% array1=(a bb ccc dddd)</span><br><span class="line">% array2=(1 2 3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 for 可以直接遍历数组，小括号不可省略</span></span><br><span class="line">% <span class="keyword">for</span> i (<span class="variable">$array1</span>) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">a</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line">dddd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小括号里可以放多个数组，依次遍历</span></span><br><span class="line">% <span class="keyword">for</span> i (<span class="variable">$array1</span> <span class="variable">$array2</span>) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">a</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line">dddd</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="数组切片"><a href="#数组切片" class="headerlink" title="数组切片"></a>数组切片</h3><p>数组切片和字符串切片操作方法完全相同。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% array=(a bb ccc dddd)</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span>[2,3]</span><br><span class="line">bb ccc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 依然可以多对多地替换元素</span></span><br><span class="line">% array[3,-1]=(1 2 3 4)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">a bb 1 2 3 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用另一种语法，不建议使用</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;array:0:3&#125;</span></span><br><span class="line">a bb 1</span><br></pre></td></tr></table></figure>

<h3 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h3><p>数组的元素查找方法，和字符串的子字符串查找语法一样。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">% array=(a bb ccc dddd ccc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用小 i 输出从左到右第一次匹配到的元素位置</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span>[(i)ccc]</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果找不到，返回数组大小 + 1</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span>[(i)xxx]</span><br><span class="line">6</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用大 I 输出从右到左第一次匹配到的元素位置</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span>[(I)ccc]</span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果找不到，返回 0 </span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span>[(I)xxx]</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以用大 I 判断是否存在元素</span></span><br><span class="line">% ((<span class="variable">$array</span>[(I)dddd])) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line">% ((<span class="variable">$array</span>[(I)xxx])) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% array=(aaa bbb aab bbc)</span><br><span class="line"><span class="comment"># n:2: 从指定的位置开始查找</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;array[(in:2:)aa*]&#125;</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="元素排序"><a href="#元素排序" class="headerlink" title="元素排序"></a>元素排序</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">% array=(aa CCC b DD e 000 AA 3 aa 22)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用小写字母 o 升序排列，从小到大</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(o)array&#125;</span></span><br><span class="line">000 22 3 aa aa AA b CCC DD e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用大写字母 O 降序排列，从大到小</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(O)array&#125;</span></span><br><span class="line">e DD CCC b AA aa aa 3 22 000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加 i 的话大小写不敏感</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(oi)array&#125;</span></span><br><span class="line">000 22 3 aa AA aa b CCC DD e</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% array=(cc aaa b 12 115 90)</span><br><span class="line"><span class="comment"># 加 n 的话按数字大小顺序排</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(on)array&#125;</span></span><br><span class="line">12 90 115 aaa b cc</span><br><span class="line"></span><br><span class="line"><span class="comment"># Oa 用于反转数组元素的排列顺序</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(Oa)array&#125;</span></span><br><span class="line">90 115 12 b aaa cc</span><br></pre></td></tr></table></figure>

<h3 id="去除重复元素"><a href="#去除重复元素" class="headerlink" title="去除重复元素"></a>去除重复元素</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% array=(ddd a bb a ccc bb ddd)</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(u)array&#125;</span></span><br><span class="line">ddd a bb ccc</span><br></pre></td></tr></table></figure>

<h3 id="使用连续字符或者数值构造数组"><a href="#使用连续字符或者数值构造数组" class="headerlink" title="使用连续字符或者数值构造数组"></a>使用连续字符或者数值构造数组</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 大括号中的逗号分隔的字符串会被展开</span></span><br><span class="line">% array=(aa&#123;bb,cc,11&#125;) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aabb aacc aa11</span><br><span class="line"></span><br><span class="line"><span class="comment"># .. 会将前后的数组连续展开</span></span><br><span class="line">% array=(aa&#123;1..3&#125;) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aa1 aa2 aa3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个 .. 后的数字是展开的间隔</span></span><br><span class="line">% array=(aa&#123;15..19..2&#125;) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aa15 aa17 aa19</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以从大到小展开</span></span><br><span class="line">% array=(aa&#123;19..15..2&#125;) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aa19 aa17 aa15</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以添加一个或多个前导 0</span></span><br><span class="line">% array=(aa&#123;01..03&#125;) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aa01 aa02 aa03</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单个字母也可以像数值那样展开，多个字母不行</span></span><br><span class="line">% array=(aa&#123;a..c&#125;) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aaa aab aac</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字母是按 ASCII 码的顺序展开的</span></span><br><span class="line">% array=(aa&#123;Y..c&#125;) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aaY aaZ aa[ aa\ aa] aa^ aa_ aa` aaa aab aac</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这些用法都可以用在 for 循环里边</span></span><br><span class="line">% <span class="keyword">for</span> i (aa&#123;a..c&#125;) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">aaa</span><br><span class="line">aab</span><br><span class="line">aac</span><br></pre></td></tr></table></figure>

<h3 id="从字符串构造数组"><a href="#从字符串构造数组" class="headerlink" title="从字符串构造数组"></a>从字符串构造数组</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">% str=<span class="string">&quot;a bb ccc dddd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&#123;=str&#125; 可以将 str 内容按空格切分成数组</span></span><br><span class="line">% array=(<span class="variable">$&#123;=str&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span>[2,3]</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% str=<span class="string">&quot;a:bb:ccc:dddd&quot;</span></span><br><span class="line"><span class="comment"># 如果是其他分隔符，可以设置 IFS 环境变量指定</span></span><br><span class="line">% IFS=:</span><br><span class="line">% array=(<span class="variable">$&#123;=str&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span>[2,3]</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% str=<span class="string">&quot;a\nbb\nccc\ndddd&quot;</span></span><br><span class="line"><span class="comment"># 如果是其他分隔符，也可以用 (s:x:) 指定</span></span><br><span class="line">% array=(<span class="variable">$&#123;(s:\n:)str&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span>[2,3]</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% str=<span class="string">&quot;a##bb##ccc##dddd&quot;</span></span><br><span class="line"><span class="comment"># 分隔符可以是多个字符</span></span><br><span class="line">% array=(<span class="variable">$&#123;(s:##:)str&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span>[2,3]</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% str=<span class="string">&quot;a:bb:ccc:dddd&quot;</span></span><br><span class="line"><span class="comment"># 如果分隔符是 :，可以 (s.:.)</span></span><br><span class="line">% array=(<span class="variable">$&#123;(s.:.)str&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span>[2,3]</span><br><span class="line">bb</span><br><span class="line">ccc</span><br></pre></td></tr></table></figure>

<h3 id="从文件构造数组"><a href="#从文件构造数组" class="headerlink" title="从文件构造数组"></a>从文件构造数组</h3><p><code>test.txt</code> 内容。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line">dddd</span><br></pre></td></tr></table></figure>

<p>每行一个元素。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># f 的功能是将字符串以换行符分隔成数组</span></span><br><span class="line"><span class="comment"># 双引号不可省略，不然会变成一个字符串，引号也可以加在 $&#123; &#125; 上</span></span><br><span class="line">% array=(<span class="variable">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">a</span><br><span class="line">bb</span><br><span class="line">ccc</span><br><span class="line">dddd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不加引号的效果</span></span><br><span class="line">% array=(<span class="variable">$&#123;(f)$(&lt;test.txt)&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">a bb ccc dddd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件构造数组，并将每行按分隔符 : 分隔后输出所有列</span></span><br><span class="line"><span class="keyword">for</span> i (<span class="variable">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>) &#123;</span><br><span class="line">    array=(<span class="variable">$&#123;(s.:.)i&#125;</span>)</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$array</span>[1,-1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="从文件列表构造数组"><a href="#从文件列表构造数组" class="headerlink" title="从文件列表构造数组"></a>从文件列表构造数组</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的 * 即上一篇讲的通配符，所有的用法都可以在这里使用。</span></span><br><span class="line">% array=(/usr/bin/vim*)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">/usr/bin/vim</span><br><span class="line">/usr/bin/vimdiff</span><br><span class="line">/usr/bin/vimtutor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 要比 ls /usr/bin/[a-b]?? | wc -l 快很多</span></span><br><span class="line">% array=(/usr/bin/[a-b]??) &amp;&amp; <span class="built_in">print</span> <span class="variable">$#array</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="数组交集差集"><a href="#数组交集差集" class="headerlink" title="数组交集差集"></a>数组交集差集</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% array1=(1 2 3)</span><br><span class="line">% array2=(1 2 4)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个数组的交集，只输出两个数组都有的元素</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;array1:*array2&#125;</span></span><br><span class="line">1 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个数组的差集，只输出 array1 中有，而 array2 中没有的元素</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;array1:|array2&#125;</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有重复元素，不会去重</span></span><br><span class="line">% array1=(1 1 2 3 3)</span><br><span class="line">% array2=(4 4 1 1 2 2)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;array1:*array2&#125;</span></span><br><span class="line">1 1 2</span><br></pre></td></tr></table></figure>

<h3 id="数组交叉合并"><a href="#数组交叉合并" class="headerlink" title="数组交叉合并"></a>数组交叉合并</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">% array1=(a b c d)</span><br><span class="line">% array2=(1 2 3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从 array1 取一个，再从 array2 取一个，以此类推，一个数组取完了就结束</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;array1:^array2&#125;</span></span><br><span class="line">a 1 b 2 c 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果用 :^^，只有一个数组取完了的话，继续从头取，直到第二个数组也取完了</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;array1:^^array2&#125;</span></span><br><span class="line">a 1 b 2 c 3 d 1</span><br></pre></td></tr></table></figure>

<h3 id="对数组中的字符串进行统一的处理"><a href="#对数组中的字符串进行统一的处理" class="headerlink" title="对数组中的字符串进行统一的处理"></a>对数组中的字符串进行统一的处理</h3><p>一些处理字符串的方法（主要是各种形式的截取、替换、转换等等），也可以用在数组上，效果是对数组中所有元素统一处理。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% array=(/a/b.htm /a/c /a/b/c.txt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># :t 是取字符串中的文件名，可以用在数组上，取所有元素的文件名</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$&#123;array:t&#125;</span></span><br><span class="line">b.htm</span><br><span class="line">c</span><br><span class="line">c.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># :e 是取扩展名，如果没有没有扩展名，结果数组中不会添加空字符串</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$&#123;array:e&#125;</span></span><br><span class="line">htm</span><br><span class="line">txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串替换等操作也可以对数组使用，替换所有字符串</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$&#123;array/a/j&#125;</span></span><br><span class="line">/j/b.txt</span><br><span class="line">/j/c</span><br><span class="line">/j/b/c.txt</span><br></pre></td></tr></table></figure>

<p><code>:#</code> 也可以在数组上用，但更实用一些。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% array=(aaa bbb ccc)</span><br><span class="line"></span><br><span class="line"><span class="comment"># :# 是排除匹配到的元素，类似 grep -v</span></span><br><span class="line">% <span class="built_in">print</span> <span class="variable">$&#123;array:#a*&#125;</span></span><br><span class="line">bbb ccc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前边加 (M)，是反转后边的效果，即只输出匹配到的元素，类似 grep</span></span><br><span class="line">% <span class="built_in">print</span> <span class="variable">$&#123;(M)array:#a*&#125;</span></span><br><span class="line">aaa</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多个操作可以同时进行，(U) 是把字符串转成大写字母</span></span><br><span class="line">% <span class="built_in">print</span> <span class="variable">$&#123;(UM)array:#a*&#125;</span></span><br><span class="line">AAA</span><br></pre></td></tr></table></figure>

<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>本篇讲的是数组的基础用法，还有很多复杂的操作方法，以后会提到。</p>
<h3 id="参考-3"><a href="#参考-3" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://zshwiki.org/home/scripting/array">http://zshwiki.org/home/scripting/array</a></p>
<p><a target="_blank" rel="noopener" href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></p>
<h3 id="更新历史"><a href="#更新历史" class="headerlink" title="更新历史"></a>更新历史</h3><p>20170830：增加“使用连续字符或者数值构造数组”。</p>
<p>20170909：修正“从字符串构造数组”中的错误。</p>
<p>20170910：增加“从字符串构造数组”中的部分内容。</p>
<h1 id="第六篇-哈希表"><a href="#第六篇-哈希表" class="headerlink" title="第六篇 哈希表"></a>第六篇 哈希表</h1><h3 id="导读-5"><a href="#导读-5" class="headerlink" title="导读"></a>导读</h3><p>哈希表是比数组更复杂的数据结构，在某些语言里被称作关联数组或者字典等等。简单说，哈希表用于存放指定键（key）对应的值（value），键和值的关系，就像字典中单词和释义的对应关系，通过单词可以快速找到释义，而不需要从头依次遍历匹配。准确地说，哈希表只是该功能的一种实现方式，也可以使用各种树或者其他数据结构来实现，不同的实现方式适合不同的场景，使用方法是一样的。但为了简化概念，统一使用哈希表这个名称。</p>
<h3 id="哈希表定义"><a href="#哈希表定义" class="headerlink" title="哈希表定义"></a>哈希表定义</h3><p>和其他变量类型不同，哈希表是需要提前声明的，因为哈希表的赋值语法和数组一样，如果不声明，是无法区分的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">typeset</span> -A table</span><br><span class="line"><span class="comment"># 或者用 local，二者功能是一样的</span></span><br><span class="line">% <span class="built_in">local</span> -A table</span><br><span class="line"></span><br><span class="line"><span class="comment"># 赋值的语法和数组一样，但顺序依次是键、值、键、值</span></span><br><span class="line">% table=(k1 v1 k2 v2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接用 echo 只能输出值</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$table</span></span><br><span class="line">v1 v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 (kv) 同时输出键和值，(kv) 会把键和值都放到同一个数组里</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(kv)table&#125;</span></span><br><span class="line">k1 v1 k2 v2</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 哈希表的大小是键值对的数量</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$#table</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h3 id="元素读写-1"><a href="#元素读写-1" class="headerlink" title="元素读写"></a>元素读写</h3><p>读写哈希表的方法和数组类似，只是用于定位的数字变成了字符串。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以声明和赋值写到一行</span></span><br><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2 k3 v3)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$table</span>[k2]</span><br><span class="line">v2</span><br><span class="line"></span><br><span class="line">% table[k2]=<span class="string">&quot;V2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除元素的方法和数组不同，引号不能省略</span></span><br><span class="line">% <span class="built_in">unset</span> <span class="string">&quot;table[k1]&quot;</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(kv)table&#125;</span></span><br><span class="line">k2 V2 k3 v3</span><br></pre></td></tr></table></figure>

<h3 id="哈希表拼接"><a href="#哈希表拼接" class="headerlink" title="哈希表拼接"></a>哈希表拼接</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 追加元素的方法和数组一样</span></span><br><span class="line">% table+=(k4 v4 k5 v5)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$table</span></span><br><span class="line">V2 v3 v4 v5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% <span class="built_in">local</span> -A table1 table2</span><br><span class="line">% table1=(k1 v1 k2 v2)</span><br><span class="line">% table2=(k2 v222 k3 v3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接哈希表，要展开成数组再追加</span></span><br><span class="line">% table1+=(<span class="variable">$&#123;(kv)table2&#125;</span>)</span><br><span class="line"><span class="comment"># 如果键重复，会直接替换值，哈希表的键是不重复的</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(kv)table1&#125;</span></span><br><span class="line">k1 v1 k2 v222 k3 v3</span><br></pre></td></tr></table></figure>

<h3 id="哈希表遍历"><a href="#哈希表遍历" class="headerlink" title="哈希表遍历"></a>哈希表遍历</h3><p>用 <code>(kv)</code> <code>(k)</code> 等先将哈希表转化成数组，然后再遍历。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2 k3 v3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只遍历值</span></span><br><span class="line">% <span class="keyword">for</span> i (<span class="variable">$table</span>) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">v1</span><br><span class="line">v2</span><br><span class="line">v3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只遍历键</span></span><br><span class="line">% <span class="keyword">for</span> i (<span class="variable">$&#123;(k)table&#125;</span>) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">k1</span><br><span class="line">k2</span><br><span class="line">k3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 同时遍历键和值</span></span><br><span class="line">% <span class="keyword">for</span> k v (<span class="variable">$&#123;(kv)table&#125;</span>) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$k</span> -&gt; <span class="variable">$v</span>&quot;</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">k1 -&gt; v1</span><br><span class="line">k2 -&gt; v2</span><br><span class="line">k3 -&gt; v3</span><br></pre></td></tr></table></figure>

<h3 id="元素查找-1"><a href="#元素查找-1" class="headerlink" title="元素查找"></a>元素查找</h3><p>判断键是否存在。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2 k3 v3)</span><br><span class="line">% (($+table[k1])) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line">% (($+table[k4])) &amp;&amp; <span class="built_in">echo</span> good</span><br></pre></td></tr></table></figure>

<p>如果需要判断某个值是否存在，直接对值的数组判断即可。但这样做就体现不出哈希表的优势了。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2 k3 v3)</span><br><span class="line"><span class="comment"># value 是值的数组，也可以用 local -a 强行声明为数组</span></span><br><span class="line">% value=(<span class="variable">$table</span>)</span><br><span class="line"></span><br><span class="line">% (( <span class="variable">$value</span>[(I)v1] )) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line">% (( <span class="variable">$value</span>[(I)v4] )) &amp;&amp; <span class="built_in">echo</span> good</span><br></pre></td></tr></table></figure>

<h3 id="元素排序-1"><a href="#元素排序-1" class="headerlink" title="元素排序"></a>元素排序</h3><p>对哈希表元素排序的方法，和数组类似，多了 <code>k</code> <code>v</code> 两个选项，其余的选项如 <code>o</code>（升序）、<code>O</code>（降序）、<code>n</code>（按数字大小）、<code>i</code>（忽略大小写）等通用，不再一一举例。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table=(aa 33 cc 11 bb 22)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只对值排序</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(o)table&#125;</span></span><br><span class="line">11 22 33</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只对键排序</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(ok)table&#125;</span></span><br><span class="line">aa bb cc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 键值放在一起排序</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(okv)table&#125;</span></span><br><span class="line">11 22 33 aa bb cc</span><br></pre></td></tr></table></figure>

<h3 id="从字符串、文件构造哈希表"><a href="#从字符串、文件构造哈希表" class="headerlink" title="从字符串、文件构造哈希表"></a>从字符串、文件构造哈希表</h3><p>因为哈希表可以从数组构造，所以从字符串、文件构造哈希表，和数组的操作是一样的，不再一一举例。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% str=<span class="string">&quot;k1 v1 k2 v2 k3 v3&quot;</span></span><br><span class="line">% <span class="built_in">local</span> -A table=(<span class="variable">$&#123;=str&#125;</span>)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$table</span></span><br><span class="line">v1 v2 v3</span><br></pre></td></tr></table></figure>

<h3 id="对哈希表中的每个元素统一处理"><a href="#对哈希表中的每个元素统一处理" class="headerlink" title="对哈希表中的每个元素统一处理"></a>对哈希表中的每个元素统一处理</h3><p>对哈希表中的每个元素统一处理，和对数组的操作是类似的，多了 <code>k</code> <code>v</code> 两个选项用于指定是对键处理还是对值处理，可以一起处理。不再一一举例。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2 k3 v3)</span><br><span class="line">% <span class="built_in">print</span> <span class="variable">$&#123;(U)table&#125;</span></span><br><span class="line">V1 V2 V3</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> <span class="variable">$&#123;(Uk)table&#125;</span></span><br><span class="line">K1 K2 K3</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> <span class="variable">$&#123;(Ukv)table&#125;</span></span><br><span class="line">K1 V1 K2 V2 K3 V3</span><br></pre></td></tr></table></figure>

<p><code>:#</code> 也可以在哈希表上用。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2 k3 v3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 排除匹配到的值</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;table:#v1&#125;</span></span><br><span class="line">v2 v3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只输出匹配到的键</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(Mk)table:#k[1-2]&#125;</span></span><br><span class="line">k1 k2</span><br></pre></td></tr></table></figure>

<h3 id="多维哈希表"><a href="#多维哈希表" class="headerlink" title="多维哈希表"></a>多维哈希表</h3><p>Zsh 并不支持多维哈希表以及多维数组，但可以通过一些方法来模拟，以实现一部分功能。</p>
<h4 id="用一维哈希表模拟多维哈希表"><a href="#用一维哈希表模拟多维哈希表" class="headerlink" title="用一维哈希表模拟多维哈希表"></a>用一维哈希表模拟多维哈希表</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table</span><br><span class="line"><span class="comment"># 这里用 , 作为分隔符，也可以用其他符号。</span></span><br><span class="line">% table[1,1]=a</span><br><span class="line">% table[1,2]=b</span><br><span class="line">% table[k,v]=c</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$table</span>[1,1] <span class="variable">$table</span>[1,2] <span class="variable">$table</span>[k,v]</span><br><span class="line">a b c</span><br></pre></td></tr></table></figure>

<p>好处：使用方便，而且支持的维数不受限制。</p>
<p>坏处：功能太单一，比如不能对 <code>table[1]</code> 进行处理。</p>
<h4 id="用字符串分割访问来模拟多维哈希表"><a href="#用字符串分割访问来模拟多维哈希表" class="headerlink" title="用字符串分割访问来模拟多维哈希表"></a>用字符串分割访问来模拟多维哈希表</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -A table</span><br><span class="line"><span class="comment"># 分隔符为空格</span></span><br><span class="line">% table[1]=<span class="string">&#x27;a b&#x27;</span></span><br><span class="line">% table[2]=<span class="string">&#x27;c d&#x27;</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$table</span>[1] <span class="variable">$&#123;table[1][(w)2]&#125;</span> <span class="variable">$&#123;table[2][(w)1]&#125;</span></span><br><span class="line">a b</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分隔符不是空格</span></span><br><span class="line">% table[a]=<span class="string">&#x27;aa,bb&#x27;</span></span><br><span class="line">% table[b]=<span class="string">&#x27;cc,dd&#x27;</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$table</span>[a] <span class="variable">$&#123;table[a][(ws:,:)2]&#125;</span> <span class="variable">$&#123;table[b][(ws:,:)1]&#125;</span></span><br><span class="line">aa,bb</span><br><span class="line">bb</span><br><span class="line">cc</span><br></pre></td></tr></table></figure>

<p>好处：可以对 <code>table[1]</code> 进行处理。</p>
<p>坏处：不大方便，性能也不好。而且功能同样受限，比如第一维只能是数组，不能是哈希表。可以支持更多维，但需要再增加新的分隔符，使用起来更麻烦。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>本篇简单讲了哈希表的基本用法。篇幅不长，但因为哈希表的操作和数组类似，很多操作数组的方法都可以用作哈希表上，而且可以把键或者值单独作为数组处理，所以操作哈希表更为复杂一些。</p>
<p>另外还有一些更进阶的处理数组和哈希表方法，之后会讲到。</p>
<h1 id="第七篇-数值计算"><a href="#第七篇-数值计算" class="headerlink" title="第七篇 数值计算"></a>第七篇 数值计算</h1><h3 id="导读-6"><a href="#导读-6" class="headerlink" title="导读"></a>导读</h3><p>数值计算并非 zsh 的强项，但应付一些简单的场景还是没问题的。并且 zsh 提供一个数值计算库，里边有一些比较常用的数学函数。</p>
<h3 id="整数和浮点数类型"><a href="#整数和浮点数类型" class="headerlink" title="整数和浮点数类型"></a>整数和浮点数类型</h3><p>Zsh 中通常不用指定变量类型，但也可以指定。对数值计算来说，区分整数和浮点数是很重要的，不指定变量类型会带来不方便。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 整数</span></span><br><span class="line">% <span class="built_in">integer</span> i=123</span><br><span class="line"><span class="comment"># (t) 用于输出变量类型</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(t)i&#125;</span></span><br><span class="line"><span class="built_in">integer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数</span></span><br><span class="line">% <span class="built_in">float</span> f=123.456</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(t)f&#125;</span></span><br><span class="line"><span class="built_in">float</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意一旦指定了变量类型，类型就不会变了，除非再重新指定其他类型，或者用 unset 删除掉 </span></span><br><span class="line"><span class="comment"># 如果把浮点数赋值给整数变量，会取整</span></span><br><span class="line">% i=12.34</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">12</span><br><span class="line">% a=-12.34</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$a</span></span><br><span class="line">-12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数是 64 位的带符号整数（在 32 位系统下也是）</span></span><br><span class="line">% <span class="built_in">echo</span> $((-<span class="number">2</span> ** <span class="number">63</span>)) $((<span class="number">2</span> ** <span class="number">63</span> - <span class="number">1</span>))</span><br><span class="line">-9223372036854775808 9223372036854775807</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浮点数是 64 位带符号浮点数（在 32 位系统下也是）</span></span><br><span class="line">% <span class="built_in">echo</span> $((-<span class="number">1.79</span>e-<span class="number">308</span>)) $((<span class="number">1.79</span>e308))</span><br><span class="line">-1.79e-308 1.79e+308</span><br></pre></td></tr></table></figure>

<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>数值计算主要是在 <code>(( ))</code> 或者 <code>$(( ))</code> 中进行的，在 <code>$[ ]</code> 或者 <code>$var[ ]</code>（可用于数组索引的计算）中也能进行一部分，这里统一使用小括号。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">integer</span> i=123</span><br><span class="line">% <span class="built_in">float</span> f=123.456</span><br><span class="line"></span><br><span class="line"><span class="comment"># $(( )) 会计算后返回数值</span></span><br><span class="line">% <span class="built_in">echo</span> $((i*f))</span><br><span class="line">15185.088</span><br><span class="line"></span><br><span class="line"><span class="comment"># (( )) 用于判断数值比较的结果</span></span><br><span class="line">% ((i &lt; f &amp;&amp; i + 1 &gt; f)) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 (( )) 中也可以给变量赋值</span></span><br><span class="line"><span class="comment"># (( )) 中的语法类似 c 语言，变量名前不需要 $，等号两边可以有空格</span></span><br><span class="line">% <span class="built_in">float</span> result</span><br><span class="line">% ((result = i / f))</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">9.963063764e-01</span><br></pre></td></tr></table></figure>

<p>运算符列表：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>功能</th>
<th>样例</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code> <code>-</code> <code>*</code> <code>/</code></td>
<td>四则运算</td>
<td>1 + 2 * 3 / 4</td>
</tr>
<tr>
<td><code>**</code></td>
<td>乘方</td>
<td>3 ** 3.5</td>
</tr>
<tr>
<td><code>%</code></td>
<td>取余</td>
<td>5 % 3</td>
</tr>
<tr>
<td><code>++</code> <code>--</code></td>
<td>自增、自减</td>
<td>i++（返回 i） ++i（返回 i + 1）</td>
</tr>
<tr>
<td><code>&amp;</code> | <code>^</code></td>
<td>按位与、按位或、按位异或</td>
<td>11 &amp; 13</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位取反</td>
<td>~15</td>
</tr>
<tr>
<td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
<td>按位左移、按位右移</td>
<td>1 &lt;&lt; 3</td>
</tr>
<tr>
<td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
<td>大小比较</td>
<td>2 &lt;= 4</td>
</tr>
<tr>
<td><code>==</code> <code>!=</code></td>
<td>相等比较</td>
<td>2 != 4</td>
</tr>
<tr>
<td><code>&amp;&amp;</code> ||</td>
<td>逻辑与、逻辑或</td>
<td>2 &lt;= 4 &amp;&amp; 1 != 3 || 5 &gt; 0</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td>! 1 &gt; 2</td>
</tr>
<tr>
<td><code>^^</code></td>
<td>逻辑异或（两个中只有一个为真）</td>
<td>1 &gt; 0 ^^ 1 &lt; 0</td>
</tr>
<tr>
<td><code>=</code></td>
<td>赋值</td>
<td>i = 10</td>
</tr>
<tr>
<td><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>**=</code> <code>&amp;=</code> <code>^=</code> |= <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&amp;&amp;=</code> <code>^^=</code> ||=</td>
<td>复合赋值</td>
<td>i += 10</td>
</tr>
<tr>
<td><code>( )</code></td>
<td>调整优先级</td>
<td>(1 + 2 ) * 3</td>
</tr>
<tr>
<td><code>? :</code></td>
<td>三元运算符</td>
<td>1 &gt; 2 ? 100 : 200</td>
</tr>
<tr>
<td><code>,</code></td>
<td>逗号运算符（只返回后者）</td>
<td>40, 20 == 20</td>
</tr>
</tbody></table>
<p>运算符的优先级和其他编程语言的差不多，不列出了，如果不确定可以加小括号。这部分内容和 c、java、javascript 等语言基本一致。</p>
<h3 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h3><p>Zsh 包含了一个数学模块，如果需要使用数学函数，需要先加载 <code>zsh/mathfunc</code> 模块。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">zmodload</span> -i zsh/mathfunc</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> $((sin(<span class="number">0</span>) + ceil(<span class="number">14.4</span>)))</span><br><span class="line">15.0</span><br></pre></td></tr></table></figure>

<p>函数列表：</p>
<table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>abs</code></td>
<td>求绝对值</td>
</tr>
<tr>
<td><code>ceil</code></td>
<td>向上取整</td>
</tr>
<tr>
<td><code>floor</code></td>
<td>向下取整</td>
</tr>
<tr>
<td><code>int</code></td>
<td>截断取整</td>
</tr>
<tr>
<td><code>float</code></td>
<td>转换成浮点数</td>
</tr>
<tr>
<td><code>sqrt</code></td>
<td>开平方</td>
</tr>
<tr>
<td><code>cbrt</code></td>
<td>开立方</td>
</tr>
<tr>
<td><code>log</code></td>
<td>自然对数</td>
</tr>
<tr>
<td><code>log10</code></td>
<td>常用对数</td>
</tr>
<tr>
<td><code>rand48</code></td>
<td>随机数</td>
</tr>
</tbody></table>
<p>更多函数：</p>
<p><code>acos</code>、<code>acosh</code>、<code>asin</code>、<code>asinh</code>、<code>atan</code>、<code>atanh</code>、<code>cos</code>、<code>cosh</code>、<code>erf</code>、<code>erfc</code>、<code>exp</code>、 <code>expm1</code>、<code>fabs</code>、<code>gamma</code>、<code>j0</code>、<code>j1</code>、<code>lgamma</code>、<code>log1p</code>、<code>logb</code>、<code>sin</code>、<code>sinh</code>、<code>tan</code>、 <code>tanh</code>、<code>y0</code>、<code>y1</code>、<code>ilogb</code>、<code>signgam</code>、<code>copysign</code>、<code>fmod</code>、<code>hypot</code>、<code>nextafter</code>、<code>jn</code>、 <code>yn</code>、<code>ldexp</code>、<code>scalb</code></p>
<h3 id="参考-4"><a href="#参考-4" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></p>
<h1 id="第八篇-变量修饰语"><a href="#第八篇-变量修饰语" class="headerlink" title="第八篇 变量修饰语"></a>第八篇 变量修饰语</h1><h3 id="导读-7"><a href="#导读-7" class="headerlink" title="导读"></a>导读</h3><p>我们已经了解了字符串、数组、哈希表、整数、浮点数的基本用法，但应付某些复杂的场景依然力不从心。</p>
<p>变量修饰语是 zsh 中有一个很独特的概念，对变量进行操作，功能上和函数类似，但用起来更方便，在一行代码里实现复杂功能主要靠它了。而代价是可读性更差，怎么用就要自己权衡了。它也是 zsh 最有特色的部分之一。变量修饰语主要应用于数组和哈希表，但也有一小部分可以应用于字符串（整数和浮点数也会被当成字符串处理）。</p>
<h3 id="变量修饰语的格式"><a href="#变量修饰语的格式" class="headerlink" title="变量修饰语的格式"></a>变量修饰语的格式</h3><p>其实前边的文章中，变量修饰语已经出现过，但当时没有详细说明。</p>
<p>比如在大小写转换的例子中。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% str=<span class="string">&quot;ABCDE abcde&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成大写，(U) 和 :u 两种用法效果一样</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(U)str&#125;</span> --- <span class="variable">$&#123;str:u&#125;</span></span><br><span class="line">ABCDE ABCDE --- ABCDE ABCDE</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转成小写，(L) 和 :l 两种用法效果一样</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(L)str&#125;</span> --- <span class="variable">$&#123;str:l&#125;</span></span><br><span class="line">abcde abcde --- abcde abcde</span><br></pre></td></tr></table></figure>

<p>这里的 <code>(U)</code>、<code>:l</code> 等等都是变量修饰语。变量修饰语主要有两种格式。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;(x)var&#125;</span></span><br><span class="line"><span class="variable">$&#123;var:x&#125;</span></span><br></pre></td></tr></table></figure>

<p>其中 var 是变量名，x 是 一个或多个字母，不同字母的功能不同。第二行的冒号也可能是其他符号。${var} 和 $var 基本相同，大括号用于避免变量名中的字符和后边的字符粘连，通常情况是不需要加大括号的。但如果使用变量修饰语，大括号就必不可少（其实第二种格式中，大括号可以省略，但考虑可读性和错误提示等因素，还是加上比较好）。</p>
<p>变量修饰语可以嵌套使用。因为加了修饰语的变量依然是变量，可以和正常的变量一样处理。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">% str=abc</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(U)str&#125;</span></span><br><span class="line">ABC</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(C)<span class="variable">$&#123;(U)str&#125;</span>&#125;</span></span><br><span class="line">Abc</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;<span class="variable">$&#123;a:u&#125;</span>:l&#125;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以简化成</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;a:u:l&#125;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以两种风格嵌套在一起</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(C)<span class="variable">$&#123;a:u&#125;</span>&#125;</span></span><br><span class="line">Abc</span><br></pre></td></tr></table></figure>

<p>这里要注意 $ 之后全程不能有空格，否则会有语法错误。也就是说不能通过加空格来避免因为字符挤在一起造成的可读性变差。但熟悉了格式后，就可以比较容易识别出代码的功能。比较复杂的逻辑可以换行继续写，而没必要一定嵌套使用。</p>
<p>知道了变量修饰语的用法后，重要的就是都有哪些可以使用的变量修饰语了。</p>
<h3 id="变量默认值"><a href="#变量默认值" class="headerlink" title="变量默认值"></a>变量默认值</h3><p>和变量默认值（读取变量时如果变量为空或者不存在，使用的默认值）相关的操作，变量可以是任何类型的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">% var=123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果变量有值，就输出变量值</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;var:-abc&#125;</span></span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果变量没有值（变量不存在，为空字符串、空数组、空哈希表等），输出 abc</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;varr:-abc&#125;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% var=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 和 :- 类似，但只有变量不存在时才替换成默认值</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;var-abc&#125;</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;varr-abc&#125;</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% var=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 和 :- 类似，但如果变量没有值，则赋值为 abc</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;var:=abc&#125;</span></span><br><span class="line">abc</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% var=abc</span><br><span class="line"><span class="comment"># 不管 var 有没有值，都赋值为 123</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;var::=123&#125;</span></span><br><span class="line">123</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">123</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% var=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 如果 var 没有值，直接报错</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;var:?error&#125;</span></span><br><span class="line">zsh: var: error</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">% var=abc</span><br><span class="line"><span class="comment"># 如果 var 有值，输出 123</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;var:+123&#125;</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;varr:+123&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="数组拼接成字符串"><a href="#数组拼接成字符串" class="headerlink" title="数组拼接成字符串"></a>数组拼接成字符串</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">% array=(aa bb cc dd)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用换行符拼接</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(F)array&#125;</span></span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc</span><br><span class="line">dd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用空格拼接</span></span><br><span class="line">% str=<span class="variable">$array</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">aa bb cc dd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用其他字符或字符串拼接</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(j:-=:)array&#125;</span></span><br><span class="line">aa-=bb-=cc-=dd</span><br></pre></td></tr></table></figure>

<h3 id="字符串切分成数组"><a href="#字符串切分成数组" class="headerlink" title="字符串切分成数组"></a>字符串切分成数组</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% str=a<span class="comment">##b##c##d</span></span><br><span class="line"></span><br><span class="line">% array=(<span class="variable">$&#123;(s:##:)str&#125;</span>)</span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br></pre></td></tr></table></figure>

<h3 id="输出变量类型"><a href="#输出变量类型" class="headerlink" title="输出变量类型"></a>输出变量类型</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意如果不加 integer 或者 float，都为字符串，但计算时会自动转换类型</span></span><br><span class="line">% <span class="built_in">integer</span> i=1</span><br><span class="line">% <span class="built_in">float</span> f=1.2</span><br><span class="line">% str=abc</span><br><span class="line">% array=(a b c)</span><br><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2)</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(t)i&#125;</span> <span class="variable">$&#123;(t)f&#125;</span> <span class="variable">$&#123;(t)str&#125;</span> <span class="variable">$&#123;(t)array&#125;</span> <span class="variable">$&#123;(t)table&#125;</span></span><br><span class="line"><span class="built_in">integer</span> <span class="built_in">float</span> scalar array association</span><br></pre></td></tr></table></figure>

<h3 id="字符串、数组或哈希表嵌套取值"><a href="#字符串、数组或哈希表嵌套取值" class="headerlink" title="字符串、数组或哈希表嵌套取值"></a>字符串、数组或哈希表嵌套取值</h3><p>可以嵌套多层。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">% str=abcde</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;<span class="variable">$&#123;str[3,5]&#125;</span>[3]&#125;</span></span><br><span class="line">e</span><br><span class="line"></span><br><span class="line">% array=(aa bb cc dd)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;<span class="variable">$&#123;array[2,3]&#125;</span>[2]&#125;</span></span><br><span class="line">cc</span><br><span class="line"><span class="comment"># 如果只剩一个元素了，就取字符串的字符</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;<span class="variable">$&#123;array[2]&#125;</span>[2]&#125;</span></span><br><span class="line">b</span><br><span class="line"></span><br><span class="line">% <span class="built_in">local</span> -A table=(k1 v1 k2 v2 k3 v3)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;<span class="variable">$&#123;table[k1]&#125;</span>[2]&#125;</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h3 id="字符串内容作为变量名再取值"><a href="#字符串内容作为变量名再取值" class="headerlink" title="字符串内容作为变量名再取值"></a>字符串内容作为变量名再取值</h3><p>不需要再通过繁琐的 eval 来做这个。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% var=abc</span><br><span class="line">% abc=123</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(P)var&#125;</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure>

<h3 id="对齐或截断数组中的字符串"><a href="#对齐或截断数组中的字符串" class="headerlink" title="对齐或截断数组中的字符串"></a>对齐或截断数组中的字符串</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">% array=(abc bcde cdefg defghi)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只取每个字符串的最后两个字符</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(l:2:)array&#125;</span></span><br><span class="line">bc de <span class="built_in">fg</span> hi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用空格补全字符串并且右对齐</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$&#123;(l:7:)array&#125;</span></span><br><span class="line">    abc</span><br><span class="line">   bcde</span><br><span class="line">  cdefg</span><br><span class="line"> defghi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用指定字符补全</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$&#123;(l:7::0:)array&#125;</span></span><br><span class="line">0000abc</span><br><span class="line">000bcde</span><br><span class="line">00cdefg</span><br><span class="line">0defghi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用指定字符补全，第二个字符只用一次</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$&#123;(l:7::0::1:)array&#125;</span></span><br><span class="line">0001abc</span><br><span class="line">001bcde</span><br><span class="line">01cdefg</span><br><span class="line">1defghi</span><br><span class="line"></span><br><span class="line"><span class="comment"># 左对齐</span></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$&#123;(r:7::0::1:)array&#125;</span></span><br><span class="line">abc1000</span><br><span class="line">bcde100</span><br><span class="line">cdefg10</span><br><span class="line">defghi1</span><br></pre></td></tr></table></figure>

<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>文中只介绍了几个比较常用的变量修饰语，还有一些没有提及，可能后续再补充。</p>
<h3 id="参考-5"><a href="#参考-5" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></p>
<h1 id="第九篇-函数和脚本"><a href="#第九篇-函数和脚本" class="headerlink" title="第九篇 函数和脚本"></a>第九篇 函数和脚本</h1><h3 id="导读-8"><a href="#导读-8" class="headerlink" title="导读"></a>导读</h3><p>很多时候，我们写的代码并不是只运行一次就不再用了，那就需要保存到文件里。我们通常称包含解释性编程语言代码的可执行文件为脚本文件，简称脚本。而在脚本内部，也会有一些可以复用的代码，我们可以把这样的代码写成函数，供其他部分调用。Zsh 中函数和脚本基本上一样的，可以认为脚本就是以文件名为函数名的函数。脚本和函数的编写方法基本相同，所以在一起讲。</p>
<p>先从函数开始，因为涉及更少的细节。</p>
<h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个很简单的函数</span></span><br><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> good</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以在前边加一个 function 关键字</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> good</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以定义一个函数了。小括号一定是空的，即使函数有参数，也无需在里边写参数列表。</p>
<p>直接输入函数名即可调用函数。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> good</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun</span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<p>用 unfunction 可以删除函数。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> good</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% <span class="built_in">unfunction</span> fun</span><br><span class="line">% fun</span><br><span class="line">zsh: <span class="built_in">command</span> not found: fun</span><br></pre></td></tr></table></figure>

<h3 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h3><p>函数可以有参数，但 zsh 中无需显式注明有几个参数，直接读取即可。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun aa</span><br><span class="line">aa</span><br><span class="line">1</span><br><span class="line">% fun aa bb cc</span><br><span class="line">aa bb cc</span><br><span class="line">3</span><br><span class="line">% fun aa bb cc dd</span><br><span class="line">aa bb cc</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<p>$n 是第 n 个参数，$# 是参数个数。如果读取的时候没有对应参数传进来，那和读取一个未定义的变量效果是一样的。函数的参数只能是字符串类型，如果把整数、浮点数传进函数里，也会被转成字符串。可以把数组传给函数，然后数组中的元素会依次成为各个参数。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$1</span> <span class="variable">$2</span> <span class="variable">$3</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% array=(11 22 33)</span><br><span class="line">% fun <span class="variable">$array</span></span><br><span class="line">11 22 33</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>这样用的好处是可以更方便地处理带空格的参数。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 遍历所有参数，$* 是包含所有参数的数组</span></span><br><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i ($*) &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun a b c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>可以用 $+n 快速判断第 n 个参数是否存在。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    (($+1)) &amp;&amp; &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>$*</code> 和 <code>$@</code>。在 bash 中， <code>$*</code> 和 <code>$@</code> 的区别是一个比较麻烦的事情，但在 zsh 中，通常没有必要使用 <code>$@</code>，所以不用踩这个坑。Bash 中需要使用 <code>$@</code> 的原因是如果使用 <code>$*</code> 并且参数中有空格的话，就分不清哪些空格是参数里的，哪些空格是参数之间的间隔符（bash 里的 <code>$*</code> 是一个字符串）。而如果使用 <code>&quot;$*&quot;</code> 的话，所有的参数都合并成一个字符串了。而 <code>&quot;$@&quot;</code> 可以保留参数中的空格，所以通常使用 <code>&quot;$@&quot;</code>。但是有些时候需要把所有参数拼接成一个字符串，那么又要使用 <code>&quot;$*&quot;</code>，所以很混乱。</p>
<p>而 zsh 中的 <code>$*</code> 会包括参数中的空格（zsh 里的 <code>$*</code> 是一个数组），所以效果和 bash 的 <code>&quot;$@&quot;</code> 是差不多的。另外在 zsh 中用 <code>&quot;$*&quot;</code> 和在 bash 中的 <code>&quot;$*&quot;</code> 效果一样，所以只用 <code>$*</code> 和 <code>&quot;$*&quot;</code> 就足够了。</p>
<h3 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h3><p>函数可以嵌套定义。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="function"><span class="title">fun2</span></span>() &#123;</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fun2 <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun aa bb</span><br><span class="line">bb</span><br></pre></td></tr></table></figure>

<p>fun2 函数是在 fun 执行过才会被定义的，但最外边也能直接访问 fun2 函数。如果想要最外边访问不了，可以在 fun 结束前调用 unfunction fun2 删除 fun2 函数。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>函数需要返回一个代表函数是否正确执行的返回值，如果是 0，代表正确执行，如果不是 0，代表有错误。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    (($+1)) &amp;&amp; &#123;</span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun 111 &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line">% fun || <span class="built_in">echo</span> bad</span><br><span class="line">bad</span><br><span class="line"></span><br><span class="line">% fun</span><br><span class="line"><span class="comment"># 也可以用 $? 获取函数返回值</span></span><br><span class="line">% <span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>

<p>遇到 return 后，函数立即结束。return 即 return 0。</p>
<p>注意返回值不是用来返回数据的，如果函数需要将字符串、整数、浮点数等返回给调用者，直接用 echo 或者 print 等命令输出即可，然后调用者用 $(fun) 获取。如果需要返回数组或者哈希表，只能通过变量（全局变量或者函数所在层次的局部变量）传递。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> 123.456</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% <span class="built_in">echo</span> $(($(fun) *<span class="number">2</span>))</span><br><span class="line">246.91200000000001</span><br></pre></td></tr></table></figure>

<p>通过全局变量返回。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array=()</span><br><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    array=(aa bb)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aa bb</span><br></pre></td></tr></table></figure>

<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数中可以直接读写函数外边的变量，并且在函数中定义的新变量在函数退出后依然存在。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str1=abcd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line">    str2=1234</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun</span><br><span class="line">abcd</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line">1234</span><br></pre></td></tr></table></figure>

<p>这通常是不符合预期的。为了避免函数内的变量“渗透”到函数外，可以使用局部变量，使用 local 定义变量。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str1=abcd</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">fun</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$str1</span></span><br><span class="line">    <span class="built_in">local</span> str2=1234</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% fun</span><br><span class="line">abcd</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数中的变量，除非确实需要留给外部使用，不然最好全部使用局部变量，避免引发 bug。</p>
<h3 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h3><p>可以认为脚本也是一个函数，但它是单独写到一个文件里的。</p>
<p>test.zsh 内容。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> good</span><br></pre></td></tr></table></figure>

<p>这是一个非常简单的脚本文件。第一行是固定的，供系统找到 zsh 解释器，#! 后加 zsh 的绝对路径即可。如果需要使用环境变量访问，可以用 #!/bin/env zsh （或者 !/usr/bin/env zsh，如果 env 在 /usr/bin/ 里边）。</p>
<p>从第二行开始，就和函数中的内容一样了。上边函数体里的内容（去掉首尾行的 fun() { 和 }，都可以写在这里边。</p>
<p>执行的话，在 test.zsh 所在目录，运行 zsh test.zsh 加参数即可（就像调用了一个名为 zsh test.zsh 的函数。也可以 chmod u+x test.zsh 给它添加可执行权限后，直接运行 ./test.zsh 加参数。</p>
<p>脚本的参数和返回值的处理方法，和函数的完全一样，这里就不举例了。</p>
<p>但函数和脚本中执行的时候是有区别的，函数是在当前的 zsh 进程里执行（也可以调用的时候加小括号在子进程执行），而脚本是在新的子进程里执行，执行完子进程即退出了，所以脚本中的变量值外界是访问不到的，无需使用 local 定义（使用也没问题）。</p>
<h3 id="exit-命令"><a href="#exit-命令" class="headerlink" title="exit 命令"></a>exit 命令</h3><p>脚本可以使用 return 返回，也可以使用 exit 命令。exit 命令用法和 return 差不多，如果不加参数则返回 0。但在代码的任何地方，调用 exit 命令即退出脚本，即使是在一个嵌套很深的函数里边理调用的。</p>
<h3 id="用-getopts-命令处理命令行选项"><a href="#用-getopts-命令处理命令行选项" class="headerlink" title="用 getopts 命令处理命令行选项"></a>用 getopts 命令处理命令行选项</h3><p>有时我们写的脚本需要支持比较复杂的命令行选项，比如 demo -i aa -t bb -cx ccc ddd，这样的话，手动处理就会很麻烦。可以使用内置的 getopts 命令。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># i: 代表可以接受一个带参数的 -i 选项</span></span><br><span class="line"><span class="comment"># c 代表可以接受一个不带参数的 -c 选项</span></span><br><span class="line"><span class="keyword">while</span> &#123;<span class="built_in">getopts</span> i:t:cv arg&#125; &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$arg</span> &#123;</span><br><span class="line">        (i)</span><br><span class="line">        <span class="comment"># $OPTARG 存放选项对应的参数</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$arg</span> option with arg: <span class="variable">$OPTARG</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (t)</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$arg</span> option with arg: <span class="variable">$OPTARG</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (c)</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$arg</span> option</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (v)</span><br><span class="line">        <span class="built_in">echo</span> version: 0.1</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (?)</span><br><span class="line">        <span class="built_in">echo</span> error</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># $OPTIND 指向剩下的第一个未处理的参数</span></span><br><span class="line"><span class="built_in">echo</span> $*[<span class="variable">$OPTIND</span>,-1]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用 shift 把之前用过的参数移走</span></span><br><span class="line"><span class="comment"># shift $((OPTIND - 1))</span></span><br><span class="line"><span class="comment"># echo $*</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">% ./demo -i aaa -t bbb -cv ccc ddd</span><br><span class="line">i option with arg: aaa</span><br><span class="line">t option with arg: bbb</span><br><span class="line">c option</span><br><span class="line">version: 0.1</span><br><span class="line">ccc ddd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以只加部分选项</span></span><br><span class="line">% ./demo -i aaa -v bbb ccc</span><br><span class="line">i option with arg: aaa</span><br><span class="line">version: 0.1</span><br><span class="line">bbb ccc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以一个选项也不加</span></span><br><span class="line">% ./demo aaa bbb</span><br><span class="line">aaa bbb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果选项不带参数，多个选项可以合并到一个 - 后</span></span><br><span class="line">% ./demo -i aaa -cv bbb ccc</span><br><span class="line">i option with arg: aaa</span><br><span class="line">c option</span><br><span class="line">version: 0.1</span><br><span class="line">bbb ccc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果该带参数的选项不带参数，会报错</span></span><br><span class="line">% ./demo -i aaa -t</span><br><span class="line">i option with arg: aaa</span><br><span class="line">./demo:3: argument expected after -t option</span><br><span class="line">error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加了不支持的选项也会报错</span></span><br><span class="line">% ./demo -i aaa -a bbb ccc</span><br><span class="line">i option with arg: aaa</span><br><span class="line">./demo:3: bad option: -a</span><br><span class="line">error</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果该带参数的选项不带参数，然后后边紧接着另一个选项，那么选项会被当作参数</span></span><br><span class="line">% ./demo -i -c aaa bbb</span><br><span class="line">i option with arg: -c</span><br><span class="line">aaa bbb</span><br></pre></td></tr></table></figure>

<p>getopts 的使用还是很方便的，但它不支持长选项（如 –log aaa）。如果需要使用长选项，可以用 getopt 命令，它是一个外部命令，可以 man getopt 查看用法。</p>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了函数和脚本的写法，重点是参数处理和返回值等等，还有很多没覆盖的地方，以后可能继续补充。</p>
<h3 id="参考-6"><a href="#参考-6" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://my.oschina.net/lenglingx/blog/410565">https://my.oschina.net/lenglingx/blog/410565</a></p>
<h3 id="更新历史-1"><a href="#更新历史-1" class="headerlink" title="更新历史"></a>更新历史</h3><p>20170901：增加用 $? 获取函数返回值的内容。</p>
<p>20170902：增加“用 getopts 命令处理命令行选项”。</p>
<h1 id="第十篇-文件查找和批量处理"><a href="#第十篇-文件查找和批量处理" class="headerlink" title="第十篇 文件查找和批量处理"></a>第十篇 文件查找和批量处理</h1><h3 id="导读-9"><a href="#导读-9" class="headerlink" title="导读"></a>导读</h3><p>寻找满足特定条件的文件路径，简称文件查找，是 shell 脚本的常见任务，因为条件复杂多样，这样的任务并不轻松。很多人使用 find 命令来做，但 find 只能覆盖一部分功能，其他的要自己进一步处理，而且 find 并不好用，和脚本其他部分配合也比较麻烦，容易出错。用 zsh 的话，基本不需要 find 命令，借助 zsh 自身的功能便足以应付多数场景，而且语法更优雅简洁不易出错。</p>
<h3 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h3><p>列出 /usr/bin 目录下以 zsh 开头的文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加 -l 为了换行显示更易读，如果需要操作这些文件，将 print -l 换成其他命令即可</span></span><br><span class="line">% <span class="built_in">print</span> -l /usr/bin/zsh*</span><br><span class="line">/usr/bin/zsh</span><br><span class="line">/usr/bin/zsh-5.4.1</span><br><span class="line">/usr/bin/zshdb</span><br></pre></td></tr></table></figure>

<p>有人可能会说用 ls /usr/bin/zsh* 就行。如果用 ls 的话，就平添了不少额外工作，因为 zsh* 已经匹配一次文件路径，结果出来了，传给 ls 后，ls 又去 stat 了一下那些文件，而这完全是多余工作，如果文件列表长的话，要多消耗不少时间。很多看起来理所当然的 shell 用法都存在类似这样的问题。所以打命令或者写脚本时，不能看结果正确就可以了，要知其所以然。如果嫌 print -l 太长，alias 个 pl 就可以了，print -l 非常常用。</p>
<p>删除 /tmp 下所有的形如 abc1234.tmp（前边字母后边数字，个数不限，但至少有一个字母和一个数字）的文件，包括子目录里的。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">setopt</span> EXTENDED_GLOB</span><br><span class="line"><span class="comment"># /**/ 是递归搜索文件</span></span><br><span class="line"><span class="comment"># ## 是前边的内容至少重复一次，&lt;-&gt; 是任何正整数或 0</span></span><br><span class="line">% rm -v /tmp/**/[a-zA-Z]<span class="comment">##&lt;-&gt;.tmp</span></span><br><span class="line">removed <span class="string">&#x27;/tmp/yaourt-tmp-goreliu/abc123.tmp&#x27;</span></span><br></pre></td></tr></table></figure>

<p>setopt EXTENDED_GLOB 是启用扩展的通配符支持，本文后续的内容默认该选项已开启，不然通配符功能太弱，建议写到 .zshrc 里边。通配符的内容之前已经讲过，可以当手册参考。</p>
<p>两个小例子热完身后开始进入正题。</p>
<h3 id="按文件属性查找"><a href="#按文件属性查找" class="headerlink" title="按文件属性查找"></a>按文件属性查找</h3><p>除了匹配文件路径外，很多时候我们还需要按文件属性查找，比如根据文件类型、权限、大小、修改时间等等。这里需要使用一个新东西，通配符修饰语。</p>
<p>先举个例子看看它的样子。列出当前目录及子目录中的所有普通文件（即 ls -l 结果中第一位是 - 的文件，非目录、符号链接、设备文件、socket、FIFO 等等）。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">print</span> -l **/*(.)</span><br><span class="line">a.txt</span><br><span class="line">b/htm</span><br></pre></td></tr></table></figure>

<p>这里比之前的例子多了个末尾的小括号，里边有一个点。这个小括号及里边的内容便是通配符修饰语，专门用于按文件属性来匹配文件。点（.）代表普通文件。</p>
<p>更多例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下的非空目录，F 是 FULL，满的意思</span></span><br><span class="line">% <span class="built_in">print</span> -l *(/F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录下的空目录，^ 是取反</span></span><br><span class="line">% <span class="built_in">print</span> -l *(/^F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录下的符号链接文件和可执行的普通文件，多种文件类型用逗号隔开</span></span><br><span class="line">% <span class="built_in">print</span> -l *(@,.x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出符合 0644 权限的普通文件</span></span><br><span class="line">% <span class="built_in">print</span> -l *(.f0644)</span><br></pre></td></tr></table></figure>

<p>那么我们来看下都有哪些可用的通配符修饰语，然后再举更复杂的例子。</p>
<h3 id="通配符修饰语列表"><a href="#通配符修饰语列表" class="headerlink" title="通配符修饰语列表"></a>通配符修饰语列表</h3><table>
<thead>
<tr>
<th>名称</th>
<th>含义</th>
<th>使用样例或补充说明</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>目录</td>
<td></td>
</tr>
<tr>
<td>F</td>
<td>非空</td>
<td>/F（非空目录） /^F（空目录）</td>
</tr>
<tr>
<td>.</td>
<td>普通文件</td>
<td></td>
</tr>
<tr>
<td>@</td>
<td>符号链接</td>
<td></td>
</tr>
<tr>
<td>=</td>
<td>socket 文件</td>
<td></td>
</tr>
<tr>
<td>p</td>
<td>FIFO 文件</td>
<td></td>
</tr>
<tr>
<td>*</td>
<td>可执行的普通文件</td>
<td></td>
</tr>
<tr>
<td>%</td>
<td>设备文件</td>
<td></td>
</tr>
<tr>
<td>%b</td>
<td>块设备文件</td>
<td></td>
</tr>
<tr>
<td>%c</td>
<td>字符设备文件</td>
<td></td>
</tr>
<tr>
<td>r</td>
<td>文件拥有着有读权限</td>
<td></td>
</tr>
<tr>
<td>w</td>
<td>文件拥有着有写权限</td>
<td></td>
</tr>
<tr>
<td>x</td>
<td>文件拥有着有执行权限</td>
<td></td>
</tr>
<tr>
<td>A</td>
<td>文件拥有组用户有读权限</td>
<td></td>
</tr>
<tr>
<td>I</td>
<td>文件拥有组用户有写权限</td>
<td></td>
</tr>
<tr>
<td>E</td>
<td>文件拥有组用户有执行权限</td>
<td></td>
</tr>
<tr>
<td>R</td>
<td>任何用户都有读权限</td>
<td></td>
</tr>
<tr>
<td>W</td>
<td>任何用户都有写权限</td>
<td></td>
</tr>
<tr>
<td>X</td>
<td>任何用户都有执行权限</td>
<td></td>
</tr>
<tr>
<td>s</td>
<td>设置了 setuid 的文件</td>
<td></td>
</tr>
<tr>
<td>S</td>
<td>设置了 setgid 的文件</td>
<td></td>
</tr>
<tr>
<td>t</td>
<td>设置了粘滞位（sticky bit）的文件</td>
<td></td>
</tr>
<tr>
<td>f</td>
<td>符合指定的权限</td>
<td>f0644 f4755 f700</td>
</tr>
<tr>
<td>e</td>
<td></td>
<td>暂无</td>
</tr>
<tr>
<td>+</td>
<td></td>
<td>暂无</td>
</tr>
<tr>
<td>d</td>
<td>指定设备号</td>
<td></td>
</tr>
<tr>
<td>l</td>
<td>硬连接个数</td>
<td>l-2（小于 2） l+3（大于 3）</td>
</tr>
<tr>
<td>U</td>
<td>当前用户拥有</td>
<td></td>
</tr>
<tr>
<td>G</td>
<td>当前用户所在组拥有</td>
<td></td>
</tr>
<tr>
<td>u</td>
<td>指定用户 id 拥有</td>
<td>u1000</td>
</tr>
<tr>
<td>g</td>
<td>指定用户组 id 拥有</td>
<td>g1000</td>
</tr>
<tr>
<td>a</td>
<td>指定文件的 atime</td>
<td>下文有说明</td>
</tr>
<tr>
<td>m</td>
<td>指定文件的 mtime</td>
<td>下文有说明</td>
</tr>
<tr>
<td>c</td>
<td>指定文件的 ctime</td>
<td>下文有说明</td>
</tr>
<tr>
<td>L</td>
<td>指定文件大小</td>
<td>下文有说明</td>
</tr>
<tr>
<td>^</td>
<td>取反</td>
<td>/^F</td>
</tr>
<tr>
<td>-</td>
<td></td>
<td>暂无</td>
</tr>
<tr>
<td>M</td>
<td></td>
<td>暂无</td>
</tr>
<tr>
<td>T</td>
<td></td>
<td>暂无</td>
</tr>
<tr>
<td>N</td>
<td>如果没匹配到，返回空而不报错</td>
<td></td>
</tr>
<tr>
<td>D</td>
<td>包含隐藏文件（. 开头）</td>
<td></td>
</tr>
<tr>
<td>n</td>
<td>按数值大小排序</td>
<td>下文有说明</td>
</tr>
<tr>
<td>o</td>
<td>递增排序</td>
<td>下文有说明</td>
</tr>
<tr>
<td>O</td>
<td>递减排序</td>
<td>下文有说明</td>
</tr>
<tr>
<td>[n]</td>
<td>只取前 n 个文件</td>
<td>.[5]</td>
</tr>
<tr>
<td>[n1,n2]</td>
<td>取第 n1 到 n2 个文件</td>
<td>/[5,10]</td>
</tr>
<tr>
<td>:X</td>
<td></td>
<td>暂无</td>
</tr>
</tbody></table>
<h3 id="更复杂的用法"><a href="#更复杂的用法" class="headerlink" title="更复杂的用法"></a>更复杂的用法</h3><h4 id="按文件时间查找文件"><a href="#按文件时间查找文件" class="headerlink" title="按文件时间查找文件"></a>按文件时间查找文件</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出最近一天修改过内容的文件</span></span><br><span class="line">% <span class="built_in">print</span> -l *(.m-1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出最近一个月没有读取过的文件</span></span><br><span class="line">% <span class="built_in">print</span> -l *(.aM+1)</span><br></pre></td></tr></table></figure>

<p>m 后边可加单位，如果没有单位，默认是天。其他单位：M（月）、w（周）、h（小时）、m（分钟）、s（秒）。+ 是指定时间之前，- 是指定时间之内。</p>
<p>a 是最后访问时间（atime），但注意如果分区挂载时指定了 noatime 或者 realtime（可以查看 /proc/mount 确认），那么 atime 并不是真正的最后访问时间。m 是最后修改时间（mtime），这里指内容修改，而不包括文件属性（如权限）的修改。c 是最后状态修改时间（ctime），如果文件内容没有修改，而文件属性发生变化，这个时间会更新。如果不能理解请在网上搜索相关文章。</p>
<h4 id="按文件大小查找文件"><a href="#按文件大小查找文件" class="headerlink" title="按文件大小查找文件"></a>按文件大小查找文件</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前目录下小于 2k 的文件</span></span><br><span class="line">% <span class="built_in">print</span> -l *(.Lk-2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前目录下大于 1m 的文件</span></span><br><span class="line">% <span class="built_in">print</span> -l *(.Lm+1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这样只能找到空文件，因为以 m 为单位的话，文件只能是 0 m 或者 1 m，不能 0.5 m</span></span><br><span class="line"><span class="comment"># 所以比 1 小就是 0 m，是空文件</span></span><br><span class="line">% <span class="built_in">print</span> -l *(.Lm-1)</span><br></pre></td></tr></table></figure>

<p>默认的单位是字节，还可以使用 k、m 和 p（512 字节的块），也可以使用大写的 K、M、P，含义一样。</p>
<h4 id="文件排序"><a href="#文件排序" class="headerlink" title="文件排序"></a>文件排序</h4><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按文件名排序，同一目录下的文件和目录名会一起排，而不是先排目录再排文件</span></span><br><span class="line">% <span class="built_in">print</span> -l **/*(.on)</span><br><span class="line">bb.txt</span><br><span class="line">cc/aa.txt</span><br><span class="line">cc/dd.txt</span><br><span class="line">zz.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按文件的目录深度逆序排，d 是从深往浅排，O 是逆序</span></span><br><span class="line">% <span class="built_in">print</span> -l **/*(.Od)</span><br><span class="line">zz.txt</span><br><span class="line">bb.txt</span><br><span class="line">cc/dd.txt</span><br><span class="line">cc/aa.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 先按文件名排序，然后再按大小排序，这样大小相同的文件依然是按文件名排的</span></span><br><span class="line">% <span class="built_in">print</span> -l **/*(.onoL)</span><br><span class="line">bb.txt</span><br><span class="line">cc/aa.txt</span><br><span class="line">cc/dd.txt</span><br><span class="line">cc.txt</span><br></pre></td></tr></table></figure>

<p>像第三个例子那样，可以排多次。</p>
<p>可供排序的因素：n（文件名，如果不指定排序选项，默认按文件名排，即 on）、L（大小）、l（硬连接数）、a（atime）、m（mtime）、c（ctime）、d（所在目录深度，从深到浅排）。</p>
<h4 id="组合使用"><a href="#组合使用" class="headerlink" title="组合使用"></a>组合使用</h4><p>现在我们大概了解了都有哪些可供使用的通配符修饰语，单个使用已经没有什么问题了。但如果同时使用多个，就涉及到怎么组合在一起的问题。</p>
<p>类型和类型之间要用逗号隔开，如果不指定类型，代表所有类型都可以，逗号前后的内容互不干扰（取反 ^ 操作只影响到逗号之前内容）。同一个类型可以同时加多个选项，依次添加即可。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当前目录下的两天内修改过的目录</span></span><br><span class="line"><span class="comment"># 加上小于 3 m 的普通文件从小到大排</span></span><br><span class="line"><span class="comment"># 再加上所有的符号链接文件（包括隐藏文件）</span></span><br><span class="line">% <span class="built_in">print</span> -l *(/m-2,.Lm-3oL,@D)</span><br></pre></td></tr></table></figure>

<h3 id="文件批量重命名"><a href="#文件批量重命名" class="headerlink" title="文件批量重命名"></a>文件批量重命名</h3><p>对文件进行批量重命名，是一个比较常见的场景。Zsh 中有一个非常方便的命令 zmv，它可以让批量重命名变得很简单。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用前需要先加载进来</span></span><br><span class="line">% <span class="built_in">autoload</span> -U zmv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有 txt 文件扩展名改成 conf</span></span><br><span class="line"><span class="comment"># 参数要用单引号扩起来，$1 代表第一个参数中括号中的内容</span></span><br><span class="line">%  zmv <span class="string">&#x27;(*).txt&#x27;</span> <span class="string">&#x27;$1.conf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果加了 -W 参数，zmv 会自动识别文件名中需要保留的部分</span></span><br><span class="line">%  zmv -W <span class="string">&#x27;*.txt&#x27;</span> <span class="string">&#x27;*.conf&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调整文件名各部分的前后顺序</span></span><br><span class="line">% zmv <span class="string">&#x27;(*).(*).txt&#x27;</span> <span class="string">&#x27;$2.$1.txt&#x27;</span></span><br><span class="line"><span class="comment"># 加 -n 预览而不实际运行</span></span><br><span class="line">% zmv -n <span class="string">&#x27;(*).(*).txt&#x27;</span> <span class="string">&#x27;$2.$1.txt&#x27;</span></span><br><span class="line">mv -- a.b.txt b.a.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 0 1 2 ... 前添加 0，以便和 10 11 12 ... 宽度一致</span></span><br><span class="line">% zmv <span class="string">&#x27;([0-9]).(*)&#x27;</span> <span class="string">&#x27;0$1.$2&#x27;</span></span><br><span class="line"><span class="comment"># 去掉开头的一个 0</span></span><br><span class="line">% zmv <span class="string">&#x27;(0)(*)&#x27;</span> <span class="string">&#x27;$2&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件整理到目录</span></span><br><span class="line">% zmv <span class="string">&#x27;(*) - (*) - (*).txt&#x27;</span> <span class="string">&#x27;$1/$2 - $3.txt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换大小写</span></span><br><span class="line">% zmv <span class="string">&#x27;(*).txt&#x27;</span> <span class="string">&#x27;$&#123;(U)1&#125;.txt&#x27;</span></span><br><span class="line">% zmv <span class="string">&#x27;(*).txt&#x27;</span> <span class="string">&#x27;$&#123;(L)1&#125;.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="不展开通配符"><a href="#不展开通配符" class="headerlink" title="不展开通配符"></a>不展开通配符</h3><p>有时我们不想展开通配符，比如我写了一个计算的函数叫做 calc：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">calc</span></span>() &#123;</span><br><span class="line">    <span class="built_in">zmodload</span> zsh/mathfunc</span><br><span class="line">    <span class="built_in">echo</span> $(($*))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">% calc 12+12</span><br><span class="line">24</span><br></pre></td></tr></table></figure>

<p>但如果我想计算 12 * 12：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% calc 12*12</span><br><span class="line">zsh: no matches found: 12*12</span><br></pre></td></tr></table></figure>

<p>如果不加引号的话，星号会被作为通配符使用，然后去找符合 12*12 的文件名，没找到所有报错了。但我并不想找文件。</p>
<p>noglob 命令可以禁止展开后边内容的通配符，这样就不需要加引号了。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">noglob</span> calc 12*12</span><br><span class="line">144</span><br></pre></td></tr></table></figure>

<p>然后可以写个 alias：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">alias</span> js=<span class="string">&quot;noglob calc&quot;</span></span><br><span class="line">% js 12*12</span><br><span class="line">144</span><br></pre></td></tr></table></figure>

<p>这样就可以更方便地使用计算器了。</p>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了文件查找中的通配符修饰语的用法，并且列出来大多数常用的通配符修饰语，还有一小部分更复杂或者更少用的暂时空缺，以后可能会补上。这些通配符修饰语没有必要全部记下来，熟悉常用的，其余的等用的时候再查询即可。</p>
<h3 id="参考-7"><a href="#参考-7" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.sina.com.cn/s/blog_687bd5d50101epna.html">http://blog.sina.com.cn/s/blog_687bd5d50101epna.html</a></p>
<h3 id="更新历史-2"><a href="#更新历史-2" class="headerlink" title="更新历史"></a>更新历史</h3><p>2017.08.31：增加“不展开通配符”和“文件批量重命名”。</p>
<h1 id="第十一篇-变量的进阶内容"><a href="#第十一篇-变量的进阶内容" class="headerlink" title="第十一篇 变量的进阶内容"></a>第十一篇 变量的进阶内容</h1><h3 id="导读-10"><a href="#导读-10" class="headerlink" title="导读"></a>导读</h3><p>之前我们已经依次讲过 zsh 下的五种变量（字符串、数组、哈希表、整数、浮点数）的基本用法。但变量的使用方面，还有一些比较进阶的内容，这对一些比较特别的场景很有帮助。</p>
<h3 id="typeset-命令"><a href="#typeset-命令" class="headerlink" title="typeset 命令"></a>typeset 命令</h3><p>typeset 命令用于对变量进行详细的设置。我们之前在哈希表那篇见过它。typeset -A 可以用来定义哈希表。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">typeset</span> -A table=(aa bb cc dd)</span><br></pre></td></tr></table></figure>

<p>但我们后续都使用 local，因为 local 的功能和 typeset 是一样的（除了不能用 -f 和 -g，这两个选项不常用），并且更短更容易输入。这里提到 typeset 命令，因为这个名称很好地反映了它的功能。但知道了这个后，我们可以继续使用 local 命令，毕竟它们是一样的。</p>
<p>typeset 命令有很多选项，可以作用在变量上，起到各种各样的效果。</p>
<h3 id="强制字符串内容为小写或者大写"><a href="#强制字符串内容为小写或者大写" class="headerlink" title="强制字符串内容为小写或者大写"></a>强制字符串内容为小写或者大写</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 强制字符串内容为小写</span></span><br><span class="line">% <span class="built_in">local</span> -l str=abcABC &amp;&amp; <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">abcabc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制字符串内容为大写</span></span><br><span class="line">% <span class="built_in">local</span> -u str=abcABC &amp;&amp; <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">ABCABC</span><br></pre></td></tr></table></figure>

<h3 id="设置变量为环境变量"><a href="#设置变量为环境变量" class="headerlink" title="设置变量为环境变量"></a>设置变量为环境变量</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -x str=abc</span><br><span class="line"><span class="comment"># 通常使用 export，功能一样</span></span><br><span class="line">% <span class="built_in">export</span> str=abc</span><br></pre></td></tr></table></figure>

<p>环境变量可以被子进程读取。</p>
<h3 id="设置变量为只读变量"><a href="#设置变量为只读变量" class="headerlink" title="设置变量为只读变量"></a>设置变量为只读变量</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -r str1=abc</span><br><span class="line"><span class="comment"># 通常使用 readonly，功能一样</span></span><br><span class="line">% <span class="built_in">readonly</span> str2=abc</span><br><span class="line"></span><br><span class="line">% str1=bcd</span><br><span class="line">zsh: read-only variable: str1</span><br><span class="line">% str2=bcd</span><br><span class="line">zsh: read-only variable: str2</span><br></pre></td></tr></table></figure>

<h3 id="设置数组不包含重复元素"><a href="#设置数组不包含重复元素" class="headerlink" title="设置数组不包含重复元素"></a>设置数组不包含重复元素</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -U array=(aa bb aa cc) &amp;&amp; <span class="built_in">echo</span> <span class="variable">$array</span></span><br><span class="line">aa bb cc</span><br></pre></td></tr></table></figure>

<h3 id="设置整数的位数"><a href="#设置整数的位数" class="headerlink" title="设置整数的位数"></a>设置整数的位数</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果位数不够，输出内容会用 0 补全</span></span><br><span class="line">% <span class="built_in">local</span> -Z 3 i=5 &amp;&amp; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">005</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果超出范围会被截断</span></span><br><span class="line">% <span class="built_in">local</span> -Z 3 i=1234 &amp;&amp; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">234</span><br></pre></td></tr></table></figure>

<h3 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h3><p>设置整数为其他进制显示：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -i 16 i=255</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">16<span class="comment">#FF</span></span><br></pre></td></tr></table></figure>

<p>可以设置 2 到 36 之间任意进制。设置几进制显示，并不影响计算，只是显示格式不同。</p>
<p>用 [#n] num 也可以显示十进制数为 n 进制：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> $(([#<span class="number">16</span>] <span class="number">255</span>))</span><br><span class="line">16<span class="comment">#FF</span></span><br></pre></td></tr></table></figure>

<p>可以用 n#num 来显示 n 进制整数为十进制：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> $((<span class="number">16#ff</span>))</span><br><span class="line">255</span><br></pre></td></tr></table></figure>

<p>我们可以定义一系列函数来快捷地转换进制，不需要使用 bc 等外部命令：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">0x</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $((<span class="number">16</span>#<span class="variable">$1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">0o</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $((<span class="number">8</span>#<span class="variable">$1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">0b</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $((<span class="number">2</span>#<span class="variable">$1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">p16</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $(([#<span class="number">16</span>] <span class="variable">$1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">p8</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $(([#<span class="number">8</span>] <span class="variable">$1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">p2</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $(([#<span class="number">2</span>] <span class="variable">$1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他进制转十进制</span></span><br><span class="line">% 0x ff</span><br><span class="line">255</span><br><span class="line">% 0b 1101</span><br><span class="line">13</span><br><span class="line"></span><br><span class="line"><span class="comment"># 十进制转其他进制</span></span><br><span class="line">% p16 1234</span><br><span class="line">16<span class="comment">#4D2</span></span><br></pre></td></tr></table></figure>

<h3 id="同时对多个变量赋相同的值"><a href="#同时对多个变量赋相同的值" class="headerlink" title="同时对多个变量赋相同的值"></a>同时对多个变量赋相同的值</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> &#123;i,j,k&#125;=123</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$i</span> <span class="variable">$j</span> <span class="variable">$k</span></span><br><span class="line">123 123 123</span><br></pre></td></tr></table></figure>

<h3 id="绑定字符串和数组"><a href="#绑定字符串和数组" class="headerlink" title="绑定字符串和数组"></a>绑定字符串和数组</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">local</span> -T DIR dir</span><br><span class="line">% dir=(/a /b/c /b/d /e/f)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$DIR</span></span><br><span class="line">/a:/b/c:/b/d:/e/f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 dir 后，DIR 也会被删除（反之亦然）</span></span><br><span class="line">% <span class="built_in">unset</span> dir</span><br><span class="line">% <span class="built_in">echo</span> $+DIR</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>Linux 下经常需要处理带分隔符冒号的字符串（比如 $PATH）。如果只修改其中某一个字段，比较麻烦。local -T 可以把字符串绑定到数组上，这样直接修改数组，字符串内容也会同步变化（反之亦然）。其实在 zsh 中，$PATH 字符串就是和 $path 数组绑定的，可以直接通过修改 $path 来达到修改 $PATH 的目的，这在某些场景会方便很多。</p>
<h3 id="显示变量的定义方式"><a href="#显示变量的定义方式" class="headerlink" title="显示变量的定义方式"></a>显示变量的定义方式</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% array=(aa bb cc)</span><br><span class="line">% <span class="built_in">local</span> -p array</span><br><span class="line"><span class="built_in">typeset</span> -a array=(aa bb cc)</span><br><span class="line"></span><br><span class="line">% array+=(dd)</span><br><span class="line">% <span class="built_in">local</span> -p array</span><br><span class="line"><span class="built_in">typeset</span> -a array=(aa bb cc dd)</span><br></pre></td></tr></table></figure>

<h3 id="什么地方该加双引号"><a href="#什么地方该加双引号" class="headerlink" title="什么地方该加双引号"></a>什么地方该加双引号</h3><p>用过 bash 的读者大概会对里边的双引号印象比较深刻，很多地方不加双引号都会出错，为了避免出错，很多人每个变量左右都加上双引号，麻烦不说，代码看起来也比较乱。</p>
<p>其实 zsh 中已经没有那些问题了，变量两边无需加双引号，不会出现莫名其妙的错误。但有些地方还是需要加双引号的。</p>
<p><strong>需要加双引号的场景：</strong></p>
<ol>
<li>像这样的包含字符或者特殊符号的字符串 <code>&quot;aa bb \t \n *&quot;</code> 出现在代码中时，两边要加双引号，这个基本不需要说明。</li>
<li>在用 <code>$()</code> 调用命令时，如果希望结果按一个字符串处理，需要加上双引号，<code>&quot;$()&quot;</code>，不然的话，如果命令结果中有空格，<code>$()</code> 会被展开成多个字符串。</li>
<li>如果想将数组当单个字符串处理，需要加双引号，<code>array=(a b); print -l &quot;$array&quot;</code>。</li>
<li>其他的原本不是单个字符串的东西，需要转成单个字符串的场景，要加双引号。</li>
</ol>
<p><strong>其余情况通常都不需要加双引号，典型的情况：</strong></p>
<ol>
<li>任何情况下，字符串变量的两边都不需要加双引号，无论里边的内容多么特殊，或者变量存不存在，都没有关系，如 <code>$str</code>。</li>
<li>如果不转换类型（比如数组转成字符串），任何变量的两边都不需要加双引号。</li>
<li><code>$1</code> <code>$2</code> <code>$*</code> 这些参数（其实它们也都是单个字符串），都不需要加双引号，无论内容是什么，或者参数是否存在。</li>
</ol>
<p>以上的 7 种情况几乎覆盖了所有场景，如果有没覆盖到的，试一下即可（让里边的内容包含空格、换行和其他特殊字符等等，看看结果是否符合预期）。</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了一些比较使用的 typeset（或者 local）命令的用法，typeset 命令还有很多其他参数，但一般很少用，以后我也会继续更新。</p>
<h3 id="参考-8"><a href="#参考-8" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a> </p>
<p><a target="_blank" rel="noopener" href="http://www.linux-mag.com/id/1079/">http://www.linux-mag.com/id/1079/</a></p>
<h3 id="更新历史-3"><a href="#更新历史-3" class="headerlink" title="更新历史"></a>更新历史</h3><p>20170831：新增“什么地方该加双引号”</p>
<h1 id="第十二篇-的用法"><a href="#第十二篇-的用法" class="headerlink" title="第十二篇 [[ ]] 的用法"></a>第十二篇 [[ ]] 的用法</h1><h3 id="导读-11"><a href="#导读-11" class="headerlink" title="导读"></a>导读</h3><p>[[ ]] 是我们比较熟悉的符号了，从第一篇开始我们就一直在用，但我一直没有详细介绍它的用法，只用到了它的一小部分功能。本文详细介绍 [[ ]] 的用法。</p>
<h3 id="比较字符串"><a href="#比较字符串" class="headerlink" title="比较字符串"></a>比较字符串</h3><p>[[ ]] 最常用的功能之一是比较字符串，这也是我们一直在用的功能。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配</span></span><br><span class="line">% [[ abc == abc ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># = 和 == 是一样的，最好统一使用一种</span></span><br><span class="line">% [[ abc = abc ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不匹配</span></span><br><span class="line">% [[ abc != abd ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式匹配</span></span><br><span class="line">% [[ abc =~ a.c ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前者字符序比后者小</span></span><br><span class="line">% [[ abc &lt; bcd ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 前者字符序比后者大</span></span><br><span class="line">% [[ cde &gt; bcd ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 没有 &gt;= 和 &lt;=</span></span><br><span class="line">% [[ cde &gt;= bcd ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">zsh: parse error near `bcd<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<p>除了在里边用等号、不等号之类比较外，还可以判断字符串是否为空：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% str=abc</span><br><span class="line"><span class="comment"># 判断字符串内容长度是否大于 0，等同于 (($#str))</span></span><br><span class="line">% [[ -n <span class="variable">$str</span> ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line">% str=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment"># 判断字符串是否为空，等同于 ((! $#str))</span></span><br><span class="line">% [[ -z <span class="variable">$str</span> ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<p>但这两种用法，我们都有更方便的其他实现方法，没有必要用它们。</p>
<h3 id="判断文件"><a href="#判断文件" class="headerlink" title="判断文件"></a>判断文件</h3><p>[[ ]] 另一类很重要的功能是判断文件，比如判断某一个文件是否存在、是否是目录、是否可读等等。</p>
<p>判断 /bin/zsh 文件是否存在：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% [[ -e /bin/zsh ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line">% [[ -e /bin/zshh ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-e 可以替换成如下的选项，用法是一致的：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>符合条件的文件</th>
</tr>
</thead>
<tbody><tr>
<td>-b</td>
<td>块设备文件</td>
</tr>
<tr>
<td>-c</td>
<td>字符设备文件</td>
</tr>
<tr>
<td>-d</td>
<td>目录</td>
</tr>
<tr>
<td>-e</td>
<td>存在的任何文件</td>
</tr>
<tr>
<td>-f</td>
<td>普通文件，含符号链接，不含目录、设备文件、socket、FIFO</td>
</tr>
<tr>
<td>-g</td>
<td>设置了 setgid 的文件</td>
</tr>
<tr>
<td>-h</td>
<td>符号链接</td>
</tr>
<tr>
<td>-k</td>
<td>设置了粘滞位（sticky bit）的文件</td>
</tr>
<tr>
<td>-p</td>
<td>FIFO 文件</td>
</tr>
<tr>
<td>-r</td>
<td>对当前进程可读的文件</td>
</tr>
<tr>
<td>-s</td>
<td>非空文件</td>
</tr>
<tr>
<td>-u</td>
<td>设置了 setuid 的文件</td>
</tr>
<tr>
<td>-x</td>
<td>对当前进程可执行的文件</td>
</tr>
<tr>
<td>-w</td>
<td>对当前进程可写的文件</td>
</tr>
<tr>
<td>-L</td>
<td>符号链接（同 -h）</td>
</tr>
<tr>
<td>-O</td>
<td>被当前进程的用户拥有的文件</td>
</tr>
<tr>
<td>-G</td>
<td>被当前进程的用户组拥有的文件</td>
</tr>
<tr>
<td>-S</td>
<td>socket 文件</td>
</tr>
<tr>
<td>-N</td>
<td>atime 和 mtime 一样的文件</td>
</tr>
</tbody></table>
<p>还有一个比较特殊的 -t 选项：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># $$ 是当前的进程 id</span></span><br><span class="line">% ls /proc/$$/fd</span><br><span class="line">0  1  10  11  2</span><br><span class="line">% [[ -t 10 ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line">% [[ -t 3 ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-t 后要接数字（如果不是，相当于 0），判断当前进程是否打开了对应的 fd（进程默认会打开 0、1、2 这三个 fd，分别对应标准输入、标准输出和错误输出，此外每打开一个文件、管道或者网络连接，都会对应一个 fd，关掉后对应 fd 会消失）。</p>
<h3 id="比较文件"><a href="#比较文件" class="headerlink" title="比较文件"></a>比较文件</h3><p>除了判断单个文件是否符合条件外，[[ ]] 还可以用来比较两个文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># file1 比 file2 新</span></span><br><span class="line">% [[ file1 -nt file2 ]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># file1 比 file2 旧</span></span><br><span class="line">% [[ file1 -ot file2 ]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># file1 和 file2 是否对应同一个文件（路径相同或者互为硬连接）</span></span><br><span class="line">% [[ file1 -ef file2 ]]</span><br></pre></td></tr></table></figure>

<h3 id="比较数值"><a href="#比较数值" class="headerlink" title="比较数值"></a>比较数值</h3><p>[[ ]] 也可以用来比较数值，注意不是用等号、大于号、小于号等等比较，有一系列专门的符号。通常我们没必要用 [[ ]] 来比较数值，用 (( )) 更方便一些。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -eq 是判断两个数值是否相等</span></span><br><span class="line">% [[ 12 -eq 12 ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<p>-eq 可以替换成下列符号，用法一样：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>相等</td>
</tr>
<tr>
<td>-ne</td>
<td>不相等</td>
</tr>
<tr>
<td>-lt</td>
<td>&lt;</td>
</tr>
<tr>
<td>-gt</td>
<td>&gt;</td>
</tr>
<tr>
<td>-le</td>
<td>&lt;=</td>
</tr>
<tr>
<td>-ge</td>
<td>&gt;=</td>
</tr>
</tbody></table>
<h3 id="组合使用-1"><a href="#组合使用-1" class="headerlink" title="组合使用"></a>组合使用</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &amp;&amp; 是逻辑与</span></span><br><span class="line">% [[ a == a &amp;&amp; b == b ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># || 是逻辑或</span></span><br><span class="line">%  [[ a == a || a == b ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># ! 是逻辑非</span></span><br><span class="line">% [[ ! a == b ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以一起用，! 优先级最高，其次 &amp;&amp;，再次 ||</span></span><br><span class="line">% [[ ! a == b &amp;&amp; b == a || b == b ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不确定优先级，可以加小括号</span></span><br><span class="line">% [[ ((! a == b) &amp;&amp; b == a) || b == b ]] &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<p>需要注意一下空格，[[ ]] 内侧和内容之间需要空格隔开，== 两边也需要空格。如果是在 zsh 中直接敲入，! 后边也要加一个空格，不然会被解析成历史命令。</p>
<h3 id="符号"><a href="#符号" class="headerlink" title="[ ] 符号"></a>[ ] 符号</h3><p>除了 [[ ]] 符号，[ ] 符号（它是古老的 test 命令化身）也可以用来判断字符串、文件、数值等等，但功能没有 [[ ]] 全，只支持上边列的一部分功能（不支持 ==、=~、&gt;、&lt;、(、) ，并且逻辑与或的语法不一样，不能调整优先级，用起来很不方便），通常没有必要使用 [ ]（如需使用，可以 man test 查看用法）。</p>
<h3 id="总结-8"><a href="#总结-8" class="headerlink" title="总结"></a>总结</h3><p>本文详细介绍了 [[ ]] 的用法，基本覆盖全面了。</p>
<h3 id="参考-9"><a href="#参考-9" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://www.bash2zsh.com/zsh_refcard/refcard.pdf">http://www.bash2zsh.com/zsh_refcard/refcard.pdf</a></p>
<h1 id="第十三篇-管道和重定向"><a href="#第十三篇-管道和重定向" class="headerlink" title="第十三篇 管道和重定向"></a>第十三篇 管道和重定向</h1><h3 id="导读-12"><a href="#导读-12" class="headerlink" title="导读"></a>导读</h3><p>到目前为止，我们已经大致了解了 zsh 的语法特性，可以写一些功能不复杂的脚本了。但 shell 脚本主要的应用场景并不是闭门造车写独立的程序，而是和外部环境交互。所以要写出实用的脚本，要了解 zsh 如何和外部环境交互。这里的外部环境包括其他进程、文件系统、网络等等。本篇主要讲管道和重定向，这是和其他进程、文件系统等交互的基础。</p>
<p>本文中的命令主要是为了演示管道的用法，在实际脚本中通常不需要使用这些命令，因为可以用 zsh 代码直接实现。另外本系列文章不详细讲任何外部命令的用法，因为相关文档或者书籍特别多。如果看不懂本文的某些内容，可以暂时跳过，基本不影响其余部分的理解。</p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是类 Unix 系统中的一个比较基础也特别重要的概念，它用于将一个程序的输出作为另一个程序的输入，进而两个程序的数据可以互通。如果只是使用管道，还是非常简单易懂的，并不需要了解管道的实现细节。</p>
<p>管道的基本用法：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% ls</span><br><span class="line">git  tmp</span><br><span class="line"><span class="comment"># wc -l 功能是计算输入内容的行数</span></span><br><span class="line">% ls | wc -l</span><br><span class="line">2</span><br></pre></td></tr></table></figure>
<p>| 即管道，在键盘上是主键盘区右侧 \ 对应的上档键字符。如果只输入 wc -l，wc 会等待用户输入，这时可以输入字符串，然后回车继续输入，直到按 ctrl + d 结束输入。然后 wc 会统计用户一共输入了多少行，然后输出行数。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 敲 wc -l 回车后，依次按 a 回车 b 回车 ctrl + d</span></span><br><span class="line">% wc -l</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>但如果前边有个管道符号，ls | wc -l，那么 wc 就不等待用户输入了，而是直接将 ls 的结果作为输入读取过来，然后统计行数，输出结果。</p>
<h3 id="关于管道的更多细节"><a href="#关于管道的更多细节" class="headerlink" title="关于管道的更多细节"></a>关于管道的更多细节</h3><p>我们再运行一个简单的例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">% cat | wc -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 cat 进程打开的 fd</span></span><br><span class="line">% ls -l /proc/$(pidof cat)/fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 2017-08-30 21:15 0 -&gt; /dev/pts/1</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 2017-08-30 21:15 1 -&gt; pipe:[2803]</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 2017-08-30 21:15 2 -&gt; /dev/pts/1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 wc 进程打开的 fd</span></span><br><span class="line">% ls -l /proc/$(pidof wc)/fd</span><br><span class="line">total 0</span><br><span class="line">lr-x------ 1 goreliu goreliu 0 2017-08-30 21:16 0 -&gt; pipe:[2803]</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 2017-08-30 21:16 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 2017-08-30 21:16 2 -&gt; /dev/pts/1</span><br></pre></td></tr></table></figure>

<p>cat 命令的效果是等待用户输入，等用户输入一行，它就把这行再输出来，直到用户按 ctrl - d。所以 cat | wc -l 也会等待用户输入。</p>
<p>我们看下 fd 的指向，/dev/ps1/1 是指向伪终端设备文件的，进程就是通过这个来读取用户的输入和输出自己的内容。0 是标准输入（即用户输入端），1 是标准输出（即正常情况的输出端），2 是错误输出（即异常情况的输出端）。但是 cat 的输出端指向了 一个管道，并且 wc 的 输入端指向了一个相同的管道，这代表两个进程的输入输出端是通过管道连接的。这种管道是匿名管道，即只在内核中存在，是没有对应的文件路径的。</p>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>重定向，指的便是 fd 的重定向，管道也是重定向的一种方法。但用得更多的是将进程的 fd 重定向到文件。</p>
<p>一个最简单的例子是输出内容到文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> abce &gt; test.txt</span><br><span class="line">% cat test.txt</span><br><span class="line">abce</span><br></pre></td></tr></table></figure>

<p>因为这个用法太常见了，大家可能习以为常了。我们依然来看下更多的细节。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% cat &gt; test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在另一个 zsh 中运行</span></span><br><span class="line">% ls -l /proc/$(pidof cat)/fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:43 0 -&gt; /dev/pts/1</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:43 1 -&gt; /tmp/test.txt</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:43 2 -&gt; /dev/pts/1</span><br></pre></td></tr></table></figure>

<p>可以看到标准输出已经指向 test.txt 文件了。</p>
<p>除了标准输出可以重定向，标准输入（fd 0），错误输出（fd 2）也都可以。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">% touch 0.txt 1.txt 2.txt</span><br><span class="line">% sleep 1000 &lt;0.txt &gt;1.txt 2&gt;2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在另一个 zsh 中运行</span></span><br><span class="line">% ls -l /proc/$(pidof sleep)/fd</span><br><span class="line">total 0</span><br><span class="line">lr-x------ 1 goreliu goreliu 0 Aug 30 21:46 0 -&gt; /tmp/0.txt</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:46 1 -&gt; /tmp/1.txt</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:46 2 -&gt; /tmp/2.txt</span><br></pre></td></tr></table></figure>

<p>&lt;0.txt 是重定向标准输入，2&gt;2.txt 是重定向错误输出，&gt;1.txt（即 1&gt;1.txt）是重定向到标准输出。然后我们看到 3 个文件已经各就各位，全部被重定向了。但因为 sleep 并不去读写任何东西，重定向它的输入输出没有什么意义。</p>
<h3 id="更多重定向的用法"><a href="#更多重定向的用法" class="headerlink" title="更多重定向的用法"></a>更多重定向的用法</h3><p>一个 fd 只能重定向到一个文件，一一对应。但在 zsh 中，我们可以把一个 fd 对应到多个文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% cat &gt;0.txt &gt;1.txt &gt;2.txt</span><br></pre></td></tr></table></figure>

<p>输入完成后，3 个文件的内容都更新了，这是怎么回事呢？</p>
<p>其实是 zsh 进程做了中介。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">% pstree -p | grep cat</span><br><span class="line">        `-tmux: server(1172)-+-zsh(1173)---cat(1307)---zsh(1308)</span><br><span class="line"></span><br><span class="line">% ls -l /proc/1307/fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:57 0 -&gt; /dev/pts/1</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:57 1 -&gt; pipe:[2975]</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:57 2 -&gt; /dev/pts/1</span><br><span class="line"></span><br><span class="line">% ls -l /proc/1308/fd</span><br><span class="line">total 0</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:58 12 -&gt; /tmp/0.txt</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:58 13 -&gt; /tmp/1.txt</span><br><span class="line">lr-x------ 1 goreliu goreliu 0 Aug 30 21:58 14 -&gt; pipe:[2975]</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:58 15 -&gt; /tmp/2.txt</span><br></pre></td></tr></table></figure>

<p>可以看到 cat 的标准输出是重定向到管道了，管道对面是 zsh 进程，然后 zsh 打开了那三个文件。实际将内容写入文件的是 zsh，而不是 cat。但不管是谁写入的，这个用法很方便。</p>
<p>标准输入、错误输出也可以重定向多个文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> good &gt;0.txt &gt;1.txt &gt;2.txt</span><br><span class="line"></span><br><span class="line">% cat &lt;0.txt &lt;1.txt &lt;2.txt</span><br><span class="line">good</span><br><span class="line">good</span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<p>给 cat 的标准输出重定向 3 个文件，它将 3 个文件的内容全部读取了出来。</p>
<p>除了能同时重定向 fd 到多个文件外，还可以同时重定向到管道和文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 敲完 a b c 后 ctrl -d 退出</span></span><br><span class="line">% cat &gt;0.txt &gt;1.txt | wc -l</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line">% cat 0.txt 1.txt</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure>

<p>可以看到输入的内容写入了文件，并且通过管道传给了 wc -l，不用说，这又是 zsh 在做背后工作，将数据分发给了文件和管道。所以在 zsh 中是不需要使用 tee 命令的。</p>
<h3 id="命名管道"><a href="#命名管道" class="headerlink" title="命名管道"></a>命名管道</h3><p>除了匿名管道，我们还可以使用命名管道，这样更容易控制。命名管道所使用的文件即 FIFO（First Input First Output，先入先出）文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mkfifo 用来创建 FIFO 文件</span></span><br><span class="line">% mkfifo fifo</span><br><span class="line">% ls -l</span><br><span class="line">prw-r--r-- 1 goreliu goreliu 0 2017-08-30 21:29 fifo|</span><br><span class="line"></span><br><span class="line"><span class="comment"># cat 写入 fifo</span></span><br><span class="line">% cat &gt; fifo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开另一个 zsh，运行 wc -l 读取 fifo</span></span><br><span class="line">% wc -l &lt; fifo</span><br></pre></td></tr></table></figure>

<p>然后在 cat 那边输入一些内容，按 ctrl - d 退出，wc 这边就会统计输入的行数。</p>
<p>在输入完成之前，我们也可以看一下 cat 和 wc 两个进程的 fd 指向哪里：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% ls -l /proc/$(pidof cat)/fd</span><br><span class="line">total 0</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:35 0 -&gt; /dev/pts/2</span><br><span class="line">l-wx------ 1 goreliu goreliu 0 Aug 30 21:35 1 -&gt; /tmp/fifo</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:35 2 -&gt; /dev/pts/2</span><br><span class="line"></span><br><span class="line">% ls -l /proc/$(pidof wc)/fd</span><br><span class="line">total 0</span><br><span class="line">lr-x------ 1 goreliu goreliu 0 Aug 30 21:34 0 -&gt; /tmp/fifo</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:34 1 -&gt; /dev/pts/1</span><br><span class="line">lrwx------ 1 goreliu goreliu 0 Aug 30 21:34 2 -&gt; /dev/pts/1</span><br></pre></td></tr></table></figure>

<p>可以看到之前的匿名管道已经变成了我们刚刚创建的 fifo 文件，其他的并无不同。</p>
<h3 id="exec-命令的用法"><a href="#exec-命令的用法" class="headerlink" title="exec 命令的用法"></a>exec 命令的用法</h3><p>说起重定向，就不得不提 exec 命令。exec 命令主要用于启动新进程替换当前进程以及对 fd 做一些操作。</p>
<p>用 exec 启动新进程：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">exec</span> cat</span><br></pre></td></tr></table></figure>

<p>看上去效果和直接运行 cat 差不多。但如果运行 ctrl + d 退出 cat，终端模拟器就关闭了，因为在运行 exec cat 的时候，zsh 进程将已经被 cat 取代了，回不去了。</p>
<p>但在脚本中很少直接这样使用 exec，更多情况是用它来操作 fd：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将当前 zsh 的错误输出重定向到 test.txt</span></span><br><span class="line">% <span class="built_in">exec</span> 2&gt;test.txt</span><br><span class="line"><span class="comment"># 随意敲入一个不存在的命令，错误提示不出现了</span></span><br><span class="line">% fdsafds</span><br><span class="line"><span class="comment"># 错误提示被重定向到 test.txt 里</span></span><br><span class="line">% cat test.txt</span><br><span class="line">zsh: <span class="built_in">command</span> not found: fdsafds</span><br></pre></td></tr></table></figure>

<p>更多用法：</p>
<table>
<thead>
<tr>
<th>用法</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>n&gt;filename</td>
<td>重定向 fd n 的输出到 filename 文件</td>
</tr>
<tr>
<td>n&lt;filename</td>
<td>重定向 fd n 的输入为 filename 文件</td>
</tr>
<tr>
<td>n&lt;&gt;filename</td>
<td>同时重定向 fd n 的输入输出为 filename 文件</td>
</tr>
<tr>
<td>n&gt;&amp;m</td>
<td>重定向 fd n 的输出到 fd m</td>
</tr>
<tr>
<td>n&lt;&amp;m</td>
<td>重定向 fd n 的输入为 fd m</td>
</tr>
<tr>
<td>n&gt;&amp;-</td>
<td>关闭 fd n 的输出</td>
</tr>
<tr>
<td>n&lt;&amp;-</td>
<td>关闭 fd n 的输入</td>
</tr>
</tbody></table>
<p>更多例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把错误输出关闭，这样错误内容就不再显示</span></span><br><span class="line">% <span class="built_in">exec</span> 2&gt;&amp;-</span><br><span class="line">% fsdafdsa</span><br><span class="line"></span><br><span class="line">% <span class="built_in">exec</span> 3&gt;test.txt</span><br><span class="line">% <span class="built_in">echo</span> good &gt;&amp;3</span><br><span class="line">% <span class="built_in">exec</span> 3&gt;&amp;-</span><br><span class="line"><span class="comment"># 关闭后无法再输出</span></span><br><span class="line">% <span class="built_in">echo</span> good &gt;&amp;3</span><br><span class="line">zsh: 3: bad file descriptor</span><br><span class="line"></span><br><span class="line">% <span class="built_in">exec</span> 3&gt;test.txt</span><br><span class="line"><span class="comment"># 将 fd 4 的输出重定向到 fd 3</span></span><br><span class="line">% <span class="built_in">exec</span> 4&gt;&amp;3</span><br><span class="line">% <span class="built_in">echo</span> abcd &gt;&amp;4</span><br><span class="line"><span class="comment"># 输出内容到 fd 4，test.txt 内容更新了</span></span><br><span class="line">% cat test.txt</span><br><span class="line">abcd</span><br></pre></td></tr></table></figure>

<p>通常情况我们用 exec 主要为了重定向输出和关闭输出，比较少操作输入。</p>
<h3 id="总结-9"><a href="#总结-9" class="headerlink" title="总结"></a>总结</h3><p>本文讲了管道和重定向的基本概念和各种用法。Zsh 中的重定向还是非常灵活好用的，之后的文章会详细讲在实际场景中怎样使用。</p>
<h3 id="参考-10"><a href="#参考-10" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="http://adelphos.blog.51cto.com/2363901/1601563">http://adelphos.blog.51cto.com/2363901/1601563</a></p>
<h3 id="更新历史-4"><a href="#更新历史-4" class="headerlink" title="更新历史"></a>更新历史</h3><p>20170901：增加“exec 命令的用法”。</p>
<h1 id="第十四篇-文件读写"><a href="#第十四篇-文件读写" class="headerlink" title="第十四篇 文件读写"></a>第十四篇 文件读写</h1><h3 id="导读-13"><a href="#导读-13" class="headerlink" title="导读"></a>导读</h3><p>之前我们也偶尔接触过读写文件的方法，本篇会系统讲读写文件的各种方法。</p>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><p>写文件要比读文件简单一些，最常用的用法是使用 &gt; 直接将命令的输出重定向到文件。如果文件存在，内容会被覆盖；如果文件不存在，会被创建。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> abc &gt; test.txt</span><br></pre></td></tr></table></figure>

<p>如果不想覆盖之前的文件内容，可以追加写入：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> abc &gt;&gt; test.txt</span><br></pre></td></tr></table></figure>

<p>这样如果文件存在，内容会被追加写入进去；如果文件不存在，也会被创建。</p>
<h4 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h4><p>有时我们只想先创建个文件，等以后需要的时候再写入。</p>
<p>touch 命令用于创建文件（普通文件）：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% touch test1.txt test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用 echo 输出重定向，效果和 touch 一样</span></span><br><span class="line"><span class="comment"># 加 -n 是因为不加的话 echo 会输出一个换行符</span></span><br><span class="line">% <span class="built_in">echo</span> -n &gt;&gt;test1.txt &gt;&gt;test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用输入重定向</span></span><br><span class="line">% &gt;&gt;test1.txt &gt;&gt;test2.txt &lt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># mkdir 用来创建目录，如果需要在新目录创建文件</span></span><br><span class="line">% mkdir dir1 dir2</span><br></pre></td></tr></table></figure>

<p>如果文件已经存在，touch 命令会更新它的时间（mtime、ctime、atime 一起更新，其余两种方法不会）到当前时间。另外下边的清空文件方法，也都可以用来创建文件。touch 命令的使用比较方便，但如果想尽量少依赖外部命令，可以使用后两种方法。</p>
<p>因为文件创建过程通常不存在性能瓶颈，不用过多考虑性能因素。如果需要创建大量文件，可以在自己的环境分别用这几种方法试验几次，看需要多少时间。</p>
<p>我在树莓派 3B 简单测试一下：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三个脚本，分别创建 1000 个文件</span></span><br><span class="line">% cat test1 test2 test3</span><br><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">touch test1&#123;1..1000&#125;.txt</span><br><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> -n &gt;&gt;test2&#123;1..1000&#125;.txt</span><br><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">&gt;&gt;test3&#123;1..1000&#125;.txt &lt;/dev/null</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行了几次，结果差不多</span></span><br><span class="line">% time ./test1; time ./test2; time ./test3</span><br><span class="line">./test1  0.02s user 0.03s system 86% cpu 0.058 total</span><br><span class="line">./test2  0.02s user 0.02s system 70% cpu 0.056 total</span><br><span class="line">./test3  0.03s user 0.01s system 72% cpu 0.055 total</span><br></pre></td></tr></table></figure>

<p>另外如果文件数量太多的话，方法二、三要按批次创建，因为一个进程能打开的 fd 总数是有上限的。</p>
<h4 id="清空文件"><a href="#清空文件" class="headerlink" title="清空文件"></a>清空文件</h4><p>有时我们需要清空一个现有的文件：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 echo 输出重定向</span></span><br><span class="line">% <span class="built_in">echo</span> -n &gt;test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用输入重定向</span></span><br><span class="line">% &gt;test.txt &lt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用 truncate 命令清空文件</span></span><br><span class="line">% truncate -s 0 test.txt</span><br></pre></td></tr></table></figure>

<p>通常使用第一种方法即可，比较简单易懂。非特殊场景尽量不要用像 truncate 这样不常见的命令。</p>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>删除文件的方法比较单一，用 rm 命令即可。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">% rm test1.txt test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># -f 参数代表即使文件不存在也不报错</span></span><br><span class="line">% rm -f test1.txt test2.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># -r 参数可以递归删除目录和文件</span></span><br><span class="line">% rm -r dir1 dir2 <span class="built_in">test</span>*.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># -v 参数代表 rm 会输出删除文件的过程</span></span><br><span class="line">% rm -v <span class="built_in">test</span>*.txt</span><br><span class="line">removed <span class="string">&#x27;test1.txt&#x27;</span></span><br><span class="line">removed <span class="string">&#x27;test2.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<p>删除文件必须借助 rm 命令。如果一定要不依赖外部命令的话，zsh/files 模块里也有一个 rm 命令，可以用 zmodload zsh/files 加载，然后 rm 就变成了内部命令，用法基本相同。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">zmodload</span> zsh/files</span><br><span class="line">% <span class="built_in">which</span> -a rm</span><br><span class="line">rm: shell built-in <span class="built_in">command</span></span><br><span class="line">/usr/bin/rm</span><br></pre></td></tr></table></figure>

<p>此外 zsh/files 中还有内置的 chgrp、chown、ln、mkdir、mv、rmdir、sync 命令。如果不想依赖外部命令，或者系统环境出问题了用不了外部命令，可以使用这些。这可以作为命令不存在或者因为命令本身问题执行异常的一个 fallback 方案，来提高脚本的健壮性。</p>
<h4 id="多行文本写入"><a href="#多行文本写入" class="headerlink" title="多行文本写入"></a>多行文本写入</h4><p>通常我们写文件时不会每一行都单独写入，这样效率太低。</p>
<p>可以先把字符串拼接起来，然后一次性写入，这样比多次写入效率更高：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% str=ab</span><br><span class="line">% str+=<span class="string">&quot;\ncd&quot;</span></span><br><span class="line">% str +=<span class="string">&quot;\n<span class="variable">$str</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span> &gt; test.txt</span><br></pre></td></tr></table></figure>

<p>可以直接把数组写入到文件，每行一个元素：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">% array=(aa bb cc)</span><br><span class="line"></span><br><span class="line">% <span class="built_in">print</span> -l <span class="variable">$array</span> &gt; test.txt</span><br></pre></td></tr></table></figure>

<p>如果是将一段内容比较固定的字符串写入到文件，可以这样：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在脚本中也是如此，第二行以后的行首 &gt; 代表换行，非输入内容</span></span><br><span class="line"><span class="comment"># &lt;&lt;EOF 代表遇到 EOF 时会终止输入内容</span></span><br><span class="line"><span class="comment"># 里边也可以使用变量</span></span><br><span class="line">% &gt; test.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">&gt; aa</span></span><br><span class="line"><span class="string">&gt; bb</span></span><br><span class="line"><span class="string">&gt; cc dd</span></span><br><span class="line"><span class="string">&gt; ee</span></span><br><span class="line"><span class="string">&gt; EOF</span></span><br><span class="line"></span><br><span class="line">% cat test.txt</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc dd</span><br><span class="line">ee</span><br></pre></td></tr></table></figure>

<h4 id="用-mapfile-读写文件"><a href="#用-mapfile-读写文件" class="headerlink" title="用 mapfile 读写文件"></a>用 mapfile 读写文件</h4><p>如果不喜欢使用重定向符号，还可以用哈希表来操作文件。Zsh 有一个 zsh/mapfile 模块，用起来很方便：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">zmodload</span> zsh/<span class="built_in">mapfile</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 这样就可以创建文件并写入内容，如果文件存在则会被覆盖</span></span><br><span class="line">% <span class="built_in">mapfile</span>[test.txt]=<span class="string">&quot;ab cd&quot;</span></span><br><span class="line">% cat test.txt</span><br><span class="line">ab <span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断文件是否存在</span></span><br><span class="line">% (($+<span class="built_in">mapfile</span>[test.txt])) &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line">good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取文件</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$mapfile</span>[test.txt]</span><br><span class="line">ab <span class="built_in">cd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除文件</span></span><br><span class="line">% <span class="built_in">unset</span> <span class="string">&quot;mapfile[test.txt]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历文件</span></span><br><span class="line">% <span class="keyword">for</span> i (<span class="variable">$&#123;(k)mapfile&#125;</span>) &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">test1.txt</span><br><span class="line">test2.txt</span><br></pre></td></tr></table></figure>

<h4 id="从文件中间位置写入"><a href="#从文件中间位置写入" class="headerlink" title="从文件中间位置写入"></a>从文件中间位置写入</h4><p>有时我们需要从一个文件的中间位置（比如从第 100 的字符或者第三行开始）继续写入，覆盖之后的内容。Zsh 并不直接提供这样的方法，但我们可以迂回实现，先用 truncate 命令把文件截断，然后追加写。如果文件后边的内容还需要保留，可以在截断之前先读取进来（见下文读文件部分的例子），最后再写回去。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> 1234567890 &gt; test.txt</span><br><span class="line"><span class="comment"># 只保留前 5 个字符</span></span><br><span class="line">% truncate -s 5 test.txt</span><br><span class="line">% cat test.txt</span><br><span class="line">12345 </span><br><span class="line">% <span class="built_in">echo</span> abcde &gt;&gt; test.txt</span><br><span class="line">% cat test.txt</span><br><span class="line">12345abcde</span><br></pre></td></tr></table></figure>

<h3 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h3><h4 id="读取整个文件"><a href="#读取整个文件" class="headerlink" title="读取整个文件"></a>读取整个文件</h4><p>读取整个文件比较容易：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% str=$(&lt;test.txt)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc dd</span><br><span class="line">ee</span><br></pre></td></tr></table></figure>

<h4 id="按行遍历文件"><a href="#按行遍历文件" class="headerlink" title="按行遍历文件"></a>按行遍历文件</h4><p>如果文件比较大，那读取整个文件会消耗很多资源，可以按行遍历文件内容：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% <span class="keyword">while</span> &#123;<span class="built_in">read</span> i&#125; &#123;</span><br><span class="line">&gt; <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">&gt; &#125; &lt;test.txt</span><br><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">cc dd</span><br><span class="line">ee</span><br></pre></td></tr></table></figure>

<p>read 命令是从标准输入读取一行内容，把标准输入重定向后，就变成了从文件读取。</p>
<h4 id="读取指定行"><a href="#读取指定行" class="headerlink" title="读取指定行"></a>读取指定行</h4><p>如果只需要读取指定的某行或者某些行，不需要用上边的方法加自己计数。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># (f)2 是读取第二行</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;&quot;$(&lt;test.txt)&quot;[(f)2]&#125;</span></span><br><span class="line">bb</span><br></pre></td></tr></table></figure>

<h4 id="读取文件到数组"><a href="#读取文件到数组" class="headerlink" title="读取文件到数组"></a>读取文件到数组</h4><p>读取文件内容到数组中，每行是数组的一个元素：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% array=(<span class="variable">$&#123;(f)&quot;$(&lt;test.txt)&quot;&#125;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="读取指定数量的字符"><a href="#读取指定数量的字符" class="headerlink" title="读取指定数量的字符"></a>读取指定数量的字符</h4><p>有时我们需要按字节数来读取文件内容，而不是按行读取。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% cat test.txt</span><br><span class="line">1234567890</span><br><span class="line"><span class="comment"># -k5 是只最多读取 5 个字节，-u 0 是从 fd 0 读取，不然会卡住</span></span><br><span class="line">% <span class="built_in">read</span> -k 5 -u 0 str &lt;test.txt</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<h4 id="向文件中间插入内容"><a href="#向文件中间插入内容" class="headerlink" title="向文件中间插入内容"></a>向文件中间插入内容</h4><p>有时我们会遇到比较麻烦的场景，在某个文件中间插入一些内容，而前后的内容保持不变。</p>
<p>Zsh 并没有直接提供这样的功能，但我们可以迂回实现。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">echo</span> -n 1234567890 &gt; test.txt</span><br><span class="line"><span class="comment"># 先全部读进来</span></span><br><span class="line">% str=$(&lt;test.txt)</span><br><span class="line"><span class="comment"># 截断文件</span></span><br><span class="line">% truncate -s 5 test.txt</span><br><span class="line"><span class="comment"># 插入内容</span></span><br><span class="line">% <span class="built_in">echo</span> -n abcde &gt;&gt; test.txt</span><br><span class="line"><span class="comment"># 将后半部分文件追加回去</span></span><br><span class="line">% <span class="built_in">echo</span> -n <span class="variable">$str</span>[6,-1] &gt;&gt; test.txt</span><br><span class="line">% cat test.txt</span><br><span class="line">12345abcde67890</span><br></pre></td></tr></table></figure>

<p>但如果比较比较大的话，就不能将整个文件全部读进来，可以先在循环里用 read -k num 一次读固定数量的字符，然后写入一个中间文件，然后再 truncate 原文件，插入内容。最后再 cat 中间文件 &gt;&gt; 原文件 追加原来的后半部分内容即可。</p>
<p>另外这种从文件中间写入或者读取内容的场景，都可以使用 dd 命令实现，可以自行搜索 dd 命令的用法。</p>
<h3 id="总结-10"><a href="#总结-10" class="headerlink" title="总结"></a>总结</h3><p>本文比较详细地介绍了各种读写文件的方法，基本可以覆盖常用的场景。</p>
<h1 id="第十五篇-进程与作业控制"><a href="#第十五篇-进程与作业控制" class="headerlink" title="第十五篇 进程与作业控制"></a>第十五篇 进程与作业控制</h1><h3 id="导读-14"><a href="#导读-14" class="headerlink" title="导读"></a>导读</h3><p>通常情况 zsh 脚本是在一个进程中（并且单线程）执行的，但有时我们需要并行执行一些代码，因为现在的 CPU 基本都是多核的，这样可以加快运行速度。这就涉及到进程与作业控制。这里不讲进程的概念。</p>
<h3 id="在子进程中执行代码"><a href="#在子进程中执行代码" class="headerlink" title="在子进程中执行代码"></a>在子进程中执行代码</h3><p>之前我们提到过，小括号中的代码是在子进程中执行的：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% (sleep 1000 &amp;&amp; <span class="built_in">echo</span> good)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再另一个 zsh 里查看进程</span></span><br><span class="line">% pstree | grep sleep</span><br><span class="line">     `-tmux: server-+-zsh---zsh---sleep</span><br></pre></td></tr></table></figure>

<p>里边有两个 zsh 进程。如果不加小括号的话：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% sleep 1000 &amp;&amp; <span class="built_in">echo</span> good</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再另一个 zsh 里查看进程</span></span><br><span class="line">% pstree | grep sleep</span><br><span class="line">     `-tmux: server-+-zsh---sleep</span><br></pre></td></tr></table></figure>

<p>就只有一个 zsh 进程。这说明使用小括号时，里边的代码是在子进程（一个新的 zsh 进程）执行的。但需要注意的时，如果括号里只有一个命令（比如 sleep 1000），那么并不会再开一个子进程来执行了。</p>
<p>那么在子进程里执行代码有什么意义呢？如果像上边那样放着前台运行，是没有什么意义。但我们可以把它放后台运行。</p>
<h3 id="在后台运行进程"><a href="#在后台运行进程" class="headerlink" title="在后台运行进程"></a>在后台运行进程</h3><p>首先我们先看下怎么把单个程序放后台运行。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">% sleep 1000 &amp;</span><br><span class="line">[1] 850</span><br></pre></td></tr></table></figure>

<p>在 sleep 1000 后边加一个 &amp;，就会把它放后台运行。然后会输出一行内容，[1] 是进程的作业（job）号，850 是进程号（PID）。我们可以继续运行别的命令，不需要等待 sleep 结束了。</p>
<p>jobs 命令可以查看当前在后台运行的所有作业：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">jobs</span></span><br><span class="line">[1]  + running    sleep 1000</span><br><span class="line"></span><br><span class="line"><span class="comment"># -l 会输出进程号</span></span><br><span class="line">% <span class="built_in">jobs</span> -l</span><br><span class="line">[1]  + 850 running    sleep 1000</span><br></pre></td></tr></table></figure>

<p>fg 命令可以把后台的作业切换回前台：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 然后会继续等待 sleep 运行</span></span><br><span class="line">% <span class="built_in">fg</span></span><br><span class="line">[1]  + running    sleep 1000</span><br></pre></td></tr></table></figure>

<p>如果进程已经运行起来了，我们想再把它放到后台，可以这样：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 回车后按 ctrl + z</span></span><br><span class="line">% sleep 1000</span><br><span class="line">^Z</span><br><span class="line">zsh: suspended  sleep 1000</span><br><span class="line"><span class="comment"># 这时可以运行 jobs 看一下，sleep 是处于挂起状态的</span></span><br><span class="line">% <span class="built_in">jobs</span></span><br><span class="line">[1]  + suspended  sleep 1000</span><br><span class="line"><span class="comment"># 可以用 bg 让 sleep 恢复运行</span></span><br><span class="line">% <span class="built_in">bg</span></span><br><span class="line">[1]  + continued  sleep 1000</span><br><span class="line"><span class="comment"># 这样 sleep 就运行在后台了</span></span><br><span class="line">% <span class="built_in">jobs</span></span><br><span class="line">[1]  + running    sleep 1000</span><br></pre></td></tr></table></figure>

<p>其实 jobs、fg、bg 这些命令并不常用，大概了解下用法即可。比如现在在用 vim 编辑文件，文件还没有保存，但我想退到终端运行个命令，然后再回到 vim。可以按 ctrl + z 让 vim 挂起，然后运行命令，最后再运行 fg 让 vim 恢复。但通常我们可以启动多个终端模拟器，或者开一个新终端模拟器标签，或者用 tmux，没必要在一个 shell 里这么折腾。</p>
<h3 id="在脚本中使用后台进程执行代码"><a href="#在脚本中使用后台进程执行代码" class="headerlink" title="在脚本中使用后台进程执行代码"></a>在脚本中使用后台进程执行代码</h3><p>那么回答之前的场景，要在后台进程里执行 sleep 1000 &amp;&amp; echo good：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% &#123;sleep 1000 &amp;&amp; <span class="built_in">echo</span> aa&#125; &amp;</span><br></pre></td></tr></table></figure>

<p>这样大括号里的代码都会在后台进程里执行，脚本里可以继续写别的。如果做完了后需要再等大括号里边的代码运行。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">&#123;sleep 5 &amp;&amp; <span class="built_in">echo</span> p1&#125; &amp;</span><br><span class="line"><span class="comment"># $! 是上一个运行的后台进程的进程号</span></span><br><span class="line">pid=$!</span><br><span class="line">&#123;sleep 10 &amp;&amp; <span class="built_in">echo</span> p2&#125; &amp;</span><br><span class="line"><span class="built_in">echo</span> aaa</span><br><span class="line"><span class="comment"># 要做的其他事情先做完</span></span><br><span class="line">sleep 2</span><br><span class="line"><span class="built_in">echo</span> bbb</span><br><span class="line"><span class="comment"># wait 加进程号用来等待进程结束，类似 fg，但脚本中不能用 fg</span></span><br><span class="line"><span class="built_in">wait</span> <span class="variable">$pid</span></span><br><span class="line"><span class="built_in">echo</span> ccc</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">% ./test.zsh</span><br><span class="line">aaa</span><br><span class="line">bbb</span><br><span class="line">p1</span><br><span class="line">ccc</span><br><span class="line"><span class="comment"># p2 是脚本运行完过几秒才输出的</span></span><br><span class="line">% p2</span><br></pre></td></tr></table></figure>

<p>这样我们就可以同时操作多个进程来为自己服务了。而进程之间的通信，可以用命名管道或者普通文件来做，也可以使用 socket 文件（Zsh 中有 zsh/net/socket 模块，使用它可以通过 socket 文件来通信。管道是单向的，而 socket 双向的，更灵活一些，后续我们会了解它的用法），或者使用网络通信（如果脚本分布在不同的机器，zsh 中有 zsh/net/tcp 模块，这样无需外部命令就可进行 tcp 通信，后续也会讲到它）。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>运行中的进程可以接受信号然后对信号做出响应。kill 命令用来给进程发送信号。</p>
<p>15（SIGTERM）是最常用的信号，也是 kill 不加参数的默认信号，用于终止一个进程。kill num 即可终止进程号是 num 的进程。但 15 信号可以被进程捕获，然后并不退出。如果要强行杀掉一个进程，可以用 9 信号（SIGKILL），它是进程无法捕获的，但这样的话进程正在做的事情会突然中断，可能会有严重的影响，所以通常情况不要使用 9 信号杀进程。</p>
<p>在脚本中捕获信号：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SIGINT 是 2 信号，ctrl + c 会触发</span></span><br><span class="line"><span class="function"><span class="title">TRAPINT</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 处理一些退出前的善后工作</span></span><br><span class="line">    sleep 333</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sleep 1000</span><br></pre></td></tr></table></figure>

<p>然后运行这个脚本，然后 ctrl + c，脚本没有退出，因为在执行 sleep 333，要再按一次才会退出。</p>
<p>在脚本中使用信号，通常是给其他进程发（主要是 15），而不是给自己发。在脚本中也很少需要捕获信号处理。信号相关的更多内容，以后可能会补充。</p>
<h3 id="总结-11"><a href="#总结-11" class="headerlink" title="总结"></a>总结</h3><p>本文大概讲了进程与作业控制相关内容，主要用于在脚本里使用多进程执行代码，而不是在终端里进行作业控制（因为很少需要这样做）。关于脚本中的多个进程如何配合的内容还需要继续完善。</p>
<h1 id="第十六篇-alias-和-eval-的用法"><a href="#第十六篇-alias-和-eval-的用法" class="headerlink" title="第十六篇 alias 和 eval 的用法"></a>第十六篇 alias 和 eval 的用法</h1><h3 id="导读-15"><a href="#导读-15" class="headerlink" title="导读"></a>导读</h3><p>alias（别名）在 shell 中是非常常用的，它主要用于给命令起别名，简化输入。但主要用于交互场景，在脚本中基本用不到。eval 是一个非常强大的命令，它的功能是将字符串解析成代码再执行，但也会额外增加很多复杂性，非必要场景尽量少用。alias 和 eval 看起来好像没什么关系，但功能上有相似之处，所以放在一起讲。</p>
<h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>最典型的例子是将 ls -l 简化成 ll：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l&#x27;</span></span><br><span class="line">% ll</span><br><span class="line">total 0</span><br><span class="line">drwx------ 0 goreliu goreliu 512 Aug 31 13:55 tmux-1000</span><br><span class="line">drwxr-xr-x 0 goreliu goreliu 512 Aug 31 13:37 yaourt-tmp-goreliu</span><br></pre></td></tr></table></figure>

<p>alias 的效果相当于直接将字符串替换过来，比较好理解。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接运行 alias，会列出所有的 alias</span></span><br><span class="line">% <span class="built_in">alias</span></span><br><span class="line">ll=<span class="string">&#x27;ls -l&#x27;</span></span><br><span class="line">lla=<span class="string">&#x27;ls -F --color --time-style=long-iso -lA&#x27;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这样的 alias 只有在行首出现时，才会被解析。但 zsh 中还有一种功能更强大的全局 alias，不在行首也能被解析：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">alias</span> -g G=<span class="string">&#x27;| grep&#x27;</span></span><br><span class="line"></span><br><span class="line">% ls G tmux</span><br><span class="line">tmux-1000</span><br></pre></td></tr></table></figure>

<p>但这样需要格外注意可能导致的副作用，比如我想创建一个名为 G 的文件：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">% touch G</span><br><span class="line">touch: missing file operand</span><br><span class="line">Try <span class="string">&#x27;touch --help&#x27;</span> <span class="keyword">for</span> more information.</span><br><span class="line">Usage: grep [OPTION]... PATTERN [FILE]...</span><br><span class="line">Try <span class="string">&#x27;grep --help&#x27;</span> <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure>

<p>结果 G 被替换了，只能在 G 两边加引号。</p>
<p>如果全局 alias 没用好，可能导致灾难性的后果，比如误删重要文件（像把某个全局 alias 传给 rm 后，恰好删除了 alias 字符串中的某些文件），所以需要执行权衡后再使用，并且用的时候要多加注意。</p>
<h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><p>eval 的功能是将字符串作为代码来执行。看上去好像很简单，但实际涉及很复杂的内容，主要是符号转义导致的语义问题。</p>
<p>在 bash 中，eval 的一个重要的使用场景是将变量的值当变量名，然后取它的变量值，类似于 c 语言中指向变量的指针：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% str1=str2</span><br><span class="line">% str2=abc</span><br><span class="line">% <span class="built_in">eval</span> <span class="built_in">echo</span> \$<span class="variable">$str1</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>注意这里有一个 \ 和两个 $，原因是第二个 $ 是和平时一样，正常取 str1 的值的，而第一个 $ 需要转义，因为它要在 eval 执行的过程中取 str2 的值，不能现在就展开。</p>
<p>这个用法很容易出问题，而且可读性很差。幸好 zsh 中无需这么用，有更好的办法：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">% str1=str2</span><br><span class="line">% str2=abc</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(P)str1&#125;</span></span><br><span class="line">abc</span><br></pre></td></tr></table></figure>

<p>(P) 专门用于这种场景，不需要再去转义 $。</p>
<p>此外 eval 有时也用来动态执行代码，比如一个脚本接受用户的输入，而这输入也是一段脚本代码，就可以用 eval 来运行它。但这种用法是极其危险的，因为脚本中可能有各种危险操作，而且 shell 的语法很灵活，很难通过静态扫描的方法判断是否有危险操作。不可靠的代码根本不应该去运行。即使一定要运行，也可以先写到文件里再运行，避免传过来的代码影响到自身的逻辑。</p>
<p>但也不是说 zsh 中就完全没有必要用 eval 了，在某些特别的场景（比如用于改造语法加语法糖）还是有用的。但如果要使用，就一定要注意它可能导致的副作用，利弊只能自己权衡了。eval 的具体用法，和 bash 中的基本没有区别，可以去网上搜索 bash eval 用法来了解，这里就不介绍了。</p>
<h3 id="总结-12"><a href="#总结-12" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 alias 的用法和 eval 的场景使用场景。alias 很简单，主要在 .zshrc 里使用。eval 很复杂，非必要场景尽量避免使用。</p>
<h1 id="第十七篇-使用-socket-文件和-TCP-实现进程间通信"><a href="#第十七篇-使用-socket-文件和-TCP-实现进程间通信" class="headerlink" title="第十七篇 使用 socket 文件和 TCP 实现进程间通信"></a>第十七篇 使用 socket 文件和 TCP 实现进程间通信</h1><h3 id="导读-16"><a href="#导读-16" class="headerlink" title="导读"></a>导读</h3><p>就像我之前提到的，zsh 脚本是可以直接使用 socket 文件（UNIX domain socket 所使用）或者 TCP 和其他进程通信的。如果进程都在本地，用 socket 文件效率更高些，并且不要占用端口，权限也更好控制。如果是在不同机器，可以使用 TCP。</p>
<h3 id="Socket-文件"><a href="#Socket-文件" class="headerlink" title="Socket 文件"></a>Socket 文件</h3><p>UNIX domain socket 是比管道更先进的进程通信方法，是全双工的方式，并且稳定性更好。但性能比管道差一些，不过一般性能瓶颈都不会出现在这里，不用考虑性能问题。而且在一个 socket 文件上可以建立多个连接，更容易管理。另外如果通信方式从 socket 文件改成 TCP，只需要修改很少的代码（建立和关闭连接的代码稍微改一下），而从管道改成 TCP 则要麻烦很多。</p>
<p>所以建议用 zsh 写进程交互脚本的话，直接使用 socket 文件，而不是命名管道（匿名管道就能满足需求的简单场景忽略不计）。</p>
<p>Socket 文件的用法：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听连接端</span></span><br><span class="line"><span class="comment"># 首先要加载 socket 模块</span></span><br><span class="line">% <span class="built_in">zmodload</span> zsh/net/socket</span><br><span class="line"></span><br><span class="line">% <span class="built_in">zsocket</span> -l test.sock</span><br><span class="line">% listenfd=<span class="variable">$REPLY</span></span><br><span class="line"><span class="comment"># 此处阻塞等待连接</span></span><br><span class="line">% <span class="built_in">zsocket</span> -a <span class="variable">$listenfd</span></span><br><span class="line"><span class="comment"># 连接建立完成</span></span><br><span class="line">% fd=<span class="variable">$REPLY</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$fd</span></span><br><span class="line">5</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 $fd 就可读可写</span></span><br><span class="line">% cat &lt;&amp;<span class="variable">$fd</span></span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发起连接端</span></span><br><span class="line"><span class="comment"># 首先要加载 socket 模块</span></span><br><span class="line">% <span class="built_in">zmodload</span> zsh/net/socket</span><br><span class="line"></span><br><span class="line">% <span class="built_in">zsocket</span> test.sock</span><br><span class="line"><span class="comment"># 连接建立完成</span></span><br><span class="line">% fd=<span class="variable">$REPLY</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$fd</span></span><br><span class="line">4</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 $fd 就可读可写</span></span><br><span class="line">% <span class="built_in">echo</span> good &gt;&amp;<span class="variable">$fd</span></span><br></pre></td></tr></table></figure>

<p>连接建立后，怎么用就随意了。实际使用时，要判断 fd 看连接是否正常建立了。通常使用 socket 文件要比在网络环境使用 TCP 稳定性高很多，一般不会连接中断或者出其他异常。另外可以在 zsocket 后加 -v 参数，查看详细的信息（比如使用的 fd 号）。</p>
<p>关闭连接：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发起连接端</span></span><br><span class="line"><span class="comment"># fd 是之前存放 fd 号的变量，不需要加 $</span></span><br><span class="line">% <span class="built_in">exec</span> &#123;fd&#125;&gt;&amp;-</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听连接端</span></span><br><span class="line">% <span class="built_in">exec</span> &#123;listenfd&#125;&gt;&amp;-</span><br><span class="line">% <span class="built_in">exec</span> &#123;fd&#125;&gt;&amp;-</span><br><span class="line"><span class="comment"># 删除 socket 文件即可，如果下次再使用会重新创建，该文件不能重复使用</span></span><br><span class="line">% rm test.sock</span><br></pre></td></tr></table></figure>

<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><p>使用 TCP 连接的方式和使用 socket 文件基本一样。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 监听连接端</span></span><br><span class="line"><span class="comment"># 首先要加载 tcp 模块</span></span><br><span class="line">% <span class="built_in">zmodload</span> zsh/net/tcp</span><br><span class="line"></span><br><span class="line">% <span class="built_in">ztcp</span> -l 1234</span><br><span class="line">% listenfd=<span class="variable">$REPLY</span></span><br><span class="line"><span class="comment"># 此处阻塞等待连接</span></span><br><span class="line">% <span class="built_in">ztcp</span> -a <span class="variable">$listenfd</span></span><br><span class="line"><span class="comment"># 连接建立完成</span></span><br><span class="line">% fd=<span class="variable">$REPLY</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$fd</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 $fd 就可读可写</span></span><br><span class="line">% cat &lt;&amp;<span class="variable">$fd</span></span><br><span class="line">good</span><br></pre></td></tr></table></figure>

<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发起连接端</span></span><br><span class="line"><span class="comment"># 首先要加载 tcp 模块</span></span><br><span class="line">% <span class="built_in">zmodload</span> zsh/net/tcp</span><br><span class="line"></span><br><span class="line">% <span class="built_in">ztcp</span> 127.0.0.1 1234</span><br><span class="line"><span class="comment"># 连接建立完成</span></span><br><span class="line">% fd=<span class="variable">$REPLY</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$fd</span></span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后 $fd 就可读可写</span></span><br><span class="line">% <span class="built_in">echo</span> good &gt;&amp;<span class="variable">$fd</span></span><br></pre></td></tr></table></figure>

<p>关闭连接：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发起连接端</span></span><br><span class="line"><span class="comment"># fd 是之前存放 fd 号的变量</span></span><br><span class="line">% <span class="built_in">ztcp</span> -c <span class="variable">$fd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听连接端</span></span><br><span class="line">% <span class="built_in">ztcp</span> -c <span class="variable">$listenfd</span></span><br><span class="line">% <span class="built_in">ztcp</span> -c <span class="variable">$fd</span></span><br></pre></td></tr></table></figure>

<h3 id="程序样例"><a href="#程序样例" class="headerlink" title="程序样例"></a>程序样例</h3><p>recv_tcp，监听指定端口，并输出发送过来的消息。使用方法：recv_tcp 端口</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">zmodload</span> zsh/net/tcp</span><br><span class="line"></span><br><span class="line">(($+1)) || &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$&#123;0:t&#125;</span> port&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">ztcp</span> -l <span class="variable">$1</span></span><br><span class="line">listenfd=<span class="variable">$REPLY</span></span><br><span class="line"></span><br><span class="line">[[ <span class="variable">$listenfd</span> == &lt;-&gt; ]] || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((1)) &#123;</span><br><span class="line">    <span class="built_in">ztcp</span> -a <span class="variable">$listenfd</span></span><br><span class="line">    fd=<span class="variable">$REPLY</span></span><br><span class="line">    [[ <span class="variable">$fd</span> == &lt;-&gt; ]] || <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">    cat &lt;&amp;<span class="variable">$fd</span></span><br><span class="line">    <span class="built_in">ztcp</span> -c <span class="variable">$fd</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>send_tcp，用来向指定机器的指定端口发一条消息。使用方法：send_tcp 机器名  端口 消息 （机器名可选，如果没有则发到本机，消息可以包含空格）</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">zmodload</span> zsh/net/tcp</span><br><span class="line"></span><br><span class="line">((<span class="variable">$#</span> &gt;= 2)) || &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$&#123;0:t&#125;</span> [hostname] port message&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$1</span> == &lt;0-65535&gt; ]] &#123;</span><br><span class="line">    <span class="built_in">ztcp</span> 127.0.0.1 <span class="variable">$1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">ztcp</span> <span class="variable">$1</span> <span class="variable">$2</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd=<span class="variable">$REPLY</span></span><br><span class="line">[[ <span class="string">&quot;<span class="variable">$fd</span>&quot;</span> == &lt;-&gt; ]] || <span class="built_in">exit</span> 1</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;*[2,-1]&#125;</span> &gt;&amp;<span class="variable">$fd</span></span><br><span class="line"><span class="built_in">ztcp</span> -c <span class="variable">$fd</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-13"><a href="#总结-13" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了使用 socket 文件或者 TCP 来实现两个脚本之间通信的方法。</p>
<h1 id="第十八篇-更多内置模块的用法"><a href="#第十八篇-更多内置模块的用法" class="headerlink" title="第十八篇 更多内置模块的用法"></a>第十八篇 更多内置模块的用法</h1><h3 id="导读-17"><a href="#导读-17" class="headerlink" title="导读"></a>导读</h3><p>除了 zsh/mathfunc、zsh/net/socket、zsh/net/tcp，zsh 还内置了一些其他的内置模块。本文简单讲几个比较常用的模块。</p>
<h3 id="模块的使用方法"><a href="#模块的使用方法" class="headerlink" title="模块的使用方法"></a>模块的使用方法</h3><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 zmodload 加模块名来加载模块</span></span><br><span class="line">% <span class="built_in">zmodload</span> zsh/mathfunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不加参数，可以查看现在已经加载了的模块</span></span><br><span class="line">% <span class="built_in">zmodload</span></span><br><span class="line">zsh/complete</span><br><span class="line">zsh/complist</span><br><span class="line">zsh/computil</span><br><span class="line">zsh/main</span><br><span class="line">zsh/mathfunc</span><br><span class="line">zsh/parameter</span><br><span class="line">zsh/<span class="built_in">stat</span></span><br><span class="line">zsh/<span class="built_in">zle</span></span><br><span class="line">zsh/zutil</span><br><span class="line"></span><br><span class="line"><span class="comment"># 加 -u 参数可以卸载模块</span></span><br><span class="line">% <span class="built_in">zmodload</span> -u zsh/mathfunc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有其他参数，可以补全查看帮助，不详细介绍了</span></span><br><span class="line">% <span class="built_in">zmodload</span> -&lt;tab&gt;</span><br><span class="line"> -- option --</span><br><span class="line">-A  -- create module aliases</span><br><span class="line">-F  -- handle features</span><br><span class="line">-I  -- define infix condition names</span><br><span class="line">-L  -- output <span class="keyword">in</span> the form of calls to <span class="built_in">zmodload</span></span><br><span class="line">-P  -- array param <span class="keyword">for</span> features</span><br><span class="line">-R  -- remove module aliases</span><br><span class="line">-a  -- <span class="built_in">autoload</span> module</span><br><span class="line">-b  -- <span class="built_in">autoload</span> module <span class="keyword">for</span> builtins</span><br><span class="line">-c  -- <span class="built_in">autoload</span> module <span class="keyword">for</span> condition codes</span><br><span class="line">-d  -- list or specify module dependencies</span><br><span class="line">-e  -- <span class="built_in">test</span> <span class="keyword">if</span> modules are loaded</span><br><span class="line">-f  -- <span class="built_in">autoload</span> module <span class="keyword">for</span> math <span class="built_in">functions</span></span><br><span class="line">-i  -- suppress error <span class="keyword">if</span> <span class="built_in">command</span> would <span class="keyword">do</span> nothing</span><br><span class="line">-l  -- list features</span><br><span class="line">-m  -- treat feature arguments as patterns</span><br><span class="line">-p  -- <span class="built_in">autoload</span> module <span class="keyword">for</span> parameters</span><br><span class="line">-u  -- unload module</span><br></pre></td></tr></table></figure>

<h3 id="日期时间相关模块"><a href="#日期时间相关模块" class="headerlink" title="日期时间相关模块"></a>日期时间相关模块</h3><p>我们知道使用 date 命令可以查看当前时间，也可以用来做日期时间的格式转换。但如果脚本里需要频繁地读取或者处理时间（比如打日志的时候，每一行加一个时间戳），那么调用 date 命令的资源消耗就太大了。Zsh 的 zsh/datetime 模块提供和 date 命令类似的功能。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">zmodload</span> zsh/datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出当前时间戳（从 1970 年年初到现在的秒数），和 date +%s 一样</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$EPOCHSECONDS</span></span><br><span class="line">1504231297</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出高精度的当前时间戳，浮点数</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$EPOCHREALTIME</span></span><br><span class="line">1504231373.9913284779</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出当前时间戳的秒和纳秒部分，是一个数组</span></span><br><span class="line"><span class="comment"># 可以用 epochtime[1] 和 epochtime[2] 分别读取</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$epochtime</span></span><br><span class="line">1504231468 503125900</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装指定格式输出当前时间，和 date +%... 效果一样</span></span><br><span class="line"><span class="comment"># 格式字符串可以 man date 或者 man strftime 查看</span></span><br><span class="line">% strftime <span class="string">&quot;%Y-%m-%d %H:%M:%S (%u)&quot;</span> <span class="variable">$EPOCHSECONDS</span></span><br><span class="line">2017-09-01 10:06:47 (5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果加了 -s str 参数，将指定格式的时间存入 str 变量而不输出</span></span><br><span class="line">% strftime -s str <span class="string">&quot;%Y-%m-%d %H:%M:%S (%u)&quot;</span> <span class="variable">$EPOCHSECONDS</span></span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$str</span></span><br><span class="line">2017-09-01 10:10:58 (5)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果加了 -r 参数，从指定的时间字符串反解出时间戳，之前操作的逆操作</span></span><br><span class="line"><span class="comment"># 也可以同时加 -s 参数来讲结果存入变量</span></span><br><span class="line">% strftime -r <span class="string">&quot;%Y-%m-%d %H:%M:%S (%u)&quot;</span> <span class="string">&quot;2017-09-01 10:10:58 (5)&quot;</span></span><br><span class="line">1504231858</span><br></pre></td></tr></table></figure>

<p>这基本覆盖了 date 的常用功能，而运行速度比 date 命令快很多。</p>
<h3 id="读写-gdbm-数据库"><a href="#读写-gdbm-数据库" class="headerlink" title="读写 gdbm 数据库"></a>读写 gdbm 数据库</h3><p>有时我们的脚本需要将某些数据持久化到本地文件，但像哈希表之类的数据，如果存放到普通文件里，载入和保存的资源消耗都比较大，而且如果脚本突然异常退出，数据会丢失。而且某些时候，我们可能需要操作一个巨大的哈希表，并不能全部将它载入到内存中。那么我们可以使用 gdbm 数据库文件。</p>
<p>Gdbm 是一个很轻量的 Key-Value 数据库，可以认为它就像一个保存在文件里的哈希表。Zsh 的 zsh/db/gdbm 模块可以很方便地读写 gdbm 数据库文件。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">zmodload</span> zsh/db/gdbm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明数据库文件对应的哈希表</span></span><br><span class="line">% <span class="built_in">local</span> -A sampledb</span><br><span class="line"><span class="comment"># 创建数据库文件，文件名是 sample.gdbm，对应 sampledb 哈希表</span></span><br><span class="line"><span class="comment"># 如果该文件已经存在，则会继续使用该文件</span></span><br><span class="line">% ztie -d db/gdbm -f sample.gdbm sampledb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后正常使用 sampledb 哈希表即可，数据会同步写入到数据库文件中</span></span><br><span class="line">% sampledb[k1]=v1</span><br><span class="line">% sampledb+=(k2 v2 k3 v3)</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$&#123;(kv)sampledb&#125;</span></span><br><span class="line">k1 v1 k2 v2 k3 v3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取数据库文件路径</span></span><br><span class="line">% zgdbmpath sampledb</span><br><span class="line">% <span class="built_in">echo</span> <span class="variable">$REPLY</span></span><br><span class="line">/home/goreliu/sample.gdbm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放数据库文件</span></span><br><span class="line">% zuntie -u sampledb</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以用只读的方式加载数据库文件</span></span><br><span class="line">% ztie -r -d db/gdbm -f sample.gdbm sampledb</span><br><span class="line"><span class="comment"># 但这样的话，需要用 zuntie -u 释放数据库文件</span></span><br><span class="line">% zuntie -u sampledb</span><br></pre></td></tr></table></figure>

<p>如果数据量比较大，或者有比较特别的需求，要先了解下 gdbm 是否符合自己的场景再使用。</p>
<h3 id="调度命令"><a href="#调度命令" class="headerlink" title="调度命令"></a>调度命令</h3><p>有时我们需要在未来的某个时刻运行某一个命令。虽然也可以 sleep 然后运行，但这样要多占两个进程，而且不好控制（比如要取消运行其中的某一个）。Zsh 的 zsh/sched 模块用于调度命令的运行。</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">% <span class="built_in">zmodload</span> zsh/<span class="built_in">sched</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5 秒后运行 ls 命令</span></span><br><span class="line">% <span class="built_in">sched</span> +5 ls</span><br><span class="line"><span class="comment"># 可以随便做些别的</span></span><br><span class="line">% date</span><br><span class="line">Fri Sep  1 10:36:16 DST 2017</span><br><span class="line"><span class="comment"># 五秒后，ls 命令被运行</span></span><br><span class="line">git  sample.gdbm  tmp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不加参数可以查看已有的待运行命令</span></span><br><span class="line">% <span class="built_in">sched</span></span><br><span class="line">  1 Fri Sep  1 21:16:05 date</span><br><span class="line">  2 Fri Sep  1 21:16:30 date</span><br><span class="line">  3 Fri Sep  1 21:17:12 date</span><br><span class="line"></span><br><span class="line"><span class="comment"># -n 可以去除第 n 个待运行命令</span></span><br><span class="line">% <span class="built_in">sched</span> -2</span><br><span class="line">% <span class="built_in">sched</span></span><br><span class="line">  1 Fri Sep  1 21:16:05 date</span><br><span class="line">  2 Fri Sep  1 21:17:12 date</span><br></pre></td></tr></table></figure>

<h3 id="底层的文件读写命令"><a href="#底层的文件读写命令" class="headerlink" title="底层的文件读写命令"></a>底层的文件读写命令</h3><p>有时我们可能需要更精细地操作文件，zsh 提供了一个 zsh/system 模块，里边包含一些底层的文件读写命令（对应 open、read、write 等系统调用）。使用这些函数，可以更精细地控制文件的读写，比如控制每次读写的数据量、从中间位置读写、上文件锁等等。这些命令的用法比较复杂，参数也比较多，这里就不列出了。如果需要使用，可以 man zshmodules 然后搜索 zsh/system 查看文档。</p>
<p>函数列表：sysopen、sysread、sysseek、syswrite、zsystem flock、systell、syserror</p>
<h3 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h3><p>其余的在脚本编写方面可能用的上的模块还有：</p>
<p>zsh/pcre（使用 pcre 正则表达式库，默认使用的是 POSIX regex 库）</p>
<p>zsh/stat（内部的 stat 命令，可用于取代 stat 命令）</p>
<p>zsh/zftp（内置的 ftp 客户端）</p>
<p>zsh/zprof（Zsh 脚本的性能追踪工具）</p>
<p>zsh/zpty（操作 pty 的命令）</p>
<p>zsh/zselect（select 系统调用的封装）</p>
<p>可以用 man zshmodules 查看。</p>
<h3 id="自己编写模块"><a href="#自己编写模块" class="headerlink" title="自己编写模块"></a>自己编写模块</h3><p>如果因为性能等因素，要自己写 zsh 模块来调用，也是比较方便的。Zsh 的源码中 Src/Modules 是模块目录，里边有一个实例模块 example（example.c 和 example.mdd 文件）。可以参考代码编写自己的模块，难度并不是很大。</p>
<h3 id="总结-14"><a href="#总结-14" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了几个比较常用的 zsh 内置模块，以后可能继续补充更多模块的用法。</p>
<h1 id="第十九篇-脚本实例讲解"><a href="#第十九篇-脚本实例讲解" class="headerlink" title="第十九篇 脚本实例讲解"></a>第十九篇 脚本实例讲解</h1><h3 id="导读-18"><a href="#导读-18" class="headerlink" title="导读"></a>导读</h3><p>本文将讲解一些比较简单的 zsh 脚本实例。</p>
<h3 id="实例一：复制一个目录的目录结构"><a href="#实例一：复制一个目录的目录结构" class="headerlink" title="实例一：复制一个目录的目录结构"></a>实例一：复制一个目录的目录结构</h3><p>功能：</p>
<p>将一个目录及它下边的所有目录复制到另一个目录中（即创建同名目录），但不复制目录下的其他类型文件。</p>
<p>例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">src 的目录结构：</span><br><span class="line"></span><br><span class="line">src</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">│   ├── 1.txt</span><br><span class="line">│   └── 2</span><br><span class="line">│       └── 3.txt</span><br><span class="line">├── c.txt</span><br><span class="line">├── d</span><br><span class="line">├── e f</span><br><span class="line">│   └── g</span><br><span class="line">│       └── 4.txt</span><br><span class="line">└── g h -&gt; e f</span><br><span class="line"></span><br><span class="line">要构造一个 dst 目录，只包含 src 下的目录，内容如下：</span><br><span class="line"></span><br><span class="line">dst</span><br><span class="line">└── src</span><br><span class="line">    ├── a</span><br><span class="line">    ├── b</span><br><span class="line">    │   └── 2</span><br><span class="line">    ├── d</span><br><span class="line">    └── e f</span><br><span class="line">        └── g</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>首先需要先将 src 目录下的目录名筛选出来，可以用 <code>**/*(/)</code> 匹配。</li>
<li>然后用 <code>mkdir -p</code> 在 dst 目录中创建对应的目录。</li>
</ol>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数 1：src 目录</span></span><br><span class="line"><span class="comment"># 参数 2：待创建的 dst 目录</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i (<span class="variable">$1</span>/**/*(/)) &#123;</span><br><span class="line">    <span class="comment"># -p 参数是递归创建目录，这样不用考虑目录的创建顺序</span></span><br><span class="line">    mkdir -p <span class="variable">$2</span>/<span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例二：寻找不配对的文件"><a href="#实例二：寻找不配对的文件" class="headerlink" title="实例二：寻找不配对的文件"></a>实例二：寻找不配对的文件</h3><p>功能：</p>
<p>需要当前目录下有一些 .txt 和 .txt.md5sum 的文件，需要寻找出没有对应的 .md5sum 文件的 .txt 文件。（实际的场景是寻找已经下载完成的文件，未下载完的文件都对应某个带后缀的文件。）</p>
<p>例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">当前目录的所有文件：</span><br><span class="line"></span><br><span class="line">aa.txt</span><br><span class="line">bb.txt</span><br><span class="line">bb.txt.md5sum</span><br><span class="line">cc dd.txt</span><br><span class="line">cc dd.txt.md5sum</span><br><span class="line">ee ff.txt.md5sum</span><br><span class="line">gg.txt</span><br><span class="line">hh ii.txt</span><br><span class="line"></span><br><span class="line">需要找出没有对应 .md5sum 的 .txt 文件：</span><br><span class="line">aa.txt</span><br><span class="line">gg.txt</span><br><span class="line">hh ii.txt</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>找到所有 .md5sum 文件，然后把文件名中的 .md5sum 去掉，即为那些需要排除的 .txt 文件（a）。</li>
<li>所有的文件，排除掉 .m5sum 文件，再排除掉 a，即结果。</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">all_files=(*)</span><br><span class="line">bad_files=(*.md5sum)</span><br><span class="line">bad_files+=(<span class="variable">$&#123;bad_files/.md5sum&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组差集操作</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;all_files:|bad_files&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="实例三：用-sed-批量重命名文件"><a href="#实例三：用-sed-批量重命名文件" class="headerlink" title="实例三：用 sed 批量重命名文件"></a>实例三：用 sed 批量重命名文件</h3><p>功能：</p>
<p>用形如 sed 命令的用法批量重命名文件。</p>
<p>例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实现 renamex 命令，接受的第一个参数为 sed 的主体参数，其余参数是文件列表</span></span><br><span class="line"><span class="comment"># 效果是根据 sed 对文件名的修改重命名这些文件</span></span><br><span class="line"></span><br><span class="line">% tree</span><br><span class="line">.</span><br><span class="line">├── aaa_aaa.txt</span><br><span class="line">├── aaa.txt</span><br><span class="line">├── ccc.txt</span><br><span class="line">└── xxx</span><br><span class="line">    ├── aaa bbb.txt</span><br><span class="line">    └── bbb ccc.txt</span><br><span class="line"></span><br><span class="line">% renamex s/aaa/bbb/g **/*</span><br><span class="line"><span class="string">&#x27;aaa_aaa.txt&#x27;</span> -&gt; <span class="string">&#x27;bbb_bbb.txt&#x27;</span></span><br><span class="line"><span class="string">&#x27;aaa.txt&#x27;</span> -&gt; <span class="string">&#x27;bbb.txt&#x27;</span></span><br><span class="line"><span class="string">&#x27;xxx/aaa bbb.txt&#x27;</span> -&gt; <span class="string">&#x27;xxx/bbb bbb.txt&#x27;</span></span><br><span class="line"></span><br><span class="line">% tree</span><br><span class="line">.</span><br><span class="line">├── bbb_bbb.txt</span><br><span class="line">├── bbb.txt</span><br><span class="line">├── ccc.txt</span><br><span class="line">└── xxx</span><br><span class="line">    ├── bbb bbb.txt</span><br><span class="line">    └── bbb ccc.txt</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>要找出所有的文件名，然后用 sed 替换成新文件名。</li>
<li>如果文件名有变化，用 mv 命令移动</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line">(($+2)) || &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&#x27;Usage: renamex s/aaa/bbb/g *.txt&#x27;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name ($*[2,-1]) &#123;</span><br><span class="line">    <span class="built_in">local</span> new_name=<span class="string">&quot;<span class="subst">$(echo $name | sed $1)</span>&quot;</span></span><br><span class="line">    [[ <span class="variable">$name</span> == <span class="variable">$new_name</span> ]] &amp;&amp; <span class="built_in">continue</span></span><br><span class="line">    mv -v <span class="variable">$name</span> <span class="variable">$new_name</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例四：根据文件的-md5-删除重复文件"><a href="#实例四：根据文件的-md5-删除重复文件" class="headerlink" title="实例四：根据文件的 md5 删除重复文件"></a>实例四：根据文件的 md5 删除重复文件</h3><p>功能：</p>
<p>删除当前目录以及子目录下所有的重复文件（根据 md5 判断，不是很严谨）。</p>
<p>思路：</p>
<ol>
<li>用 md5sum 命令计算所有文件的 md5。</li>
<li>使用哈希表判断 md5 是否重复，删除哈希表里已经有 md5 的后续文件。</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># D 是包含以 . 开头的隐藏文件</span></span><br><span class="line"><span class="built_in">local</span> files=(<span class="string">&quot;<span class="variable">$&#123;(f)$(md5sum **/*(.D))&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">local</span> files_to_delete=()</span><br><span class="line"><span class="built_in">local</span> -A md5s</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i (<span class="variable">$files</span>) &#123;</span><br><span class="line">    <span class="comment"># 取前 32 位，即 md5 的长度</span></span><br><span class="line">    <span class="built_in">local</span> md5=<span class="variable">$i</span>[1,32]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (($+md5s[<span class="variable">$md5</span>])) &#123;</span><br><span class="line">        <span class="comment"># 取 35 位之后的内容，即文件路径，md5 后边有两个空格</span></span><br><span class="line">        files_to_delete+=(<span class="variable">$i</span>[35,-1])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        md5s[<span class="variable">$md5</span>]=1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((<span class="variable">$#files_to_delete</span>)) &amp;&amp; rm -v <span class="variable">$files_to_delete</span></span><br></pre></td></tr></table></figure>

<h3 id="实例五：转换-100-以内的汉字数字为阿拉伯数字"><a href="#实例五：转换-100-以内的汉字数字为阿拉伯数字" class="headerlink" title="实例五：转换 100 以内的汉字数字为阿拉伯数字"></a>实例五：转换 100 以内的汉字数字为阿拉伯数字</h3><p>功能：</p>
<p>转换 100 以内的汉字数字为阿拉伯数字，如六十八转换成 68。</p>
<p>思路：</p>
<ol>
<li>建一个哈希表存放汉字与数字的对应关系。</li>
<li>比较麻烦的是“十”，在不同的位置，转换成的数字不同，需要分别处理。</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> -A table=(</span><br><span class="line">零 0</span><br><span class="line">一 1</span><br><span class="line">二 2</span><br><span class="line">三 3</span><br><span class="line">四 4</span><br><span class="line">五 5</span><br><span class="line">六 6</span><br><span class="line">七 7</span><br><span class="line">八 8</span><br><span class="line">九 9</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$1</span> == 十 ]] &#123;</span><br><span class="line">    result=一零</span><br><span class="line">&#125; <span class="keyword">elif</span> [[ <span class="variable">$1</span> == 十* ]] &#123;</span><br><span class="line">    result=<span class="variable">$&#123;1/十/一&#125;</span></span><br><span class="line">&#125; <span class="keyword">elif</span> [[ <span class="variable">$1</span> == *十 ]] &#123;</span><br><span class="line">    result=<span class="variable">$&#123;1/十/零&#125;</span></span><br><span class="line">&#125; <span class="keyword">elif</span> [[ <span class="variable">$1</span> == *十* ]] &#123;</span><br><span class="line">    result=<span class="variable">$&#123;1/十&#125;</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result=<span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i (&#123;1..<span class="variable">$#result</span>&#125;) &#123;</span><br><span class="line">    result[i]=<span class="variable">$table</span>[<span class="variable">$result</span>[i]]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ -z <span class="variable">$result</span>[i] ]] &#123;</span><br><span class="line">        <span class="built_in">echo</span> error</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line"></span><br><span class="line">运行结果：</span><br><span class="line"></span><br><span class="line">% ./convert 一</span><br><span class="line">1</span><br><span class="line">% ./convert 十</span><br><span class="line">10</span><br><span class="line">% ./convert 十五</span><br><span class="line">15</span><br><span class="line">% ./convert 二十</span><br><span class="line">20</span><br><span class="line">% ./convert 五十六</span><br><span class="line">56</span><br><span class="line">% ./convert 一百</span><br><span class="line">error</span><br></pre></td></tr></table></figure>

<h3 id="实例六：为带中文汉字数字的文件名重命名成以对应数字开头"><a href="#实例六：为带中文汉字数字的文件名重命名成以对应数字开头" class="headerlink" title="实例六：为带中文汉字数字的文件名重命名成以对应数字开头"></a>实例六：为带中文汉字数字的文件名重命名成以对应数字开头</h3><p>功能：</p>
<p>见下边例子。</p>
<p>例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">当前目录有如下文件：</span><br><span class="line"></span><br><span class="line">Zsh-开发指南（第一篇-变量和语句）.md</span><br><span class="line">Zsh-开发指南（第七篇-数值计算）.md</span><br><span class="line">Zsh-开发指南（第三篇-字符串处理之转义字符和格式化输出）.md</span><br><span class="line">Zsh-开发指南（第九篇-函数和脚本）.md</span><br><span class="line">Zsh-开发指南（第二篇-字符串处理之常用操作）.md</span><br><span class="line">Zsh-开发指南（第五篇-数组）.md</span><br><span class="line">Zsh-开发指南（第八篇-变量修饰语）.md</span><br><span class="line">Zsh-开发指南（第六篇-哈希表）.md</span><br><span class="line">Zsh-开发指南（第十一篇-变量的进阶内容）.md</span><br><span class="line">Zsh-开发指南（第十七篇-使用-socket-文件和-TCP-实现进程间通信）.md</span><br><span class="line">Zsh-开发指南（第十三篇-管道和重定向）.md</span><br><span class="line">Zsh-开发指南（第十九篇-脚本实例讲解）.md</span><br><span class="line">Zsh-开发指南（第十二篇-[[-]]-的用法）.md</span><br><span class="line">Zsh-开发指南（第十五篇-进程与作业控制）.md</span><br><span class="line">Zsh-开发指南（第十八篇-更多内置模块的用法）.md</span><br><span class="line">Zsh-开发指南（第十六篇-<span class="built_in">alias</span>-和-<span class="built_in">eval</span>-的用法）.md</span><br><span class="line">Zsh-开发指南（第十四篇-文件读写）.md</span><br><span class="line">Zsh-开发指南（第十篇-文件查找和批量处理）.md</span><br><span class="line">Zsh-开发指南（第四篇-字符串处理之通配符）.md</span><br><span class="line"></span><br><span class="line">需要重命名成这样：</span><br><span class="line"></span><br><span class="line">01_Zsh-开发指南（第一篇-变量和语句）.md</span><br><span class="line">02_Zsh-开发指南（第二篇-字符串处理之常用操作）.md</span><br><span class="line">03_Zsh-开发指南（第三篇-字符串处理之转义字符和格式化输出）.md</span><br><span class="line">04_Zsh-开发指南（第四篇-字符串处理之通配符）.md</span><br><span class="line">05_Zsh-开发指南（第五篇-数组）.md</span><br><span class="line">06_Zsh-开发指南（第六篇-哈希表）.md</span><br><span class="line">07_Zsh-开发指南（第七篇-数值计算）.md</span><br><span class="line">08_Zsh-开发指南（第八篇-变量修饰语）.md</span><br><span class="line">09_Zsh-开发指南（第九篇-函数和脚本）.md</span><br><span class="line">10_Zsh-开发指南（第十篇-文件查找和批量处理）.md</span><br><span class="line">11_Zsh-开发指南（第十一篇-变量的进阶内容）.md</span><br><span class="line">12_Zsh-开发指南（第十二篇-[[-]]-的用法）.md</span><br><span class="line">13_Zsh-开发指南（第十三篇-管道和重定向）.md</span><br><span class="line">14_Zsh-开发指南（第十四篇-文件读写）.md</span><br><span class="line">15_Zsh-开发指南（第十五篇-进程与作业控制）.md</span><br><span class="line">16_Zsh-开发指南（第十六篇-<span class="built_in">alias</span>-和-<span class="built_in">eval</span>-的用法）.md</span><br><span class="line">17_Zsh-开发指南（第十七篇-使用-socket-文件和-TCP-实现进程间通信）.md</span><br><span class="line">18_Zsh-开发指南（第十八篇-更多内置模块的用法）.md</span><br><span class="line">19_Zsh-开发指南（第十九篇-脚本实例讲解）.md</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>首先需要写将汉字数字转成阿拉伯数字的函数。</li>
<li>然后需要从文件名中截取汉字数字，然后转成阿拉伯数字。</li>
<li>拼接文件名，然后移动文件。</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换数字的逻辑和上一个实例一样</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> -A table=(</span><br><span class="line">零 0</span><br><span class="line">一 1</span><br><span class="line">二 2</span><br><span class="line">三 3</span><br><span class="line">四 4</span><br><span class="line">五 5</span><br><span class="line">六 6</span><br><span class="line">七 7</span><br><span class="line">八 8</span><br><span class="line">九 9</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">convert</span></span>() &#123;</span><br><span class="line">    <span class="built_in">local</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$1</span> == 十 ]] &#123;</span><br><span class="line">        result=一零</span><br><span class="line">    &#125; <span class="keyword">elif</span> [[ <span class="variable">$1</span> == 十* ]] &#123;</span><br><span class="line">        result=<span class="variable">$&#123;1/十/一&#125;</span></span><br><span class="line">    &#125; <span class="keyword">elif</span> [[ <span class="variable">$1</span> == *十 ]] &#123;</span><br><span class="line">        result=<span class="variable">$&#123;1/十/零&#125;</span></span><br><span class="line">    &#125; <span class="keyword">elif</span> [[ <span class="variable">$1</span> == *十* ]] &#123;</span><br><span class="line">        result=<span class="variable">$&#123;1/十&#125;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result=<span class="variable">$1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i (&#123;1..<span class="variable">$#result</span>&#125;) &#123;</span><br><span class="line">        result[i]=<span class="variable">$table</span>[<span class="variable">$result</span>[i]]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [[ -z <span class="variable">$result</span>[i] ]] &#123;</span><br><span class="line">            <span class="built_in">echo</span> error</span><br><span class="line">            <span class="built_in">return</span> 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$result</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i (Zsh*.md) &#123;</span><br><span class="line">    <span class="comment"># -Z 2 是为了在前边补全一个 0</span></span><br><span class="line">    <span class="comment"># 把文件名“第”之前和“篇”之后的全部去除</span></span><br><span class="line">    <span class="built_in">local</span> -Z 2 num=$(convert <span class="variable">$&#123;<span class="variable">$&#123;i#*第&#125;</span>%篇*&#125;</span>)</span><br><span class="line">    mv -v <span class="variable">$i</span> <span class="variable">$&#123;num&#125;</span>_<span class="variable">$i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例七：统一压缩解压工具"><a href="#实例七：统一压缩解压工具" class="headerlink" title="实例七：统一压缩解压工具"></a>实例七：统一压缩解压工具</h3><p>功能：</p>
<p>Linux 下常用的压缩、归档格式众多，参数各异，写一个用法统一的压缩解压工具，用于创建、解压 <code>.zip</code> <code>.7z</code> <code>.tar</code> <code>.tgz</code> <code>.tbz2</code> <code>.txz</code> <code>.tar.gz</code> <code>.tar.bz2</code> <code>.tar.xz</code> <code>.cpio</code> <code>.ar</code> <code>.gz</code> <code>.bz2</code> <code>.xz</code> 等文件。（类似 <code>atool</code>，但 <code>atool</code> 很久没更新了，一些新的格式不支持，没法定制。而且是用 <code>perl</code> 写的，很难看懂。所以还是决定自己写一个，只覆盖 <code>atool</code> 的一部分常用功能。）</p>
<p>例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a 用于创建压缩文件</span></span><br><span class="line">% a a.tgz dir1 file1 file2</span><br><span class="line">dir1/</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># al 用于列出压缩文件中的文件列表</span></span><br><span class="line">% al a.tgz</span><br><span class="line">drwxr-xr-x goreliu/goreliu   0 2017-09-13 11:23 dir1/</span><br><span class="line">-rw-r--r-- goreliu/goreliu   3 2017-09-13 11:23 file1</span><br><span class="line">-rw-r--r-- goreliu/goreliu   3 2017-09-13 11:23 file2</span><br><span class="line"></span><br><span class="line"><span class="comment"># x 用于解压文件</span></span><br><span class="line">% x a.tgz</span><br><span class="line">dir1/</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line">a.tgz  -&gt;  a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果解压后的文件名或目录名中当前目录下已经存在，则解压到随机目录</span></span><br><span class="line">% x a.tgz</span><br><span class="line">dir1/</span><br><span class="line">file1</span><br><span class="line">file2</span><br><span class="line">a.tgz  -&gt;  /tmp/<span class="built_in">test</span>/x-c4I</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>压缩文件时，根据传入的文件名判断压缩文件的格式。</li>
<li>解压和查看压缩文件内容时，根据传入的文件名和 <code>file</code> 命令结果判断压缩文件的格式。</li>
<li>为了复用代码，多个命令整合到一个文件，然后 <code>ln -s</code> 成多个命令。</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_type_by_name</span></span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="variable">$1</span> &#123;</span><br><span class="line">        (*.zip|*.7z|*.jar)</span><br><span class="line">        <span class="built_in">echo</span> 7z</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.rar|*.iso)</span><br><span class="line">        <span class="built_in">echo</span> 7z_r</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.tar|*.tgz|*.txz|*.tbz2|*.tar.*)</span><br><span class="line">        <span class="built_in">echo</span> tar</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.cpio)</span><br><span class="line">        <span class="built_in">echo</span> cpio</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.cpio.*)</span><br><span class="line">        <span class="built_in">echo</span> cpio_r</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.gz)</span><br><span class="line">        <span class="built_in">echo</span> gz</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.xz)</span><br><span class="line">        <span class="built_in">echo</span> xz</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.bz2)</span><br><span class="line">        <span class="built_in">echo</span> bz2</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.lzma)</span><br><span class="line">        <span class="built_in">echo</span> lzma</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.lz4)</span><br><span class="line">        <span class="built_in">echo</span> lz4</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*.ar)</span><br><span class="line">        <span class="built_in">echo</span> ar</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*)</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_type_by_file</span></span>() &#123;</span><br><span class="line">    <span class="keyword">case</span> $(file -bz <span class="variable">$1</span>) &#123;</span><br><span class="line">        (Zip *|7-zip *)</span><br><span class="line">        <span class="built_in">echo</span> 7z</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (RAR *)</span><br><span class="line">        <span class="built_in">echo</span> 7z_r</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (POSIX tar *|tar archive)</span><br><span class="line">        <span class="built_in">echo</span> tar</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*cpio archive*)</span><br><span class="line">        <span class="built_in">echo</span> cpio</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*gzip *)</span><br><span class="line">        <span class="built_in">echo</span> gz</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*XZ *)</span><br><span class="line">        <span class="built_in">echo</span> xz</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*bzip2 *)</span><br><span class="line">        <span class="built_in">echo</span> bz2</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*LZMA *)</span><br><span class="line">        <span class="built_in">echo</span> lzma</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*LZ4 *)</span><br><span class="line">        <span class="built_in">echo</span> lz4</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (current ar archive)</span><br><span class="line">        <span class="built_in">echo</span> ar</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*)</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(($+commands[tar])) || <span class="built_in">alias</span> tar=bsdtar</span><br><span class="line">(($+commands[cpio])) || <span class="built_in">alias</span> cpio=bsdcpio</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$&#123;0:t&#125;</span> &#123;</span><br><span class="line">    (a)</span><br><span class="line"></span><br><span class="line">    ((<span class="variable">$#</span>* &gt;= 2)) || &#123;</span><br><span class="line">        <span class="built_in">echo</span> Usage: <span class="variable">$0</span> target files/<span class="built_in">dirs</span></span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> $(get_type_by_name <span class="variable">$1</span>) &#123;</span><br><span class="line">        (7z)</span><br><span class="line">        7z a <span class="variable">$1</span> $*[2,-1]</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (tar)</span><br><span class="line">        tar -cavf <span class="variable">$1</span> $*[2,-1]</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (cpio)</span><br><span class="line">        find $*[2,-1] -print0 | cpio -H newc -0ov &gt; <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (gz)</span><br><span class="line">        gzip -cv $*[2,-1] &gt; <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (xz)</span><br><span class="line">        xz -cv $*[2,-1] &gt; <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (bz2)</span><br><span class="line">        bzip2 -cv $*[2,-1] &gt; <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (lzma)</span><br><span class="line">        lzma -cv $*[2,-1] &gt; <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (lz4)</span><br><span class="line">        lz4 -cv <span class="variable">$2</span> &gt; <span class="variable">$1</span></span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (ar)</span><br><span class="line">        ar rv <span class="variable">$1</span> $*[2,-1]</span><br><span class="line">        ;;</span><br><span class="line"></span><br><span class="line">        (*)</span><br><span class="line">        <span class="built_in">echo</span> <span class="variable">$1</span>: error</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">        ;;</span><br><span class="line">    &#125;</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (al)</span><br><span class="line"></span><br><span class="line">    ((<span class="variable">$#</span>* &gt;= 1)) || &#123;</span><br><span class="line">        <span class="built_in">echo</span> Usage: <span class="variable">$0</span> files</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i ($*) &#123;</span><br><span class="line">        <span class="keyword">case</span> $(get_type_by_name <span class="variable">$i</span> || get_type_by_file <span class="variable">$i</span>) &#123;</span><br><span class="line">            (7z|7z_r)</span><br><span class="line">            7z l <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (tar)</span><br><span class="line">            tar -tavf <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (cpio|cpio_r)</span><br><span class="line">            cpio -itv &lt; <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (gz)</span><br><span class="line">            zcat <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (xz)</span><br><span class="line">            xzcat <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (bz2)</span><br><span class="line">            bzcat <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (lzma)</span><br><span class="line">            lzcat <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (lz4)</span><br><span class="line">            lz4cat <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (ar)</span><br><span class="line">            ar tv <span class="variable">$i</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (*)</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$i</span>: error</span><br><span class="line">            ;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (x)</span><br><span class="line"></span><br><span class="line">    ((<span class="variable">$#</span>* &gt;= 1)) || &#123;</span><br><span class="line">        <span class="built_in">echo</span> Usage: <span class="variable">$0</span> files</span><br><span class="line">        <span class="built_in">return</span> 1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i ($*) &#123;</span><br><span class="line">        <span class="built_in">local</span> outdir=<span class="variable">$&#123;i%.*&#125;</span></span><br><span class="line"></span><br><span class="line">        [[ <span class="variable">$outdir</span> == *.tar ]] &amp;&amp; &#123;</span><br><span class="line">            outdir=<span class="variable">$outdir</span>[1, -5]</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [[ -e <span class="variable">$outdir</span> ]] &#123;</span><br><span class="line">            outdir=<span class="string">&quot;<span class="subst">$(mktemp -d -p $PWD x-XXX)</span>&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mkdir <span class="variable">$outdir</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> $(get_type_by_name <span class="variable">$i</span> || get_type_by_file <span class="variable">$i</span>) &#123;</span><br><span class="line">            (7z|7z_r)</span><br><span class="line">            7z x <span class="variable">$i</span> -o<span class="variable">$outdir</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (tar)</span><br><span class="line">            tar -xavf <span class="variable">$i</span> -C <span class="variable">$outdir</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (cpio|cpio_r)</span><br><span class="line">            <span class="built_in">local</span> file_path=<span class="variable">$i</span></span><br><span class="line">            [[ <span class="variable">$i</span> != /* ]] &amp;&amp; file_path=<span class="variable">$PWD</span>/<span class="variable">$i</span></span><br><span class="line">            <span class="built_in">cd</span> <span class="variable">$outdir</span> &amp;&amp; cpio -iv &lt; <span class="variable">$file_path</span> &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (gz)</span><br><span class="line">            zcat <span class="variable">$i</span> &gt; <span class="variable">$outdir</span>/<span class="variable">$i</span>[1,-4]</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (xz)</span><br><span class="line">            xzcat <span class="variable">$i</span> &gt; <span class="variable">$outdir</span>/<span class="variable">$i</span>[1,-4]</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (bz2)</span><br><span class="line">            bzcat <span class="variable">$i</span> &gt; <span class="variable">$outdir</span>/<span class="variable">$i</span>[1,-5]</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (lzma)</span><br><span class="line">            lzcat <span class="variable">$i</span> &gt; <span class="variable">$outdir</span>/<span class="variable">$i</span>[1,-6]</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (lz4)</span><br><span class="line">            lz4cat <span class="variable">$i</span> &gt; <span class="variable">$outdir</span>/<span class="variable">$i</span>[1,-5]</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (ar)</span><br><span class="line">            <span class="built_in">local</span> file_path=<span class="variable">$i</span></span><br><span class="line">            [[ <span class="variable">$i</span> != /* ]] &amp;&amp; file_path=<span class="variable">$PWD</span>/<span class="variable">$i</span></span><br><span class="line">            <span class="built_in">cd</span> <span class="variable">$outdir</span> &amp;&amp; ar x <span class="variable">$file_path</span> &amp;&amp; <span class="built_in">cd</span> ..</span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (*)</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$i</span>: error</span><br><span class="line">            ;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">local</span> files=$(ls -A <span class="variable">$outdir</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> [[ -z <span class="variable">$files</span> ]] &#123;</span><br><span class="line">            rmdir <span class="variable">$outdir</span></span><br><span class="line">        &#125; <span class="keyword">elif</span> [[ -e <span class="variable">$outdir</span>/<span class="variable">$files</span> &amp;&amp; ! -e <span class="variable">$files</span> ]] &#123;</span><br><span class="line">            mv -v <span class="variable">$outdir</span>/<span class="variable">$files</span> . &amp;&amp; rmdir <span class="variable">$outdir</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$i</span> <span class="string">&quot; -&gt; &quot;</span> <span class="variable">$files</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="variable">$i</span> <span class="string">&quot; -&gt; &quot;</span> <span class="variable">$outdir</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (*)</span><br><span class="line">    <span class="built_in">echo</span> error</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">    ;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例八：方便并发运行命令的工具"><a href="#实例八：方便并发运行命令的工具" class="headerlink" title="实例八：方便并发运行命令的工具"></a>实例八：方便并发运行命令的工具</h3><p>功能：</p>
<p>我们经常会遇到在循环里批量处理文件的场景（比如将所有 jpg 图片转换成 png 图片），那么就会遇到一个麻烦：如果在前台处理文件，那同一时间只能处理一个，效率太低；如果在后台处理文件，那么瞬间就会启动很多个进程，占用大量资源，系统难以承受。我们希望的是在同一时间最多同时处理固定数量（比如 10 个）的文件，如果已经达到了这个数量，那么就先等一会，直到有退出的进程后再继续。<code>parallel</code> 命令中在一定程度上能满足这个需求，但用起来太麻烦。</p>
<p>例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># rr 是一个函数（可放在 .zshrc 中），直接 rr 加命令即可使用</span></span><br><span class="line"><span class="comment"># 命令中支持变量、重定向等等，格式上和直接输入命令没有区别（不支持 alias）</span></span><br><span class="line">% rr sleep 5</span><br><span class="line">[4] 5031</span><br><span class="line">% rr sleep 5</span><br><span class="line">[5] 5032</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果不加参数，则显示当前运行的进程数、最大进程并发数和运行中进程的进程号</span></span><br><span class="line"><span class="comment"># 默认最大进程并发数是 10</span></span><br><span class="line">% rr</span><br><span class="line">running/max: 2/10</span><br><span class="line">pid: 5031 5032</span><br><span class="line"><span class="comment"># 5 秒之后，运行结束</span></span><br><span class="line">% rr</span><br><span class="line">running/max: 0/10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用 -j 来指定最大进程并发数，指定一次即可，如需修改可再次指定</span></span><br><span class="line"><span class="comment"># 可以只调整最大进程并发数而不运行命令</span></span><br><span class="line">% rr -j2 sleep 10</span><br><span class="line">[4] 5035</span><br><span class="line">% rr sleep 10</span><br><span class="line">[5] 5036</span><br><span class="line"></span><br><span class="line"><span class="comment"># 超过了最大进程并发数，等待，并且每一秒检查一次是否有进程退出</span></span><br><span class="line"><span class="comment"># 如果有进程退出，则继续在后台运行当前命令</span></span><br><span class="line">% rr sleep 10</span><br><span class="line">running/max: 2/2, <span class="built_in">wait</span> 1s ...</span><br><span class="line">pid: 5035 5036</span><br><span class="line">running/max: 2/2, <span class="built_in">wait</span> 1s ...</span><br><span class="line">pid: 5035 5036</span><br><span class="line">[4]  - <span class="keyword">done</span>       $*</span><br><span class="line">[4] 5039</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 实际使用场景，批量将 jpg 图片转换成 png 图片，gm 是 graphicsmagick 中的命令</span></span><br><span class="line"><span class="comment"># 转换图片格式比较耗时，顺序执行的话需要很久</span></span><br><span class="line">% <span class="keyword">for</span> i (*.jpg) &#123; rr gm convert <span class="variable">$i</span> <span class="variable">$&#123;i/jpg/png&#125;</span> &#125;</span><br><span class="line">[4] 5055</span><br><span class="line">[5] 5056</span><br><span class="line">[6] 5057</span><br><span class="line">[7] 5058</span><br><span class="line">[8] 5059</span><br><span class="line">[9] 5060</span><br><span class="line">[10] 5061</span><br><span class="line">[11] 5062</span><br><span class="line">[12] 5063</span><br><span class="line">[13] 5064</span><br><span class="line">running/max: 10/10, <span class="built_in">wait</span> 1s ...</span><br><span class="line">pid: 5060 5061 5062 5063 5064 5055 5056 5057 5058 5059</span><br><span class="line">running/max: 10/10, <span class="built_in">wait</span> 1s ...</span><br><span class="line">pid: 5060 5061 5062 5063 5064 5055 5056 5057 5058 5059</span><br><span class="line">[11]    <span class="keyword">done</span>       $*</span><br><span class="line">[5]    <span class="keyword">done</span>       $*</span><br><span class="line">[5] 5067</span><br><span class="line">[12]    <span class="keyword">done</span>       $*</span><br><span class="line">[11] 5068</span><br><span class="line">[6]    <span class="keyword">done</span>       $*</span><br><span class="line">[6] 5069</span><br><span class="line">[12] 5070</span><br><span class="line">running/max: 10/10, <span class="built_in">wait</span> 1s ...</span><br><span class="line">pid: 5070 5060 5061 5064 5055 5067 5068 5069 5058 5059</span><br><span class="line">[13]  - <span class="keyword">done</span>       $*</span><br><span class="line">[4]    <span class="keyword">done</span>       $*</span><br><span class="line">[4] 5072</span><br><span class="line">[13] 5073</span><br><span class="line">running/max: 10/10, <span class="built_in">wait</span> 1s ...</span><br><span class="line">pid: 5070 5060 5072 5061 5073 5067 5068 5069 5058 5059</span><br><span class="line">[5]    <span class="keyword">done</span>       $*</span><br><span class="line">[6]    <span class="keyword">done</span>       $*</span><br><span class="line">[5] 5075</span><br><span class="line">[6] 5076</span><br><span class="line">running/max: 10/10, <span class="built_in">wait</span> 1s ...</span><br><span class="line">pid: 5070 5060 5072 5061 5073 5075 5076 5068 5058 5059</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>需要在全局变量里记录最大进程并发数和当前运行的进程（哈希表）。</li>
<li>每运行一个进程，将对应的进程号放入哈希表中。</li>
<li>如果当前运行进程数达到最大进程并发数，则循环检查哈希表里的进程是否退出。</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rr</span></span>() &#123;</span><br><span class="line">    (($+max_process)) || <span class="built_in">typeset</span> -g max_process=10</span><br><span class="line">    (($+running_process)) || <span class="built_in">typeset</span> -gA running_process=()</span><br><span class="line"></span><br><span class="line">    [[ <span class="variable">$1</span> == -j&lt;1-&gt; ]] &amp;&amp; &#123;</span><br><span class="line">        max_process=<span class="variable">$&#123;1[3,-1]&#125;</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ((<span class="variable">$#</span> == 0)) &amp;&amp; &#123;</span><br><span class="line">        <span class="keyword">for</span> i (<span class="variable">$&#123;(k)running_process&#125;</span>) &#123;</span><br><span class="line">            [[ -e /proc/<span class="variable">$i</span> ]] || <span class="built_in">unset</span> <span class="string">&quot;running_process[<span class="variable">$i</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;running/max: <span class="variable">$#running_process</span>/<span class="variable">$max_process</span>&quot;</span></span><br><span class="line">        ((<span class="variable">$#running_process</span> &gt; 0)) &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;pid: <span class="variable">$&#123;(k)running_process&#125;</span>&quot;</span></span><br><span class="line">        <span class="built_in">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((1)) &#123;</span><br><span class="line">        <span class="built_in">local</span> running_process_num=<span class="variable">$#running_process</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$running_process_num</span> &lt; max_process)) &#123;</span><br><span class="line">            $* &amp;</span><br><span class="line">            running_process[$!]=1</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i (<span class="variable">$&#123;(k)running_process&#125;</span>) &#123;</span><br><span class="line">            [[ -e /proc/<span class="variable">$i</span> ]] || <span class="built_in">unset</span> <span class="string">&quot;running_process[<span class="variable">$i</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((<span class="variable">$#running_process</span> == <span class="variable">$running_process_num</span>)) &amp;&amp; &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;running/max: <span class="variable">$running_process_num</span>/<span class="variable">$max_process</span>, wait 1s ...&quot;</span></span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;pid: <span class="variable">$&#123;(k)running_process&#125;</span>&quot;</span></span><br><span class="line">            sleep 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 inotifywait 的版本（无需循环 sleep 等待）：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">rr</span></span>() &#123;</span><br><span class="line">    (($+max_process)) || <span class="built_in">typeset</span> -gi max_process=10</span><br><span class="line">    (($+running_process)) || <span class="built_in">typeset</span> -gA running_process=()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="built_in">getopts</span> j:h arg&#125; &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$arg</span> &#123;</span><br><span class="line">            (j)</span><br><span class="line">            ((OPTARG &gt; 0)) &amp;&amp; max_process=<span class="variable">$OPTARG</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (h)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [-j max_process] [cmd] [args]&quot;</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">            ;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shift</span> $((OPTIND - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    ((<span class="variable">$#</span> == 0)) &amp;&amp; &#123;</span><br><span class="line">        <span class="keyword">for</span> i (<span class="variable">$&#123;(k)running_process&#125;</span>) &#123;</span><br><span class="line">            [[ -e <span class="variable">$i</span> ]] || <span class="built_in">unset</span> <span class="string">&quot;running_process[<span class="variable">$i</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;running/max: <span class="variable">$#running_process</span>/<span class="variable">$max_process</span>&quot;</span></span><br><span class="line">        ((<span class="variable">$#running_process</span> &gt; 0)) &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;pids:&quot;</span> <span class="variable">$&#123;<span class="variable">$&#123;(k)running_process/\/proc\/&#125;</span>/\/exe&#125;</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((1)) &#123;</span><br><span class="line">        <span class="built_in">local</span> running_process_num=<span class="variable">$#running_process</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$running_process_num</span> &lt; max_process)) &#123;</span><br><span class="line">            $* &amp;</span><br><span class="line">            running_process[/proc/$!/exe]=1</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i (<span class="variable">$&#123;(k)running_process&#125;</span>) &#123;</span><br><span class="line">            [[ -e <span class="variable">$i</span> ]] || <span class="built_in">unset</span> <span class="string">&quot;running_process[<span class="variable">$i</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((<span class="variable">$#running_process</span> == <span class="variable">$running_process_num</span>)) &amp;&amp; &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;wait <span class="variable">$running_process_num</span> pids:&quot;</span> <span class="variable">$&#123;<span class="variable">$&#123;(k)running_process/\/proc\/&#125;</span>/\/exe&#125;</span></span><br><span class="line">            inotifywait -q <span class="variable">$&#123;(k)running_process&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例九：批量转换图片格式"><a href="#实例九：批量转换图片格式" class="headerlink" title="实例九：批量转换图片格式"></a>实例九：批量转换图片格式</h3><p>功能：</p>
<p>将当前目录及子目录的所有常见图片格式转换成 jpg 格式（jpg 格式也要转换一遍，可以减少文件体积），然后删除原图片。需要用 5 个并发进程来处理。注意避免仅扩展名不同的文件互相覆盖的情况。</p>
<p>例子：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">% tree</span><br><span class="line">.</span><br><span class="line">├── mine</span><br><span class="line">│   ├── 信.txt</span><br><span class="line">│   ├── 第一封信.jpg</span><br><span class="line">│   └── 第二封信.JPG</span><br><span class="line">├── 搞笑</span><br><span class="line">│   ├── 卖萌.GIF</span><br><span class="line">│   ├── 猫吃鱼.gif</span><br><span class="line">│   └── 猫抢东西吃.gif</span><br><span class="line">└── 素材</span><br><span class="line">    ├── 104 按键模板.jpg</span><br><span class="line">    ├── 104 按键模板.psd</span><br><span class="line">    ├── ahk</span><br><span class="line">    │   ├── ahk_bg.jpg</span><br><span class="line">    │   ├── ahk_home_logo.jpg</span><br><span class="line">    │   ├── ahk_home_logo.txt</span><br><span class="line">    │   ├── ahk_home_qr.jpg</span><br><span class="line">    │   ├── ahk_home_qr_small.jpg</span><br><span class="line">    │   └── ahk_logo.png</span><br><span class="line">    ├── stp_fc_cw_png_pk</span><br><span class="line">    │   ├── HD.PNG</span><br><span class="line">    │   ├── newimage.png</span><br><span class="line">    │   ├── nshd.PNG</span><br><span class="line">    │   └── std.png</span><br><span class="line">    ├── 地球.jpg</span><br><span class="line">    ├── 星系.JPEG</span><br><span class="line">    ├── 木纹 背景.GIF</span><br><span class="line">    ├── 木纹 背景.jpeg</span><br><span class="line">    └── 木纹 背景.jpg</span><br><span class="line"></span><br><span class="line">5 directories, 23 files</span><br><span class="line"></span><br><span class="line">% alltojpg</span><br><span class="line">running/max: 0/5</span><br><span class="line">running: 5, <span class="built_in">wait</span> 1.0000000000s ...</span><br><span class="line">pid: 5953 5954 5955 5956 5957</span><br><span class="line">running: 5, <span class="built_in">wait</span> 1.0000000000s ...</span><br><span class="line">pid: 5965 5966 5967 5968 5959</span><br><span class="line"></span><br><span class="line">% tree</span><br><span class="line">.</span><br><span class="line">├── mine</span><br><span class="line">│   ├── 信.txt</span><br><span class="line">│   ├── 第一封信.jpg</span><br><span class="line">│   └── 第二封信.jpg</span><br><span class="line">├── 搞笑</span><br><span class="line">│   ├── 卖萌_g.jpg</span><br><span class="line">│   ├── 猫吃鱼_g.jpg</span><br><span class="line">│   └── 猫抢东西吃_g.jpg</span><br><span class="line">└── 素材</span><br><span class="line">    ├── 104 按键模板.jpg</span><br><span class="line">    ├── 104 按键模板.psd</span><br><span class="line">    ├── ahk</span><br><span class="line">    │   ├── ahk_bg.jpg</span><br><span class="line">    │   ├── ahk_home_logo.jpg</span><br><span class="line">    │   ├── ahk_home_logo.txt</span><br><span class="line">    │   ├── ahk_home_qr.jpg</span><br><span class="line">    │   ├── ahk_home_qr_small.jpg</span><br><span class="line">    │   └── ahk_logo_p.jpg</span><br><span class="line">    ├── stp_fc_cw_png_pk</span><br><span class="line">    │   ├── HD_p.jpg</span><br><span class="line">    │   ├── newimage_p.jpg</span><br><span class="line">    │   ├── nshd_p.jpg</span><br><span class="line">    │   └── std_p.jpg</span><br><span class="line">    ├── 地球.jpg</span><br><span class="line">    ├── 星系_e.jpg</span><br><span class="line">    ├── 木纹 背景_e.jpg</span><br><span class="line">    ├── 木纹 背景_g.jpg</span><br><span class="line">    └── 木纹 背景.jpg</span><br><span class="line"></span><br><span class="line">5 directories, 23 files</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<ol>
<li>并发运行命令的方法见上一个实例。</li>
<li>转换图片格式用 <code>gm convert</code> 命令（graphicsmagick 中）或者 <code>convert</code> 命令（imagemagick 中）。</li>
<li>常见的图片文件扩展名有 <code>jpg</code>  <code>jpeg</code>  <code>png</code>  <code>gif</code>，另外可能是大写的扩展名。</li>
<li>为了避免类似 <code>a.gif</code> 覆盖 <code>a.jpg</code> 的情况，为不同的文件格式添加不同后缀，这样可以无需检查是否有同名文件，加快速度。</li>
</ol>
<p>实现：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># rr 是上一个实例中的代码</span></span><br><span class="line"><span class="function"><span class="title">rr</span></span>() &#123;</span><br><span class="line">    (($+max_process)) || <span class="built_in">typeset</span> -gi max_process=10</span><br><span class="line">    (($+running_process)) || <span class="built_in">typeset</span> -gA running_process=()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> &#123;<span class="built_in">getopts</span> j:h arg&#125; &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="variable">$arg</span> &#123;</span><br><span class="line">            (j)</span><br><span class="line">            ((OPTARG &gt; 0)) &amp;&amp; max_process=<span class="variable">$OPTARG</span></span><br><span class="line">            ;;</span><br><span class="line"></span><br><span class="line">            (h)</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;Usage: <span class="variable">$0</span> [-j max_process] [cmd] [args]&quot;</span></span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">            ;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shift</span> $((OPTIND - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    ((<span class="variable">$#</span> == 0)) &amp;&amp; &#123;</span><br><span class="line">        <span class="keyword">for</span> i (<span class="variable">$&#123;(k)running_process&#125;</span>) &#123;</span><br><span class="line">            [[ -e <span class="variable">$i</span> ]] || <span class="built_in">unset</span> <span class="string">&quot;running_process[<span class="variable">$i</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">&quot;running/max: <span class="variable">$#running_process</span>/<span class="variable">$max_process</span>&quot;</span></span><br><span class="line">        ((<span class="variable">$#running_process</span> &gt; 0)) &amp;&amp; <span class="built_in">echo</span> <span class="string">&quot;pids:&quot;</span> <span class="variable">$&#123;<span class="variable">$&#123;(k)running_process/\/proc\/&#125;</span>/\/exe&#125;</span></span><br><span class="line">        <span class="built_in">return</span> 0</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((1)) &#123;</span><br><span class="line">        <span class="built_in">local</span> running_process_num=<span class="variable">$#running_process</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((<span class="variable">$running_process_num</span> &lt; max_process)) &#123;</span><br><span class="line">            $* &amp;</span><br><span class="line">            running_process[/proc/$!/exe]=1</span><br><span class="line">            <span class="built_in">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i (<span class="variable">$&#123;(k)running_process&#125;</span>) &#123;</span><br><span class="line">            [[ -e <span class="variable">$i</span> ]] || <span class="built_in">unset</span> <span class="string">&quot;running_process[<span class="variable">$i</span>]&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ((<span class="variable">$#running_process</span> == <span class="variable">$running_process_num</span>)) &amp;&amp; &#123;</span><br><span class="line">            <span class="built_in">echo</span> <span class="string">&quot;wait <span class="variable">$running_process_num</span> pids:&quot;</span> <span class="variable">$&#123;<span class="variable">$&#123;(k)running_process/\/proc\/&#125;</span>/\/exe&#125;</span></span><br><span class="line">            inotifywait -q <span class="variable">$&#123;(k)running_process&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># JPG 作为中间扩展名</span></span><br><span class="line">rename .JPG .jpg **/*.JPG</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置进程并发数为 5</span></span><br><span class="line">rr -j5</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i (**/*.(jpg|png|PNG|jpeg|JPEG|gif|GIF)) &#123;</span><br><span class="line">    rr gm convert <span class="variable">$i</span> <span class="variable">$i</span>.JPG</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等所有操作结束</span></span><br><span class="line"><span class="built_in">wait</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除原文件</span></span><br><span class="line">rm **/*.(jpg|png|PNG|jpeg|JPEG|gif|GIF)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 避免覆盖同名文件</span></span><br><span class="line">rename .jpg.JPG .jpg **/*.JPG</span><br><span class="line">rename .png.JPG _p.jpg **/*.JPG</span><br><span class="line">rename .PNG.JPG _p.jpg **/*.JPG</span><br><span class="line">rename .jpeg.JPG _e.jpg **/*.JPG</span><br><span class="line">rename .JPEG.JPG _e.jpg **/*.JPG</span><br><span class="line">rename .gif.JPG _g.jpg **/*.JPG</span><br><span class="line">rename .GIF.JPG _g.jpg **/*.JPG</span><br></pre></td></tr></table></figure>

<h3 id="总结-15"><a href="#总结-15" class="headerlink" title="总结"></a>总结</h3><p>本文讲解了几个比较实用的 zsh 脚本，后续可能会补充更多个。</p>
<h3 id="更新历史-5"><a href="#更新历史-5" class="headerlink" title="更新历史"></a>更新历史</h3><p>2017.09.13：新增“实例七”、“实例八”和“实例九”。</p>
<p>2017.10.09：“示例八”和“示例九”中，新增使用 inotifywait 的 rr 函数。</p>
<h1 id="第二十篇-代码风格"><a href="#第二十篇-代码风格" class="headerlink" title="第二十篇 代码风格"></a>第二十篇 代码风格</h1><h3 id="导读-19"><a href="#导读-19" class="headerlink" title="导读"></a>导读</h3><p>因为 shell 脚本语法比较灵活，写 shell 脚本的开发者熟悉的编程语言也有较大差异，大家很容易写出风格迥异的代码出来。如果只有自己一个人用还好，如果是大家合作开发同一个项目，代码风格不同就会造成不小的麻烦。所以约定一个代码风格是很有必要的。</p>
<p>本文中的代码风格约定只是我的个人建议，可以根据自己的需求或者喜好来调整。本文的代码风格约定，在一定程度上也适用于 bash。</p>
<p>注意需要有丰富 shell 编程经验的人制定和维护代码风格约定，不然很容易无法执行或者流于形式而解决不了实际问题。代码风格约定不只需要约定代码怎么写，而且要说明为什么要这么写，不然容易因为难以服众而无法推广。</p>
<h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><ul>
<li>统一使用 4 个空格来缩进。</li>
</ul>
<p>原因：</p>
<ol>
<li>要用空格而不是 tab。因为在终端上 <code>cat</code> <code>less</code> <code>diff</code> 等命令都将 tab 显示成 8 个空格的宽度，有些命令是不可配置的（即使可配置，要让所有机器配置同步也是件麻烦的事情）。如果自己在编辑器上配置 tab 为 4 个或者 2 个空格，那么就会和 <code>cat</code> <code>less</code> 等命令的显示方法不一致，会导致很多麻烦。</li>
<li>8 个空格太长，缩进几次就会导致行太长，而 shell 脚本每行不宜过长。</li>
<li>2 个空格的话，如果缩进比较频繁，看起来比较费劲。另外如果写代码时不小心多了或者少了一个空格，在某些场景，不看逻辑的话，就无法确定是多个一个还是少了一个，更容易导致他人错误的修改，或者代码越改越乱。</li>
<li>对于 4 个空格也可能导致缩进层数多时行太长的问题，通过修改逻辑减少缩进层数或者折行的方法，而不是减少缩进的空格数量来解决。</li>
</ol>
<h3 id="每行代码最多字符数"><a href="#每行代码最多字符数" class="headerlink" title="每行代码最多字符数"></a>每行代码最多字符数</h3><ul>
<li>非特殊场景，每行代码不超过 100 个字符。</li>
</ul>
<p>原因：</p>
<ol>
<li>代码过长，阅读起来不方便，用 <code>diff</code> 之类工具对代码进行分析处理也不方便，所以需要约定最长字符数。</li>
<li>经典的 80 个字符的约定，是受当时的输出设备限制而产生的标准，而现在的屏幕基本都是宽屏的，终端模拟器也都是可调大小的（而不是固定的 80x24）没必要削足适履迎合陈旧的标准，浪费屏幕空间。而且如果使用 80 个字符的约定，很容易遇到需要折行的情况，反而会导致可读性下降。</li>
<li>如果一行超过了 100 个字符，通常说明逻辑太多，需要分行或者折行。</li>
<li>某些特殊场景，比如显示一个 ASCII 字符组成的图片，会有一行超过 100 个字符的需求，所有不能严格执行每行必须不超过 100 个字符的约定。如果分行或者折行会不可避免地导致代码可读性下降，那么优先考虑可读性。</li>
</ol>
<h3 id="折行"><a href="#折行" class="headerlink" title="折行"></a>折行</h3><ul>
<li>在前一行尾部加一个空格和 <code>\</code> 折行，折行后缩进一层（4 个空格）。</li>
<li>如果缩进的是一个文本块，可以使用对齐缩进，也可以使用 4 个空格的固定缩进。</li>
<li>如果是在 <code>aa &amp;&amp; bb || cc</code>、<code>[[ ]]</code> 或者 <code>(( ))</code> 中折行，<code>&amp;&amp;</code> <code>||</code> 放在下一行的行首。</li>
</ul>
<p>原因：</p>
<ol>
<li>折行的缩进和普通的缩进都是为了体现代码的递进关系，没必要区分对待（比如折行缩进两层）。</li>
<li>如果为了看起来美观，使用对齐缩进而不是固定缩进。那么因为每个人的审美不同，很容易产生不同的缩进方法，从而产生不必要的麻烦。但对文本块来说比较特殊，因为通常对齐缩进不会产生争议。</li>
<li><code>&amp;&amp;</code> 和 <code>||</code> 在逻辑上属于后半个语句，在自然语言中也是这样，比如 <code>明天我去公园或者去逛街</code>，如果需要拆成两个子句，那么会是 <code>明天我去公园，或者去逛街</code>，而不是 <code>明天我去公园或者，去逛街</code>。对代码来说也是一样。而且把 <code>&amp;&amp;</code> 或 <code>||</code> 放在行首更容易对齐，看起来更舒服。</li>
</ol>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><ul>
<li>在缩进和对齐之外的场景，不允许出现逻辑上不必要的连续多个空格。</li>
<li><code>+</code> <code>&amp;&amp;</code> <code>|</code> 等双元运算符左右要加一个空格。</li>
<li><code>!</code> <code>~</code>等一元运算符和作用对象之间不加空格。</li>
<li><code>( )</code> 和 <code>(( ))</code> <code>&#123; &#125;</code> 内侧不加空格，<code>[[ ]]</code> 因为语法需要，内侧加一个空格。</li>
<li><code>;</code> 之前不加空格，之后加一个空格。</li>
<li>定义函数时（以及在 <code>(( ))</code> 中调用函数时），函数名和 <code>(</code> 之间不加空格。</li>
<li><code>if </code> <code>while</code> 等关键字和后边的内容之间加一个空格。</li>
<li><code>if [[ ]] &#123;</code> 等场景中，<code>&#123;</code> 和前边的内容之间加一个空格。</li>
<li>变量和 <code>[ ]</code> 之间不加空格，用 <code>[ ]</code> 取数组或者哈希表值时，<code>[ ]</code> 内侧不加空格。</li>
<li><code>&gt;</code> <code>&lt;</code> 等重定向符号和文件或者文件描述符之间不加空格。</li>
</ul>
<p>原因：</p>
<ol>
<li>适量地添加空格可以让代码更清晰易读。</li>
<li>这些约定基本属于很多编程语言代码风格中约定成俗的习惯，符合多数人的审美。</li>
</ol>
<h3 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h3><ul>
<li>非特殊场景，不允许出现超过两个连续空行。</li>
<li><code>#!/bin/zsh</code> 后加一个空行。</li>
<li><code>if </code> <code>while</code> 等语句块之后加一个空行。</li>
<li>定义函数后加一个空行。</li>
<li>逻辑关系不强的两行（或者两块）代码之间，根据逻辑关系强弱（自行判断），加一个或两个空行。</li>
</ul>
<p>原因：</p>
<ol>
<li>适量添加空格，可以让代码逻辑按照空行分隔，提高可读性。</li>
<li>因为添加空行的方法涉及诸多因素，很难详细约定，主要靠开发者自行判断。</li>
</ol>
<h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><ul>
<li>在判断条件的场景，不使用 <code>[ ]</code>，用 <code>[[ ]]</code> 代替。</li>
<li>在数值计算的场景，使用 <code>$(( ))</code> 而不是 <code>$[ ]</code>。</li>
</ul>
<p>原因：</p>
<ol>
<li>在判断条件的场景，<code>[ ]</code> 的功能没有 <code>[[ ]]</code> 丰富，而且二者的用法存在差异，混合使用容易出问题。</li>
<li>在数值比较或者计算的场景，<code>$[ ]</code> 的功能没有 <code>$(( ))</code> 丰富，混合使用容易出问题。</li>
<li><code>[ ]</code> 在各种地方功能不一致，非必要场景尽量避免使用。</li>
</ol>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul>
<li>字符串常量中如果没有特殊符号，两端可以不加引号，也可以加引号。</li>
<li>使用数值时，两端不加引号。</li>
</ul>
<p>原因：</p>
<ol>
<li>如果任何字符串常量两端都加引号，容易让代码中充斥着引号，影响可读性。并且如果不小心误删引号，容易导致难以定位错误。</li>
<li>shell 脚本和很多其他编程语言不同，处理字符串的逻辑占很大部分，每个字符串常量两边都加引号的话，会增加很多额外工作量。</li>
</ol>
<h3 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h3><ul>
<li>用 <code>$var</code> 取变量值时，两边不加双引号，除非需要将非字符串变量转换成字符串。</li>
<li>在非必须场景，不需要加 <code>$&#123;var&#125;</code> 中的大括号。</li>
<li>变量使用前要明确指明是局部变量（用 <code>local</code> 定义）还是全局变量（用 <code>typeset -g</code> 定义）。</li>
<li>能用局部变量的地方全部使用局部变量（用 <code>local</code> 定义）。</li>
<li>变量名中的单词可以使用下划线分隔或者驼峰风格，在不影响可读性的情况也可以使用全小写字母，但在同一个文件中要一致。</li>
</ul>
<p>原因：</p>
<ol>
<li>和 bash 不同，zsh 在使用 <code>$var</code> 读取变量内容时，不用因为变量不存在、值为空、包含特殊符号而产生各种逻辑错误，所以无需在两端加双引号。</li>
<li>用 <code>$var</code> 读变量是很多编程语言都有的用法，而 <code>$&#123;var&#125;</code> 几乎是 shell 中特有的用法，并且输入更麻烦，没必要推广这种用法。而且因为不加大括号导致变量名粘连而出错的情况，编写代码时即可识别出来，和外部输入无关，不需要为了避免不存在的问题而输入很多额外的大括号。</li>
<li>如果不指明变量是全局变量还是局部变量，默认是全局变量，有时候很难简单地判断一个变量是作为全局变量还是局部变量使用的，这样会给脚本的维护者带来很多麻烦。</li>
<li>如果能使用局部变量的地方使用全局变量，更容易出现全局变量重名而互相影响导致错误的情况。这种错误是很难排查的（因为不会产生语法错误，容易让人怀疑是代码逻辑的问题，而不去检查是否有全局变量重名的情况），往往会浪费开发或者测试人员大量的时间。</li>
<li>不同编程语言的开发者对变量名的风格偏好不同，不宜规定统一风格。</li>
</ol>
<h3 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h3><ul>
<li>字符串常量两端可以添加双引号或者单引号，但同一个文件中风格要一致。</li>
</ul>
<p>原因：</p>
<ol>
<li>双引号和单引号的功能不同，混合使用是不可避免的。</li>
<li>在双引号和单引号都适用的场景，统一使用一种引号，可以让代码更整洁易读。</li>
<li>编程语言背景不同的开发者，对单双引号的偏好不同，不宜强行规定默认使用的引号。</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li>可以使用 <code>name()</code> 或者 <code>function name()</code> 定义函数，但同一个文件中风格要一致。</li>
</ul>
<p>原因：</p>
<ol>
<li>如果约定统一使用 <code>name()</code> 定义函数，那么没有照顾 JavaScript 等编程语言开发者的习惯，而且 <code>function</code> 关键字有助于代码的搜索。</li>
<li>如果约定统一使用 <code>function name()</code> 定义函数，需要额外输入 9 个字符，而意义有限，投入比产出要大。</li>
</ol>
<h3 id="脚本行数"><a href="#脚本行数" class="headerlink" title="脚本行数"></a>脚本行数</h3><ul>
<li>非特殊场景，单个脚本文件不超过 1000 行。</li>
</ul>
<p>原因：</p>
<ol>
<li>因为 shell 脚本的特性，单个脚本文件过长容易导致各种问题（比如全局变量互相影响）。1000 行代码对于多数场景都够用了。</li>
<li>如果写的是安装脚本之类需要分发的脚本，那么分发单个文件要比分发多个文件（需要打包解包等额外工作）容易很多，这种场景可能需要写长脚本。所以不宜强行规定单个脚本文件最大行数。</li>
</ol>
<h3 id="语句风格"><a href="#语句风格" class="headerlink" title="语句风格"></a>语句风格</h3><ul>
<li>条件、循环、选择等语句，可以使用本系列教程中的风格，也可以使用 POSIX shell 风格，但同一个文件的风格要一致。</li>
</ul>
<p>原因：</p>
<ol>
<li>本系列教程的中语句风格简洁易懂，并且和 c、Java、JavaScript 等语言的语句风格相近。</li>
<li>从 bash 迁移过来的开发者习惯使用 POSIX shell 风格语句，需要兼顾。</li>
</ol>
<p>本系列教程语句风格实例：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ ... ]] &#123;</span><br><span class="line">&#125; <span class="keyword">elif</span> ((...)) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$i</span> &#123;</span><br><span class="line">    (a)</span><br><span class="line">    ...</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (*)</span><br><span class="line">    ...</span><br><span class="line">    ;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>POSIX shell 语句风格实例：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ ... ]]; <span class="keyword">then</span></span><br><span class="line"><span class="keyword">elif</span> ((...)); <span class="keyword">then</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$i</span> <span class="keyword">in</span></span><br><span class="line">    (a)</span><br><span class="line">    ...</span><br><span class="line">    ;;</span><br><span class="line"></span><br><span class="line">    (*)</span><br><span class="line">    ...</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<h3 id="总结-16"><a href="#总结-16" class="headerlink" title="总结"></a>总结</h3><p>本文介绍了我建议的 zsh 代码风格，可以适当参考。</p>
<h1 id="第二十一篇-测试方法以及编写可测试代码的方法"><a href="#第二十一篇-测试方法以及编写可测试代码的方法" class="headerlink" title="第二十一篇 测试方法以及编写可测试代码的方法"></a>第二十一篇 测试方法以及编写可测试代码的方法</h1><h3 id="导读-20"><a href="#导读-20" class="headerlink" title="导读"></a>导读</h3><p>在正式的场景，代码写完后都是需要测试的，shell 脚本也不例外。但 shell 脚本的特性导致测试方法和其他语言有所不同。</p>
<h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>作为一种重要的测试方法，单元测试在很多种编程语言程序测试中起到举重轻重的作用。但不幸的是，单元测试基本不适用于 shell 脚本。并不是说 shell 脚本不能被单元测试，而是说单元测试能测试出来的问题很少，投入却很大。为了让 shell 脚本能被单元测试，50 行的代码很可能要改写成 100 多行甚至更多行。更重要的是 shell 脚本严重依赖外部环境，多数问题需要对脚本整体进行功能测试才能发现，而不是对单个函数进行单元测试。对单元测试的精力投入很可能会减少在功能测试的精力投入。</p>
<p>所以不建议推行 shell 脚本的单元测试，这不仅会让开发者很痛苦，也很难减少问题的出现几率，甚至有可能适得其反。</p>
<h3 id="单个脚本的功能测试"><a href="#单个脚本的功能测试" class="headerlink" title="单个脚本的功能测试"></a>单个脚本的功能测试</h3><p>Shell 脚本的最小测试粒度是单个脚本。必须保证单个脚本是容易测试的，不能多个脚本耦合太紧密而难以对其中某一个进行单独测试。</p>
<p>有主体逻辑的脚本依赖的外部环境必须是容易模拟的。比如需要从数据库中读取数据，对数据进行处理，然后写入到文件中，这些功能不能在同一个脚本中完成。因为数据库这个外部环境不容易模拟，会导致测试困难。需要把读写数据库的功能独立成单独的脚本，功能尽量简单，测试该脚本时只需要关心数据是否正常读取了出来，格式是否被正确转换等等，而不需要关心处理数据的具体逻辑。处理数据的主体逻辑代码要独立成一个（或者多个）脚本，测试该脚本时，无需准备数据库环境，直接用另一个脚本或者数据文件取代读取数据库的脚本，提供测试数据。如果文件写入的环境复杂（比如文件或者目录结构复杂，或者要写入到分布式文件系统等等），也需要将文件写入的脚本独立出来以便更易于测试。</p>
<p>对有主体逻辑的脚本进行功能测试，不能手动进行，必须写测试脚本，可以自动运行。每次脚本改动后进行回归测试。项目稳定后，可以在每次提交代码后自动运行测试脚本。测试脚本必须覆盖正常和异常情况，不能只覆盖正常情况。异常情况的多少，要根据脚本的复杂度而定。</p>
<p>有复杂外部依赖的脚本，功能必须单一，逻辑尽量简单，代码尽量稳定，不经常改动。比如读写数据库、启停进程、复杂的目录文件操作等有复杂外部依赖的脚本，功能必须单一，只与一个特定的外部依赖交互，提供尽量和外部依赖无关的中间数据，尽量不包含和外部环境无关的逻辑。该类脚本要容易模拟，以便在测试其他部分时不再需要依赖外部环境。</p>
<p>对于有复杂外部依赖的脚本，可以写脚本自动测试，也可以手动测试，测试时需要包含正常和异常的情况，不能只测试正常情况。</p>
<h3 id="功能测试示例"><a href="#功能测试示例" class="headerlink" title="功能测试示例"></a>功能测试示例</h3><p><strong>需要写脚本完成如下功能：</strong></p>
<p>如果 process1 和 process2 两个进程都存在，以 process2 进程 cwd 目录中的 <code>data/output.txt</code> 为输入，做一些比较复杂的处理，然后输出到 process1 进程 cwd 目录中的 <code>data/input.txt</code> 文件（如果该文件已存在，则不处理），处理完后，删除之前的 <code>data/output.txt</code>。</p>
<p><strong>分析：</strong></p>
<p>process1 和 process2 两个进程都是复杂的外部依赖，不能在主体逻辑脚本里直接依赖它们，所以要把检查进程是否存在的逻辑独立成单独的脚本。输入和输出文件的路径依赖进程路径，为了测试方便，也要把获取文件路径的逻辑独立成单独的脚本。</p>
<p><strong>脚本功能实现：</strong></p>
<p>检查进程是否存在和获取进程 cwd 目录的 util.zsh 脚本：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    pidof <span class="variable">$1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">get_process_cwd</span></span>() &#123;</span><br><span class="line">    readlink /proc/<span class="variable">$1</span>/cwd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>主体逻辑脚本 main.zsh：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有错误即退出，可以省掉很多错误处理的代码</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到脚本当前目录</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;0:h&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载依赖的脚本</span></span><br><span class="line"><span class="built_in">source</span> ./util.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查进程是否存在</span></span><br><span class="line"><span class="built_in">local</span> process1_pid=$(check_process process1)</span><br><span class="line"><span class="built_in">local</span> process2_pid=$(check_process process2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 input 和 output 是相对脚本来说的</span></span><br><span class="line"><span class="built_in">local</span> input_file=$(get_process_cwd <span class="variable">$process2_pid</span>)/data/output.txt</span><br><span class="line"><span class="built_in">local</span> output_file=$(get_process_cwd <span class="variable">$process1_pid</span>)/data/input.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果输入文件不存在，直接退出</span></span><br><span class="line">[[ -e <span class="variable">$input_file</span> ]] || &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$input_file</span> not found.</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果输出文件已存在，也直接退出</span></span><br><span class="line">[[ -e <span class="variable">$output_file</span> ]] &amp;&amp; &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$output_file</span> already exists.</span><br><span class="line">    <span class="built_in">exit</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 $input_file 内容</span></span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将结果输出到 $output_file</span></span><br><span class="line"><span class="comment"># 省略</span></span><br></pre></td></tr></table></figure>

<p><strong>功能测试方法：</strong></p>
<p>util.zsh 里的两个函数功能过于简单，无需测试。</p>
<p>测试 main.zsh 时，需要构造一系列测试用的 util.zsh，用于模拟各种情况：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程存在的情况</span></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $$</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程不存在的情况</span></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程 process1 存在而 process2 不存在的情况</span></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    [[ <span class="variable">$1</span> == process1 ]] &amp;&amp; <span class="built_in">echo</span> 1234 &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    [[ <span class="variable">$1</span> == process2 ]] &amp;&amp; <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出了进程号，但实际进程不存在的情况</span></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他情况</span></span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径存在的情况</span></span><br><span class="line"><span class="function"><span class="title">get_process_cwd</span></span>() &#123;</span><br><span class="line">    [[ <span class="variable">$1</span> == process1 ]] &amp;&amp; <span class="built_in">echo</span> /path/to/cwd1 &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    [[ <span class="variable">$1</span> == process2 ]] &amp;&amp; <span class="built_in">echo</span> /path/to/cwd2 &amp;&amp; <span class="built_in">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 路径不存在的情况</span></span><br><span class="line"><span class="function"><span class="title">get_process_cwd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出了路径，但路径实际不存在的情况</span></span><br><span class="line"><span class="function"><span class="title">get_process_cwd</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> /wrong/path</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他情况</span></span><br><span class="line"><span class="comment"># 省略</span></span><br></pre></td></tr></table></figure>

<p>然后组合这些情况，写测试脚本判断 main.zsh 的处理是否符合预期。</p>
<p>其中一个测试脚本样例：</p>
<p>util_test1.zsh 内容：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进程存在</span></span><br><span class="line"><span class="function"><span class="title">check_process</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> $$</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接返回正确的路径</span></span><br><span class="line"><span class="function"><span class="title">get_process_cwd</span></span>() &#123;</span><br><span class="line">    [[ <span class="variable">$1</span> == process1 ]] &amp;&amp; <span class="built_in">echo</span> /path/to/cwd1 &amp;&amp; <span class="built_in">return</span></span><br><span class="line">    [[ <span class="variable">$1</span> == process2 ]] &amp;&amp; <span class="built_in">echo</span> /path/to/cwd2 &amp;&amp; <span class="built_in">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>test.zsh 内容：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/zsh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用于测试的函数，可以独立成单独脚本以便复用</span></span><br><span class="line"><span class="function"><span class="title">assert_ok</span></span>() &#123;</span><br><span class="line">    ((<span class="variable">$1</span> == 0)) || &#123;</span><br><span class="line">        <span class="built_in">echo</span> Error, retcode: <span class="variable">$1</span></span><br><span class="line">        <span class="built_in">exit</span> 1</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">check_output_file</span></span>() &#123;</span><br><span class="line">    <span class="comment"># 检查输出文件是否符合预期</span></span><br><span class="line">    <span class="comment"># 省略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 util_test1.zsh</span></span><br><span class="line">ln -sf util_test1.zsh util.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行脚本</span></span><br><span class="line">./main.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查返回值是否正常</span></span><br><span class="line">assert_ok $?</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查输出文件是否符合预期</span></span><br><span class="line">check_output_file /path/to/output/file</span><br><span class="line"></span><br><span class="line"><span class="comment"># 其他检查</span></span><br><span class="line"><span class="comment"># 省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用 util_test2.zsh</span></span><br><span class="line">ln -sf util_test2.zsh util.zsh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略</span></span><br></pre></td></tr></table></figure>

<h3 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h3><p>测试完每个脚本的功能后，需要将各个脚本以及其他程序整合起来测试互相调用过程是否正常。如果功能比较复杂，需要分批整合，测试各个逻辑单元是否能正常工作。在这部分测试中，和外部环境交互的脚本如果逻辑较为简单，可以不参与，用模拟脚本替代。可以手动测试或自动测试。同样不能只测试正常情况。</p>
<h3 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h3><p>将所有相关组件整合起来，测试整个系统或者子系统的功能。模拟脚本不能参与系统测试，必须使用真实的外部环境。系统测试通常需要手动进行，可以用自动化测试系统来辅助。需要覆盖尽可能多的情况，不能只测试系统的正常功能。</p>
<h3 id="总结-17"><a href="#总结-17" class="headerlink" title="总结"></a>总结</h3><p>本文简单介绍了 shell 脚本的测试方法，以及编写可测试代码的方法。</p>
<h1 id="第二十二篇-Bash-和-zsh-用法简明对照表"><a href="#第二十二篇-Bash-和-zsh-用法简明对照表" class="headerlink" title="第二十二篇 Bash 和 zsh 用法简明对照表"></a>第二十二篇 Bash 和 zsh 用法简明对照表</h1><h3 id="导读-21"><a href="#导读-21" class="headerlink" title="导读"></a>导读</h3><p>习惯写 bash 的开发者容易将 bash 下的用法用在 zsh 上，虽然多数情况并不会产生错误，但往往会多做很多不必要的工作，让脚本显得更臃肿或难以理解。</p>
<h3 id="Bash-和-zsh-用法简明对照表"><a href="#Bash-和-zsh-用法简明对照表" class="headerlink" title="Bash 和 zsh 用法简明对照表"></a>Bash 和 zsh 用法简明对照表</h3><table>
<thead>
<tr>
<th>Bash 用法</th>
<th>Zsh 用法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>&quot;$var&quot;</code></td>
<td><code>$var</code></td>
<td>避免变量中有空格导致异常</td>
</tr>
<tr>
<td><code>&quot;$@&quot;</code></td>
<td><code>$*</code></td>
<td>避免变量中有空格导致异常</td>
</tr>
<tr>
<td><code>&quot;$&#123;array[@]&#125;&quot;</code></td>
<td><code>$array</code></td>
<td>取数组所有元素，<code>@</code> 可改成 <code>*</code></td>
</tr>
<tr>
<td><code>&quot;$&#123;#array[@]&#125;&quot;</code></td>
<td><code>$#array</code></td>
<td>取数组中元素个数，<code>@</code> 可改成 <code>*</code></td>
</tr>
<tr>
<td><code>&quot;$&#123;array[n - 1]&#125;&quot;</code></td>
<td><code>$array[n]</code></td>
<td>取数组第 n 个元素，bash 从 0 开始，zsh 从 1 开始</td>
</tr>
<tr>
<td><code>&quot;$array&quot;</code></td>
<td><code>$array[1]</code></td>
<td>Bash 中的 <code>$array</code> 是取数组的第一个元素</td>
</tr>
<tr>
<td><code>echo a*b</code></td>
<td><code>echo &quot;a*b&quot;</code></td>
<td>Zsh 默认配置中，通配符如果匹配不到文件会报错</td>
</tr>
<tr>
<td><code>if true; then :; fi</code></td>
<td><code>if true &#123;&#125;</code></td>
<td>Zsh 中不需要使用 <code>:</code> 作为空语句</td>
</tr>
<tr>
<td><code>[ &quot;$var&quot; == value ]</code></td>
<td><code>[[ $var == value ]]</code></td>
<td>Zsh 中的 <code>[ ]</code> 里不支持 <code>==</code>，一律用 <code>[[ ]]</code></td>
</tr>
<tr>
<td><code>ls | tee file | less</code></td>
<td><code>ls &gt; file | less</code></td>
<td>Zsh 中不需要用 <code>tee</code> 即可实现相同功能</td>
</tr>
</tbody></table>
<h3 id="总结-18"><a href="#总结-18" class="headerlink" title="总结"></a>总结</h3><p>本文简单列出了一些 zsh 中已经不再需要的 bash 用法，以及 zsh 和 bash 行为不一致的用法。待补充。</p>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AF%87-%E5%8F%98%E9%87%8F%E5%92%8C%E8%AF%AD%E5%8F%A5"><span class="toc-text">第一篇 变量和语句</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-zsh-%E5%86%99%E8%84%9A%E6%9C%AC"><span class="toc-text">为什么用 zsh 写脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zsh-%E8%84%9A%E6%9C%AC%E6%A0%B7%E4%BE%8B"><span class="toc-text">Zsh 脚本样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8-shell-%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80"><span class="toc-text">为什么要使用 shell 脚本语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E7%BA%A6%E5%AE%9A"><span class="toc-text">格式约定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">变量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%AF%94%E8%BE%83"><span class="toc-text">变量比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5"><span class="toc-text">语句</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">分支语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E9%80%89%E6%8B%A9%E8%AF%AD%E5%8F%A5"><span class="toc-text">用户输入选择语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E8%AF%AD%E5%8F%A5"><span class="toc-text">异常处理语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E7%9A%84%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">简化的条件语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AF%87-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-text">第二篇 字符串处理之常用操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-1"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6"><span class="toc-text">字符串长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E7%89%87"><span class="toc-text">字符串切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E6%96%AD"><span class="toc-text">字符串截断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%A5%E6%89%BE"><span class="toc-text">字符串查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%8D%E5%8E%86%E5%AD%97%E7%AC%A6"><span class="toc-text">遍历字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2"><span class="toc-text">字符串替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-text">判断字符串变量是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%88%A4%E6%96%AD"><span class="toc-text">字符串匹配判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E5%86%99%E8%BD%AC%E6%8D%A2"><span class="toc-text">大小写转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E6%96%87%E4%BB%B6%E5%90%8D%E6%88%AA%E5%8F%96"><span class="toc-text">目录文件名截取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E8%BD%AC%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84"><span class="toc-text">相对路径转绝对路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E9%9A%94"><span class="toc-text">字符串分隔</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">多行字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">读取文件内容到字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E8%BF%9B%E7%A8%8B%E8%BE%93%E5%87%BA%E5%88%B0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">读取进程输出到字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AF%87-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E4%B9%8B%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6%E5%92%8C%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">第三篇 字符串处理之转义字符和格式化输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-2"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%AD%97%E7%AC%A6"><span class="toc-text">转义字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%BC%95%E5%8F%B7"><span class="toc-text">单引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="toc-text">双引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%BC%95%E5%8F%B7"><span class="toc-text">反引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#print-%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95"><span class="toc-text">print 命令用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#print-%E5%91%BD%E4%BB%A4%E9%80%89%E9%A1%B9%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D"><span class="toc-text">print 命令选项功能介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#printf-%E5%91%BD%E4%BB%A4%E7%94%A8%E6%B3%95"><span class="toc-text">printf 命令用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%B8%A6%E9%A2%9C%E8%89%B2%E5%92%8C%E7%89%B9%E6%AE%8A%E6%A0%B7%E5%BC%8F%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">输出带颜色和特殊样式的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#print-%E9%80%89%E9%A1%B9%E5%88%97%E8%A1%A8"><span class="toc-text">print 选项列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-1"><span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AF%87-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E4%B9%8B%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">第四篇 字符串处理之通配符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-3"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95"><span class="toc-text">通配符的基本用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%BC%BA%E7%89%88%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">加强版通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-2"><span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AF%87-%E6%95%B0%E7%BB%84"><span class="toc-text">第五篇 数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-4"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89"><span class="toc-text">数组定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%AF%BB%E5%86%99"><span class="toc-text">元素读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5"><span class="toc-text">数组拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86"><span class="toc-text">数组遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%88%87%E7%89%87"><span class="toc-text">数组切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE"><span class="toc-text">元素查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F"><span class="toc-text">元素排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">去除重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%9E%E7%BB%AD%E5%AD%97%E7%AC%A6%E6%88%96%E8%80%85%E6%95%B0%E5%80%BC%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84"><span class="toc-text">使用连续字符或者数值构造数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84"><span class="toc-text">从字符串构造数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84"><span class="toc-text">从文件构造数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E6%95%B0%E7%BB%84"><span class="toc-text">从文件列表构造数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BA%A4%E9%9B%86%E5%B7%AE%E9%9B%86"><span class="toc-text">数组交集差集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%BA%A4%E5%8F%89%E5%90%88%E5%B9%B6"><span class="toc-text">数组交叉合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E7%BB%9F%E4%B8%80%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-text">对数组中的字符串进行统一的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-3"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2"><span class="toc-text">更新历史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AF%87-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">第六篇 哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-5"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%9A%E4%B9%89"><span class="toc-text">哈希表定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E8%AF%BB%E5%86%99-1"><span class="toc-text">元素读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E6%8B%BC%E6%8E%A5"><span class="toc-text">哈希表拼接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E9%81%8D%E5%8E%86"><span class="toc-text">哈希表遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%9F%A5%E6%89%BE-1"><span class="toc-text">元素查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E6%8E%92%E5%BA%8F-1"><span class="toc-text">元素排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%96%87%E4%BB%B6%E6%9E%84%E9%80%A0%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">从字符串、文件构造哈希表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%93%88%E5%B8%8C%E8%A1%A8%E4%B8%AD%E7%9A%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86"><span class="toc-text">对哈希表中的每个元素统一处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">多维哈希表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E4%B8%80%E7%BB%B4%E5%93%88%E5%B8%8C%E8%A1%A8%E6%A8%A1%E6%8B%9F%E5%A4%9A%E7%BB%B4%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">用一维哈希表模拟多维哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2%E8%AE%BF%E9%97%AE%E6%9D%A5%E6%A8%A1%E6%8B%9F%E5%A4%9A%E7%BB%B4%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-text">用字符串分割访问来模拟多维哈希表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AF%87-%E6%95%B0%E5%80%BC%E8%AE%A1%E7%AE%97"><span class="toc-text">第七篇 数值计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-6"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%92%8C%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">整数和浮点数类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-text">数学函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-4"><span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AF%87-%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E8%AF%AD"><span class="toc-text">第八篇 变量修饰语</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-7"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BF%AE%E9%A5%B0%E8%AF%AD%E7%9A%84%E6%A0%BC%E5%BC%8F"><span class="toc-text">变量修饰语的格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E9%BB%98%E8%AE%A4%E5%80%BC"><span class="toc-text">变量默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8B%BC%E6%8E%A5%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">数组拼接成字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%87%E5%88%86%E6%88%90%E6%95%B0%E7%BB%84"><span class="toc-text">字符串切分成数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text">输出变量类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E6%95%B0%E7%BB%84%E6%88%96%E5%93%88%E5%B8%8C%E8%A1%A8%E5%B5%8C%E5%A5%97%E5%8F%96%E5%80%BC"><span class="toc-text">字符串、数组或哈希表嵌套取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AE%B9%E4%BD%9C%E4%B8%BA%E5%8F%98%E9%87%8F%E5%90%8D%E5%86%8D%E5%8F%96%E5%80%BC"><span class="toc-text">字符串内容作为变量名再取值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E9%BD%90%E6%88%96%E6%88%AA%E6%96%AD%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">对齐或截断数组中的字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-5"><span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AF%87-%E5%87%BD%E6%95%B0%E5%92%8C%E8%84%9A%E6%9C%AC"><span class="toc-text">第九篇 函数和脚本</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-8"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AE%9A%E4%B9%89"><span class="toc-text">函数定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86"><span class="toc-text">参数处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%B5%8C%E5%A5%97"><span class="toc-text">函数嵌套</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC"><span class="toc-text">脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exit-%E5%91%BD%E4%BB%A4"><span class="toc-text">exit 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-getopts-%E5%91%BD%E4%BB%A4%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4%E8%A1%8C%E9%80%89%E9%A1%B9"><span class="toc-text">用 getopts 命令处理命令行选项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-6"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2-1"><span class="toc-text">更新历史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AF%87-%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%92%8C%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86"><span class="toc-text">第十篇 文件查找和批量处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-9"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E4%BE%8B%E5%AD%90"><span class="toc-text">简单例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E6%9F%A5%E6%89%BE"><span class="toc-text">按文件属性查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%85%8D%E7%AC%A6%E4%BF%AE%E9%A5%B0%E8%AF%AD%E5%88%97%E8%A1%A8"><span class="toc-text">通配符修饰语列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%8D%E6%9D%82%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">更复杂的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%96%87%E4%BB%B6%E6%97%B6%E9%97%B4%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-text">按文件时间查找文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6"><span class="toc-text">按文件大小查找文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%8E%92%E5%BA%8F"><span class="toc-text">文件排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-text">组合使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-text">文件批量重命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%B1%95%E5%BC%80%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">不展开通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-7"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2-2"><span class="toc-text">更新历史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AF%87-%E5%8F%98%E9%87%8F%E7%9A%84%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9"><span class="toc-text">第十一篇 变量的进阶内容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-10"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeset-%E5%91%BD%E4%BB%A4"><span class="toc-text">typeset 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%AE%B9%E4%B8%BA%E5%B0%8F%E5%86%99%E6%88%96%E8%80%85%E5%A4%A7%E5%86%99"><span class="toc-text">强制字符串内容为小写或者大写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E4%B8%BA%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">设置变量为环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%98%E9%87%8F%E4%B8%BA%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F"><span class="toc-text">设置变量为只读变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%95%B0%E7%BB%84%E4%B8%8D%E5%8C%85%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0"><span class="toc-text">设置数组不包含重复元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%95%B4%E6%95%B0%E7%9A%84%E4%BD%8D%E6%95%B0"><span class="toc-text">设置整数的位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">进制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%AF%B9%E5%A4%9A%E4%B8%AA%E5%8F%98%E9%87%8F%E8%B5%8B%E7%9B%B8%E5%90%8C%E7%9A%84%E5%80%BC"><span class="toc-text">同时对多个变量赋相同的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-text">绑定字符串和数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E6%96%B9%E5%BC%8F"><span class="toc-text">显示变量的定义方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%E8%AF%A5%E5%8A%A0%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="toc-text">什么地方该加双引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-8"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2-3"><span class="toc-text">更新历史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AF%87-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">第十二篇 [[ ]] 的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-11"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">比较字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6"><span class="toc-text">判断文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%96%87%E4%BB%B6"><span class="toc-text">比较文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%95%B0%E5%80%BC"><span class="toc-text">比较数值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8-1"><span class="toc-text">组合使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7"><span class="toc-text">[ ] 符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-9"><span class="toc-text">参考</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AF%87-%E7%AE%A1%E9%81%93%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">第十三篇 管道和重定向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-12"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-text">管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E7%AE%A1%E9%81%93%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82"><span class="toc-text">关于管道的更多细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E5%AE%9A%E5%90%91"><span class="toc-text">重定向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E5%A4%9A%E9%87%8D%E5%AE%9A%E5%90%91%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">更多重定向的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%AE%A1%E9%81%93"><span class="toc-text">命名管道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-%E5%91%BD%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">exec 命令的用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83-10"><span class="toc-text">参考</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2-4"><span class="toc-text">更新历史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AF%87-%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-text">第十四篇 文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-13"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E6%96%87%E4%BB%B6"><span class="toc-text">清空文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E5%86%99%E5%85%A5"><span class="toc-text">多行文本写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-mapfile-%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-text">用 mapfile 读写文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE%E5%86%99%E5%85%A5"><span class="toc-text">从文件中间位置写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6"><span class="toc-text">读文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B4%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-text">读取整个文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%A1%8C%E9%81%8D%E5%8E%86%E6%96%87%E4%BB%B6"><span class="toc-text">按行遍历文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E8%A1%8C"><span class="toc-text">读取指定行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E4%BB%B6%E5%88%B0%E6%95%B0%E7%BB%84"><span class="toc-text">读取文件到数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E6%95%B0%E9%87%8F%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-text">读取指定数量的字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E6%96%87%E4%BB%B6%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E5%86%85%E5%AE%B9"><span class="toc-text">向文件中间插入内容</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AF%87-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6"><span class="toc-text">第十五篇 进程与作业控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-14"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-text">在子进程中执行代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">在后台运行进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%84%9A%E6%9C%AC%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-text">在脚本中使用后台进程执行代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-text">信号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AF%87-alias-%E5%92%8C-eval-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">第十六篇 alias 和 eval 的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-15"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#alias"><span class="toc-text">alias</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eval"><span class="toc-text">eval</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AF%87-%E4%BD%BF%E7%94%A8-socket-%E6%96%87%E4%BB%B6%E5%92%8C-TCP-%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-text">第十七篇 使用 socket 文件和 TCP 实现进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-16"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Socket-%E6%96%87%E4%BB%B6"><span class="toc-text">Socket 文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP"><span class="toc-text">TCP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E6%A0%B7%E4%BE%8B"><span class="toc-text">程序样例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AF%87-%E6%9B%B4%E5%A4%9A%E5%86%85%E7%BD%AE%E6%A8%A1%E5%9D%97%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">第十八篇 更多内置模块的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-17"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-text">模块的使用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E6%A8%A1%E5%9D%97"><span class="toc-text">日期时间相关模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99-gdbm-%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text">读写 gdbm 数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%91%BD%E4%BB%A4"><span class="toc-text">调度命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99%E5%91%BD%E4%BB%A4"><span class="toc-text">底层的文件读写命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%A8%A1%E5%9D%97"><span class="toc-text">其他模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97"><span class="toc-text">自己编写模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AF%87-%E8%84%9A%E6%9C%AC%E5%AE%9E%E4%BE%8B%E8%AE%B2%E8%A7%A3"><span class="toc-text">第十九篇 脚本实例讲解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-18"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%A4%8D%E5%88%B6%E4%B8%80%E4%B8%AA%E7%9B%AE%E5%BD%95%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-text">实例一：复制一个目录的目录结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%AF%BB%E6%89%BE%E4%B8%8D%E9%85%8D%E5%AF%B9%E7%9A%84%E6%96%87%E4%BB%B6"><span class="toc-text">实例二：寻找不配对的文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%B8%89%EF%BC%9A%E7%94%A8-sed-%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6"><span class="toc-text">实例三：用 sed 批量重命名文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%9B%9B%EF%BC%9A%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E7%9A%84-md5-%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E6%96%87%E4%BB%B6"><span class="toc-text">实例四：根据文件的 md5 删除重复文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%BA%94%EF%BC%9A%E8%BD%AC%E6%8D%A2-100-%E4%BB%A5%E5%86%85%E7%9A%84%E6%B1%89%E5%AD%97%E6%95%B0%E5%AD%97%E4%B8%BA%E9%98%BF%E6%8B%89%E4%BC%AF%E6%95%B0%E5%AD%97"><span class="toc-text">实例五：转换 100 以内的汉字数字为阿拉伯数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%85%AD%EF%BC%9A%E4%B8%BA%E5%B8%A6%E4%B8%AD%E6%96%87%E6%B1%89%E5%AD%97%E6%95%B0%E5%AD%97%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D%E9%87%8D%E5%91%BD%E5%90%8D%E6%88%90%E4%BB%A5%E5%AF%B9%E5%BA%94%E6%95%B0%E5%AD%97%E5%BC%80%E5%A4%B4"><span class="toc-text">实例六：为带中文汉字数字的文件名重命名成以对应数字开头</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%B8%83%EF%BC%9A%E7%BB%9F%E4%B8%80%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B7%A5%E5%85%B7"><span class="toc-text">实例七：统一压缩解压工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%85%AB%EF%BC%9A%E6%96%B9%E4%BE%BF%E5%B9%B6%E5%8F%91%E8%BF%90%E8%A1%8C%E5%91%BD%E4%BB%A4%E7%9A%84%E5%B7%A5%E5%85%B7"><span class="toc-text">实例八：方便并发运行命令的工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E4%B9%9D%EF%BC%9A%E6%89%B9%E9%87%8F%E8%BD%AC%E6%8D%A2%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F"><span class="toc-text">实例九：批量转换图片格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-15"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0%E5%8E%86%E5%8F%B2-5"><span class="toc-text">更新历史</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AF%87-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC"><span class="toc-text">第二十篇 代码风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-19"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E8%BF%9B"><span class="toc-text">缩进</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%8F%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%9C%80%E5%A4%9A%E5%AD%97%E7%AC%A6%E6%95%B0"><span class="toc-text">每行代码最多字符数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%98%E8%A1%8C"><span class="toc-text">折行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%A0%BC"><span class="toc-text">空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E8%A1%8C"><span class="toc-text">空行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%AC%E5%8F%B7"><span class="toc-text">括号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F-1"><span class="toc-text">变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%8F%B7"><span class="toc-text">引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E8%A1%8C%E6%95%B0"><span class="toc-text">脚本行数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E9%A3%8E%E6%A0%BC"><span class="toc-text">语句风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-16"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AF%87-%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E7%BC%96%E5%86%99%E5%8F%AF%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">第二十一篇 测试方法以及编写可测试代码的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-20"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-text">单元测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%B8%AA%E8%84%9A%E6%9C%AC%E7%9A%84%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="toc-text">单个脚本的功能测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">功能测试示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-text">集成测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%B5%8B%E8%AF%95"><span class="toc-text">系统测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-17"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AF%87-Bash-%E5%92%8C-zsh-%E7%94%A8%E6%B3%95%E7%AE%80%E6%98%8E%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-text">第二十二篇 Bash 和 zsh 用法简明对照表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%BC%E8%AF%BB-21"><span class="toc-text">导读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bash-%E5%92%8C-zsh-%E7%94%A8%E6%B3%95%E7%AE%80%E6%98%8E%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-text">Bash 和 zsh 用法简明对照表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-18"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol>
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/zsh/"><i class="fa fa-tags"></i>zsh</a>
    
    </div>
  
</div>

    </main>
    
      
<div class="site-comment-contanier" data-plateform="leancloud">
  
    <p id="site-comment-info">
      <i class="fa fa-spinner fa-spin"></i> 评论加载中
    </p>
    <div id="site-comment"></div>
  
</div>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
      <div class="site-footer-info">
        <i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客
      </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: snoire@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2020 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>

    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
        <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
          
            <div>
              <img src="/images/wechat.png" alt="WeChat">
              
                <p>WeChat</p>
              
            </div>
          
            <div>
              <img src="/images/alipay.png" alt="AliPay">
              
                <p>AliPay</p>
              
            </div>
          
        </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/passages/tips_for_using_vim/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/passages/Address_Space/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
      <a href="#site-comment" data-enable="true">
        <i class="fa fa-commenting"></i>
      </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
      <a href="javascript:void(0);" id="site-reward">
        <i class="fa fa-thumbs-up"></i>
      </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>