<!DOCTYPE html>
<html>
  
<head>
  <meta charset="utf-8">
  <meta name="author" content="Snoire" />
  
  
  <title>学习笔记 | Snoire&#39; Blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="笔记,C,notes,Linux,Makefile," />
  

  
  <meta name="description" content="自入职以来的笔记。其中，C 语言部分主要参考 C 语言中文网 以及 Linux C 编程一站式学习；Makefile 语法参考 跟我一起写 Makefile；Linux 命令部分主要参考《LINUX 与 UNIX-SHELL 编程指南》。">

  

  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>
  

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  
    <script src="//unpkg.com/valine/dist/Valine.min.js" async></script>
  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"53Hsawr9k3ISwmY0drKzCs2F-gzGzoHsz","appkey":"SjrIApaUKrCn5iS0dmM0qJ8L","comment":true,"count":true},
    welcome: {"enable":false,"interval":30},
    start_time: "2019-10-08 20:01:24",
    passwords: ["cc8f2b7a1d1a757235e2c7b58b0b1dc1a721eb34c8d06a386d50b654522393d1", ],
    is_post: true,
    lock: false,
    author: "Snoire",
    share: {"twitter":false,"facebook":false,"weibo":false,"qq":false,"wechat":false},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  
<script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>


  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  
<link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">


  
<meta name="generator" content="Hexo 5.2.0"></head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Snoire</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 观察改变世界</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/snoire/" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2019-10-14
    </span>
    
      <span>
        | <a href="/categories/%E7%AC%94%E8%AE%B0/"><i class="fa fa-bookmark"></i>笔记</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    学习笔记
  </h1>
  
  <article class="passage-article">
    <h1 id="学习顺序"><a href="#学习顺序" class="headerlink" title="学习顺序"></a>学习顺序</h1><ul>
<li>HTML</li>
<li>CSS</li>
<li>JavaScript</li>
<li><del>CSS3</del></li>
<li><del>HTML5</del></li>
<li>XML</li>
<li><del>HTML DOM</del></li>
<li><del>PHP</del></li>
<li><del>SQL</del></li>
<li>TCP/IP</li>
<li>Debian打包</li>
<li>linux内核</li>
<li>C语言</li>
<li>数据结构</li>
<li>git</li>
<li>make</li>
<li>cmake</li>
<li>configure</li>
<li>shell</li>
<li>库函数</li>
<li>Makefile</li>
<li>cgi</li>
<li>二叉树</li>
<li>Racket</li>
<li>LISP</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://video.biancheng.net/">链接</a></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25809330/">The Linux Programming Interface</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1219329/">Understanding UNIX/LINUX Programming</a></li>
<li><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4859464/">Unix Network Programming</a></li>
<li><a target="_blank" rel="noopener" href="http://linux.vbird.org/">鸟哥的私房菜</a></li>
<li>Linux Kernel Development</li>
</ul>
<p>看到 10.18 system 看不下去了，换书</p>
<hr>
<h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/c/">参考</a></p>
<h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>这个必须得单独列一章啊</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/yuliying/article/details/72898132">C语言运算符优先级</a></p>
<p><img src="/passages/Learning-notes/Operator-priority.png" alt="运算符优先级"></p>
<p><strong>说明：</strong></p>
<p>​    <strong>同一优先级的运算符，运算次序由结合方向所决定。    简单记就是：！ &gt; 算术运算符 &gt; 关系运算符 &gt; &amp;&amp; &gt; || &gt; 赋值运算符</strong></p>
<h2 id="ASCII-表"><a href="#ASCII-表" class="headerlink" title="ASCII 表"></a>ASCII 表</h2><table>
<thead>
<tr>
<th>Bin(二进制)</th>
<th>Oct(八进制)</th>
<th>Dec(十进制)</th>
<th>Hex(十六进制)</th>
<th>缩写/字符</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000</td>
<td>00</td>
<td>0</td>
<td>0x00</td>
<td>NUL(null)</td>
<td>空字符</td>
</tr>
<tr>
<td>0000 0001</td>
<td>01</td>
<td>1</td>
<td>0x01</td>
<td>SOH(start of headline)</td>
<td>标题开始</td>
</tr>
<tr>
<td>0000 0010</td>
<td>02</td>
<td>2</td>
<td>0x02</td>
<td>STX (start of text)</td>
<td>正文开始</td>
</tr>
<tr>
<td>0000 0011</td>
<td>03</td>
<td>3</td>
<td>0x03</td>
<td>ETX (end of text)</td>
<td>正文结束</td>
</tr>
<tr>
<td>0000 0100</td>
<td>04</td>
<td>4</td>
<td>0x04</td>
<td>EOT (end of transmission)</td>
<td>传输结束</td>
</tr>
<tr>
<td>0000 0101</td>
<td>05</td>
<td>5</td>
<td>0x05</td>
<td>ENQ (enquiry)</td>
<td>请求</td>
</tr>
<tr>
<td>0000 0110</td>
<td>06</td>
<td>6</td>
<td>0x06</td>
<td>ACK (acknowledge)</td>
<td>收到通知</td>
</tr>
<tr>
<td>0000 0111</td>
<td>07</td>
<td>7</td>
<td>0x07</td>
<td>BEL (bell)</td>
<td>响铃</td>
</tr>
<tr>
<td>0000 1000</td>
<td>010</td>
<td>8</td>
<td>0x08</td>
<td>BS (backspace) <code>\b</code></td>
<td>退格</td>
</tr>
<tr>
<td>0000 1001</td>
<td>011</td>
<td>9</td>
<td>0x09</td>
<td>HT (horizontal tab)</td>
<td>水平制表符</td>
</tr>
<tr>
<td>0000 1010</td>
<td>012</td>
<td>10</td>
<td>0x0A</td>
<td>LF (NL line feed, new line) <code>\n</code></td>
<td>换行键</td>
</tr>
<tr>
<td>0000 1011</td>
<td>013</td>
<td>11</td>
<td>0x0B</td>
<td>VT (vertical tab)</td>
<td>垂直制表符</td>
</tr>
<tr>
<td>0000 1100</td>
<td>014</td>
<td>12</td>
<td>0x0C</td>
<td>FF (NP form feed, new page)</td>
<td>换页键</td>
</tr>
<tr>
<td>0000 1101</td>
<td>015</td>
<td>13</td>
<td>0x0D</td>
<td>CR (carriage return) <code>\r</code></td>
<td>回车键</td>
</tr>
<tr>
<td>0000 1110</td>
<td>016</td>
<td>14</td>
<td>0x0E</td>
<td>SO (shift out)</td>
<td>不用切换</td>
</tr>
<tr>
<td>0000 1111</td>
<td>017</td>
<td>15</td>
<td>0x0F</td>
<td>SI (shift in)</td>
<td>启用切换</td>
</tr>
<tr>
<td>0001 0000</td>
<td>020</td>
<td>16</td>
<td>0x10</td>
<td>DLE (data link escape)</td>
<td>数据链路转义</td>
</tr>
<tr>
<td>0001 0001</td>
<td>021</td>
<td>17</td>
<td>0x11</td>
<td>DC1 (device control 1)</td>
<td>设备控制1</td>
</tr>
<tr>
<td>0001 0010</td>
<td>022</td>
<td>18</td>
<td>0x12</td>
<td>DC2 (device control 2)</td>
<td>设备控制2</td>
</tr>
<tr>
<td>0001 0011</td>
<td>023</td>
<td>19</td>
<td>0x13</td>
<td>DC3 (device control 3)</td>
<td>设备控制3</td>
</tr>
<tr>
<td>0001 0100</td>
<td>024</td>
<td>20</td>
<td>0x14</td>
<td>DC4 (device control 4)</td>
<td>设备控制4</td>
</tr>
<tr>
<td>0001 0101</td>
<td>025</td>
<td>21</td>
<td>0x15</td>
<td>NAK (negative acknowledge)</td>
<td>拒绝接收</td>
</tr>
<tr>
<td>0001 0110</td>
<td>026</td>
<td>22</td>
<td>0x16</td>
<td>SYN (synchronous idle)</td>
<td>同步空闲</td>
</tr>
<tr>
<td>0001 0111</td>
<td>027</td>
<td>23</td>
<td>0x17</td>
<td>ETB (end of trans. block)</td>
<td>结束传输块</td>
</tr>
<tr>
<td>0001 1000</td>
<td>030</td>
<td>24</td>
<td>0x18</td>
<td>CAN (cancel)</td>
<td>取消</td>
</tr>
<tr>
<td>0001 1001</td>
<td>031</td>
<td>25</td>
<td>0x19</td>
<td>EM (end of medium)</td>
<td>媒介结束</td>
</tr>
<tr>
<td>0001 1010</td>
<td>032</td>
<td>26</td>
<td>0x1A</td>
<td>SUB (substitute)</td>
<td>代替</td>
</tr>
<tr>
<td>0001 1011</td>
<td>033</td>
<td>27</td>
<td>0x1B</td>
<td>ESC (escape)</td>
<td>换码(溢出)</td>
</tr>
<tr>
<td>0001 1100</td>
<td>034</td>
<td>28</td>
<td>0x1C</td>
<td>FS (file separator)</td>
<td>文件分隔符</td>
</tr>
<tr>
<td>0001 1101</td>
<td>035</td>
<td>29</td>
<td>0x1D</td>
<td>GS (group separator)</td>
<td>分组符</td>
</tr>
<tr>
<td>0001 1110</td>
<td>036</td>
<td>30</td>
<td>0x1E</td>
<td>RS (record separator)</td>
<td>记录分隔符</td>
</tr>
<tr>
<td>0001 1111</td>
<td>037</td>
<td>31</td>
<td>0x1F</td>
<td>US (unit separator)</td>
<td>单元分隔符</td>
</tr>
<tr>
<td>0010 0000</td>
<td>040</td>
<td>32</td>
<td>0x20</td>
<td>(space)</td>
<td>空格</td>
</tr>
<tr>
<td>0010 0001</td>
<td>041</td>
<td>33</td>
<td>0x21</td>
<td>!</td>
<td>叹号</td>
</tr>
<tr>
<td>0010 0010</td>
<td>042</td>
<td>34</td>
<td>0x22</td>
<td>“</td>
<td>双引号</td>
</tr>
<tr>
<td>0010 0011</td>
<td>043</td>
<td>35</td>
<td>0x23</td>
<td>#</td>
<td>井号</td>
</tr>
<tr>
<td>0010 0100</td>
<td>044</td>
<td>36</td>
<td>0x24</td>
<td>$</td>
<td>美元符</td>
</tr>
<tr>
<td>0010 0101</td>
<td>045</td>
<td>37</td>
<td>0x25</td>
<td>%</td>
<td>百分号</td>
</tr>
<tr>
<td>0010 0110</td>
<td>046</td>
<td>38</td>
<td>0x26</td>
<td>&amp;</td>
<td>和号</td>
</tr>
<tr>
<td>0010 0111</td>
<td>047</td>
<td>39</td>
<td>0x27</td>
<td>‘</td>
<td>闭单引号</td>
</tr>
<tr>
<td>0010 1000</td>
<td>050</td>
<td>40</td>
<td>0x28</td>
<td>(</td>
<td>开括号</td>
</tr>
<tr>
<td>0010 1001</td>
<td>051</td>
<td>41</td>
<td>0x29</td>
<td>)</td>
<td>闭括号</td>
</tr>
<tr>
<td>0010 1010</td>
<td>052</td>
<td>42</td>
<td>0x2A</td>
<td>*</td>
<td>星号</td>
</tr>
<tr>
<td>0010 1011</td>
<td>053</td>
<td>43</td>
<td>0x2B</td>
<td>+</td>
<td>加号</td>
</tr>
<tr>
<td>0010 1100</td>
<td>054</td>
<td>44</td>
<td>0x2C</td>
<td>,</td>
<td>逗号</td>
</tr>
<tr>
<td>0010 1101</td>
<td>055</td>
<td>45</td>
<td>0x2D</td>
<td>-</td>
<td>减号/破折号</td>
</tr>
<tr>
<td>0010 1110</td>
<td>056</td>
<td>46</td>
<td>0x2E</td>
<td>.</td>
<td>句号</td>
</tr>
<tr>
<td>0010 1111</td>
<td>057</td>
<td>47</td>
<td>0x2F</td>
<td>/</td>
<td>斜杠</td>
</tr>
<tr>
<td>0011 0000</td>
<td>060</td>
<td>48</td>
<td>0x30</td>
<td>0</td>
<td>字符0</td>
</tr>
<tr>
<td>0011 0001</td>
<td>061</td>
<td>49</td>
<td>0x31</td>
<td>1</td>
<td>字符1</td>
</tr>
<tr>
<td>0011 0010</td>
<td>062</td>
<td>50</td>
<td>0x32</td>
<td>2</td>
<td>字符2</td>
</tr>
<tr>
<td>0011 0011</td>
<td>063</td>
<td>51</td>
<td>0x33</td>
<td>3</td>
<td>字符3</td>
</tr>
<tr>
<td>0011 0100</td>
<td>064</td>
<td>52</td>
<td>0x34</td>
<td>4</td>
<td>字符4</td>
</tr>
<tr>
<td>0011 0101</td>
<td>065</td>
<td>53</td>
<td>0x35</td>
<td>5</td>
<td>字符5</td>
</tr>
<tr>
<td>0011 0110</td>
<td>066</td>
<td>54</td>
<td>0x36</td>
<td>6</td>
<td>字符6</td>
</tr>
<tr>
<td>0011 0111</td>
<td>067</td>
<td>55</td>
<td>0x37</td>
<td>7</td>
<td>字符7</td>
</tr>
<tr>
<td>0011 1000</td>
<td>070</td>
<td>56</td>
<td>0x38</td>
<td>8</td>
<td>字符8</td>
</tr>
<tr>
<td>0011 1001</td>
<td>071</td>
<td>57</td>
<td>0x39</td>
<td>9</td>
<td>字符9</td>
</tr>
<tr>
<td>0011 1010</td>
<td>072</td>
<td>58</td>
<td>0x3A</td>
<td>:</td>
<td>冒号</td>
</tr>
<tr>
<td>0011 1011</td>
<td>073</td>
<td>59</td>
<td>0x3B</td>
<td>;</td>
<td>分号</td>
</tr>
<tr>
<td>0011 1100</td>
<td>074</td>
<td>60</td>
<td>0x3C</td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td>0011 1101</td>
<td>075</td>
<td>61</td>
<td>0x3D</td>
<td>=</td>
<td>等号</td>
</tr>
<tr>
<td>0011 1110</td>
<td>076</td>
<td>62</td>
<td>0x3E</td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td>0011 1111</td>
<td>077</td>
<td>63</td>
<td>0x3F</td>
<td>?</td>
<td>问号</td>
</tr>
<tr>
<td>0100 0000</td>
<td>0100</td>
<td>64</td>
<td>0x40</td>
<td>@</td>
<td>电子邮件符号</td>
</tr>
<tr>
<td>0100 0001</td>
<td>0101</td>
<td>65</td>
<td>0x41</td>
<td>A</td>
<td>大写字母A</td>
</tr>
<tr>
<td>0100 0010</td>
<td>0102</td>
<td>66</td>
<td>0x42</td>
<td>B</td>
<td>大写字母B</td>
</tr>
<tr>
<td>0100 0011</td>
<td>0103</td>
<td>67</td>
<td>0x43</td>
<td>C</td>
<td>大写字母C</td>
</tr>
<tr>
<td>0100 0100</td>
<td>0104</td>
<td>68</td>
<td>0x44</td>
<td>D</td>
<td>大写字母D</td>
</tr>
<tr>
<td>0100 0101</td>
<td>0105</td>
<td>69</td>
<td>0x45</td>
<td>E</td>
<td>大写字母E</td>
</tr>
<tr>
<td>0100 0110</td>
<td>0106</td>
<td>70</td>
<td>0x46</td>
<td>F</td>
<td>大写字母F</td>
</tr>
<tr>
<td>0100 0111</td>
<td>0107</td>
<td>71</td>
<td>0x47</td>
<td>G</td>
<td>大写字母G</td>
</tr>
<tr>
<td>0100 1000</td>
<td>0110</td>
<td>72</td>
<td>0x48</td>
<td>H</td>
<td>大写字母H</td>
</tr>
<tr>
<td>0100 1001</td>
<td>0111</td>
<td>73</td>
<td>0x49</td>
<td>I</td>
<td>大写字母I</td>
</tr>
<tr>
<td>01001010</td>
<td>0112</td>
<td>74</td>
<td>0x4A</td>
<td>J</td>
<td>大写字母J</td>
</tr>
<tr>
<td>0100 1011</td>
<td>0113</td>
<td>75</td>
<td>0x4B</td>
<td>K</td>
<td>大写字母K</td>
</tr>
<tr>
<td>0100 1100</td>
<td>0114</td>
<td>76</td>
<td>0x4C</td>
<td>L</td>
<td>大写字母L</td>
</tr>
<tr>
<td>0100 1101</td>
<td>0115</td>
<td>77</td>
<td>0x4D</td>
<td>M</td>
<td>大写字母M</td>
</tr>
<tr>
<td>0100 1110</td>
<td>0116</td>
<td>78</td>
<td>0x4E</td>
<td>N</td>
<td>大写字母N</td>
</tr>
<tr>
<td>0100 1111</td>
<td>0117</td>
<td>79</td>
<td>0x4F</td>
<td>O</td>
<td>大写字母O</td>
</tr>
<tr>
<td>0101 0000</td>
<td>0120</td>
<td>80</td>
<td>0x50</td>
<td>P</td>
<td>大写字母P</td>
</tr>
<tr>
<td>0101 0001</td>
<td>0121</td>
<td>81</td>
<td>0x51</td>
<td>Q</td>
<td>大写字母Q</td>
</tr>
<tr>
<td>0101 0010</td>
<td>0122</td>
<td>82</td>
<td>0x52</td>
<td>R</td>
<td>大写字母R</td>
</tr>
<tr>
<td>0101 0011</td>
<td>0123</td>
<td>83</td>
<td>0x53</td>
<td>S</td>
<td>大写字母S</td>
</tr>
<tr>
<td>0101 0100</td>
<td>0124</td>
<td>84</td>
<td>0x54</td>
<td>T</td>
<td>大写字母T</td>
</tr>
<tr>
<td>0101 0101</td>
<td>0125</td>
<td>85</td>
<td>0x55</td>
<td>U</td>
<td>大写字母U</td>
</tr>
<tr>
<td>0101 0110</td>
<td>0126</td>
<td>86</td>
<td>0x56</td>
<td>V</td>
<td>大写字母V</td>
</tr>
<tr>
<td>0101 0111</td>
<td>0127</td>
<td>87</td>
<td>0x57</td>
<td>W</td>
<td>大写字母W</td>
</tr>
<tr>
<td>0101 1000</td>
<td>0130</td>
<td>88</td>
<td>0x58</td>
<td>X</td>
<td>大写字母X</td>
</tr>
<tr>
<td>0101 1001</td>
<td>0131</td>
<td>89</td>
<td>0x59</td>
<td>Y</td>
<td>大写字母Y</td>
</tr>
<tr>
<td>0101 1010</td>
<td>0132</td>
<td>90</td>
<td>0x5A</td>
<td>Z</td>
<td>大写字母Z</td>
</tr>
<tr>
<td>0101 1011</td>
<td>0133</td>
<td>91</td>
<td>0x5B</td>
<td>[</td>
<td>开方括号</td>
</tr>
<tr>
<td>0101 1100</td>
<td>0134</td>
<td>92</td>
<td>0x5C</td>
<td>\</td>
<td>反斜杠</td>
</tr>
<tr>
<td>0101 1101</td>
<td>0135</td>
<td>93</td>
<td>0x5D</td>
<td>]</td>
<td>闭方括号</td>
</tr>
<tr>
<td>0101 1110</td>
<td>0136</td>
<td>94</td>
<td>0x5E</td>
<td>^</td>
<td>脱字符</td>
</tr>
<tr>
<td>0101 1111</td>
<td>0137</td>
<td>95</td>
<td>0x5F</td>
<td>_</td>
<td>下划线</td>
</tr>
<tr>
<td>0110 0000</td>
<td>0140</td>
<td>96</td>
<td>0x60</td>
<td>`</td>
<td>开单引号</td>
</tr>
<tr>
<td>0110 0001</td>
<td>0141</td>
<td>97</td>
<td>0x61</td>
<td>a</td>
<td>小写字母a</td>
</tr>
<tr>
<td>0110 0010</td>
<td>0142</td>
<td>98</td>
<td>0x62</td>
<td>b</td>
<td>小写字母b</td>
</tr>
<tr>
<td>0110 0011</td>
<td>0143</td>
<td>99</td>
<td>0x63</td>
<td>c</td>
<td>小写字母c</td>
</tr>
<tr>
<td>0110 0100</td>
<td>0144</td>
<td>100</td>
<td>0x64</td>
<td>d</td>
<td>小写字母d</td>
</tr>
<tr>
<td>0110 0101</td>
<td>0145</td>
<td>101</td>
<td>0x65</td>
<td>e</td>
<td>小写字母e</td>
</tr>
<tr>
<td>0110 0110</td>
<td>0146</td>
<td>102</td>
<td>0x66</td>
<td>f</td>
<td>小写字母f</td>
</tr>
<tr>
<td>0110 0111</td>
<td>0147</td>
<td>103</td>
<td>0x67</td>
<td>g</td>
<td>小写字母g</td>
</tr>
<tr>
<td>0110 1000</td>
<td>0150</td>
<td>104</td>
<td>0x68</td>
<td>h</td>
<td>小写字母h</td>
</tr>
<tr>
<td>0110 1001</td>
<td>0151</td>
<td>105</td>
<td>0x69</td>
<td>i</td>
<td>小写字母i</td>
</tr>
<tr>
<td>0110 1010</td>
<td>0152</td>
<td>106</td>
<td>0x6A</td>
<td>j</td>
<td>小写字母j</td>
</tr>
<tr>
<td>0110 1011</td>
<td>0153</td>
<td>107</td>
<td>0x6B</td>
<td>k</td>
<td>小写字母k</td>
</tr>
<tr>
<td>0110 1100</td>
<td>0154</td>
<td>108</td>
<td>0x6C</td>
<td>l</td>
<td>小写字母l</td>
</tr>
<tr>
<td>0110 1101</td>
<td>0155</td>
<td>109</td>
<td>0x6D</td>
<td>m</td>
<td>小写字母m</td>
</tr>
<tr>
<td>0110 1110</td>
<td>0156</td>
<td>110</td>
<td>0x6E</td>
<td>n</td>
<td>小写字母n</td>
</tr>
<tr>
<td>0110 1111</td>
<td>0157</td>
<td>111</td>
<td>0x6F</td>
<td>o</td>
<td>小写字母o</td>
</tr>
<tr>
<td>0111 0000</td>
<td>0160</td>
<td>112</td>
<td>0x70</td>
<td>p</td>
<td>小写字母p</td>
</tr>
<tr>
<td>0111 0001</td>
<td>0161</td>
<td>113</td>
<td>0x71</td>
<td>q</td>
<td>小写字母q</td>
</tr>
<tr>
<td>0111 0010</td>
<td>0162</td>
<td>114</td>
<td>0x72</td>
<td>r</td>
<td>小写字母r</td>
</tr>
<tr>
<td>0111 0011</td>
<td>0163</td>
<td>115</td>
<td>0x73</td>
<td>s</td>
<td>小写字母s</td>
</tr>
<tr>
<td>0111 0100</td>
<td>0164</td>
<td>116</td>
<td>0x74</td>
<td>t</td>
<td>小写字母t</td>
</tr>
<tr>
<td>0111 0101</td>
<td>0165</td>
<td>117</td>
<td>0x75</td>
<td>u</td>
<td>小写字母u</td>
</tr>
<tr>
<td>0111 0110</td>
<td>0166</td>
<td>118</td>
<td>0x76</td>
<td>v</td>
<td>小写字母v</td>
</tr>
<tr>
<td>0111 0111</td>
<td>0167</td>
<td>119</td>
<td>0x77</td>
<td>w</td>
<td>小写字母w</td>
</tr>
<tr>
<td>0111 1000</td>
<td>0170</td>
<td>120</td>
<td>0x78</td>
<td>x</td>
<td>小写字母x</td>
</tr>
<tr>
<td>0111 1001</td>
<td>0171</td>
<td>121</td>
<td>0x79</td>
<td>y</td>
<td>小写字母y</td>
</tr>
<tr>
<td>0111 1010</td>
<td>0172</td>
<td>122</td>
<td>0x7A</td>
<td>z</td>
<td>小写字母z</td>
</tr>
<tr>
<td>0111 1011</td>
<td>0173</td>
<td>123</td>
<td>0x7B</td>
<td>{</td>
<td>开花括号</td>
</tr>
<tr>
<td>0111 1100</td>
<td>0174</td>
<td>124</td>
<td>0x7C</td>
<td>|</td>
<td>垂线</td>
</tr>
<tr>
<td>0111 1101</td>
<td>0175</td>
<td>125</td>
<td>0x7D</td>
<td>}</td>
<td>闭花括号</td>
</tr>
<tr>
<td>0111 1110</td>
<td>0176</td>
<td>126</td>
<td>0x7E</td>
<td>~</td>
<td>波浪号</td>
</tr>
<tr>
<td>0111 1111</td>
<td>0177</td>
<td>127</td>
<td>0x7F</td>
<td>DEL (delete)</td>
<td>删除</td>
</tr>
</tbody></table>
<h2 id="C-语言的阴暗角落"><a href="#C-语言的阴暗角落" class="headerlink" title="C 语言的阴暗角落"></a>C 语言的阴暗角落</h2><h3 id="Implementation-defined、Unspecified和Undefined"><a href="#Implementation-defined、Unspecified和Undefined" class="headerlink" title="Implementation-defined、Unspecified和Undefined"></a>Implementation-defined、Unspecified和Undefined</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在 C 标准中没有做明确规定的地方会用 <span class="code">`Implementation-defined`</span>、<span class="code">`Unspecified`</span> 或 <span class="code">`Undefined`</span> 来表述，在本书中有时把这三种情况统称为“未明确定义”的。这三种情况到底有什么不同呢？</span><br><span class="line"></span><br><span class="line">我们刚才看到一种 Implementation-defined 的情况，C 标准没有明确规定 <span class="code">`char`</span> 是有符号的还是无符号的，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。</span><br><span class="line"></span><br><span class="line">而对于 Unspecified 的情况，往往有几种可选的处理方式，C 标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即使用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式，比如下一章我们会讲到一个函数调用的各个实参表达式按什么顺序求值是 Unspecified 的。</span><br><span class="line"></span><br><span class="line">Undefined 的情况则是完全不确定的，C 标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，有很多Undefined 的情况是编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是 Undefined 的。</span><br><span class="line"></span><br><span class="line">初学者看到这些规则通常会很不舒服，觉得这不是在学编程而是在啃法律条文，结果越学越泄气。是的，C 语言并不像一个数学定理那样完美，现实世界里的东西总是不够完美的。但还好啦，C 程序员已经很幸福了，只要严格遵照C标准来写代码，不要去触碰那些阴暗角落，写出来的代码就有很好的可移植性。想想那些可怜的 JavaScript 程序员吧，他们甚至连一个可以遵照的标准都没有，一个浏览器一个样，因而不得不为每一种浏览器的每一个版本分别写不同的代码。</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch15s01.html">参考</a></p>
<h3 id="Side-Effect与Sequence-Point"><a href="#Side-Effect与Sequence-Point" class="headerlink" title="Side Effect与Sequence Point"></a>Side Effect与Sequence Point</h3><p><a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch16s03.html">参考</a></p>
<h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><blockquote>
<p>把一个预处理指示写成多行要用<code>\</code>续行，因为根据定义，一条预处理指示只能由一个逻辑代码行组成，而把C代码写成多行则不需要用<code>\</code>续行，因为换行在C代码中只不过是一种空白字符，在做语法解析时所有空白字符都已经丢掉了。</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://akaedu.github.io/book/ch21s01.html">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dlf1769/article/details/78553921">参考2</a></p>
<h2 id="变量和数据类型"><a href="#变量和数据类型" class="headerlink" title="变量和数据类型"></a>变量和数据类型</h2><h3 id="不同数据类型占用的内存字节"><a href="#不同数据类型占用的内存字节" class="headerlink" title="不同数据类型占用的内存字节"></a>不同数据类型占用的内存字节</h3><ul>
<li><p>整数</p>
<table>
<thead>
<tr>
<th>操作系统</th>
<th>short</th>
<th>int</th>
<th>long</th>
</tr>
</thead>
<tbody><tr>
<td>Win64（64位 Windows）</td>
<td>2</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>类Unix系统（包括 Unix、Linux、Mac OS、BSD、Solaris 等）</td>
<td>2</td>
<td>4</td>
<td>8</td>
</tr>
</tbody></table>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体可以用 <span class="selector-tag">sizeof</span> 操作符查看</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用这个程序查看</span></span><br><span class="line">$ cat sizeof.c</span><br><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    short a = 10;</span><br><span class="line">    int b = 100;</span><br><span class="line"></span><br><span class="line">    int short_length = sizeof a;</span><br><span class="line">    int int_length = sizeof(b);</span><br><span class="line">    int long_length = sizeof(long);</span><br><span class="line">    int char_length = sizeof(char);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;short=%d, int=%d, long=%d, char=%d\n&quot;</span>, short_length, int_length, long_length, char_length);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>小数 (这个是固定的，不像整数在不同系统中长度不同)</p>
<ul>
<li>float  <strong>4</strong>个字节</li>
<li>double  <strong>8</strong>个字节</li>
</ul>
</li>
</ul>
<h3 id="不同进制表示"><a href="#不同进制表示" class="headerlink" title="不同进制表示"></a>不同进制表示</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">二进制：以0<span class="selector-tag">b</span>开头</span><br><span class="line">八进制：以0开关</span><br><span class="line">十进制：正常书写</span><br><span class="line">十六进制：以0<span class="selector-tag">x</span>开关</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">note</span>：0<span class="selector-tag">b</span>和0<span class="selector-tag">x</span>也可以用0<span class="selector-tag">B</span>和0<span class="selector-tag">X</span>代替，但是推荐不要用，容易混淆</span><br></pre></td></tr></table></figure>

<h3 id="不同进制的格式化输出"><a href="#不同进制的格式化输出" class="headerlink" title="不同进制的格式化输出"></a>不同进制的格式化输出</h3><ol>
<li><p>输出时没有前缀</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">short</th>
<th align="center">int</th>
<th align="center">long</th>
</tr>
</thead>
<tbody><tr>
<td align="center">八进制(无符号)</td>
<td align="center">%ho</td>
<td align="center">%o</td>
<td align="center">%lo</td>
</tr>
<tr>
<td align="center">十进制(无符号)</td>
<td align="center">%hu</td>
<td align="center">%u</td>
<td align="center">%lu</td>
</tr>
<tr>
<td align="center">十进制(有符号)</td>
<td align="center">%hd</td>
<td align="center">%d</td>
<td align="center">%ld</td>
</tr>
<tr>
<td align="center">十六进制(小写，无符号)</td>
<td align="center">%hx</td>
<td align="center">%x</td>
<td align="center">%lx</td>
</tr>
<tr>
<td align="center">十六进制(大写，无符号)</td>
<td align="center">%hX</td>
<td align="center">%X</td>
<td align="center">%lX</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="2">
<li><p>输出时有前缀</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在格式控制符中加上 # 即可输出前缀</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">short</th>
<th align="center">int</th>
<th align="center">long</th>
</tr>
</thead>
<tbody><tr>
<td align="center">八进制</td>
<td align="center">%#ho</td>
<td align="center">%#o</td>
<td align="center">%#lo</td>
</tr>
<tr>
<td align="center">十六进制(小写)</td>
<td align="center">%#hx</td>
<td align="center">%#x</td>
<td align="center">%#lx</td>
</tr>
<tr>
<td align="center">十六进制(大写)</td>
<td align="center">%#hX</td>
<td align="center">%#X</td>
<td align="center">%#lX</td>
</tr>
</tbody></table>
</li>
</ol>
<ol start="3">
<li><p>总结</p>
<ul>
<li>%d 以十进制形式输出有符号数；</li>
<li>%u 以十进制形式输出无符号数；</li>
<li>%o 以八进制形式输出无符号数；</li>
<li>%x 以十六进制形式输出无符号数；</li>
<li>%h 对应 short；</li>
<li>%l 对应 long。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">printf</span> 不支持以八进制和十六进制形式输出有符号数，一般也没有这个需求。</span><br><span class="line">但是！</span><br><span class="line">用 %<span class="selector-tag">o</span> 和 %<span class="selector-tag">x</span> 输出有符号的正数，没有问题，输出有符号的负数，就会出错。</span><br><span class="line">注意，有符号数以无符号的形式输出，或者无符号数以有符号的形式输出，都有可以会出错，这涉及到不同的数原码和补码转换关系不一样。</span><br><span class="line">所以，尽量用对格式化输出，除了用 %<span class="selector-tag">o</span> 和 %<span class="selector-tag">x</span> 输出有符号的正数，这个没办法。</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="printf-格式化输出符号"><a href="#printf-格式化输出符号" class="headerlink" title="printf 格式化输出符号"></a>printf 格式化输出符号</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/xiexievv/article/details/6831194">参考</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">%a  浮点数、十六进制数字和p-记数法（c99</span><br><span class="line">%A  浮点数、十六进制数字和p-记法（c99）</span><br><span class="line">%c  一个字符(char)</span><br><span class="line">%C  一个ISO宽字符</span><br><span class="line">%d  有符号十进制整数(int)（%ld、%Ld：长整型数据(long),%hd：输出短整形。）　</span><br><span class="line">%e  浮点数、e-记数法</span><br><span class="line">%E  浮点数、E-记数法</span><br><span class="line">%f  单精度浮点数(默认float)、十进制记数法（%.nf  这里n表示精确到小数位后n位.十进制计数）</span><br><span class="line">%g  根据数值不同自动选择%f或%e．</span><br><span class="line">%G  根据数值不同自动选择%f或%e.</span><br><span class="line">%i  有符号十进制数（与%d相同）</span><br><span class="line">%o  无符号八进制整数</span><br><span class="line">%p  指针</span><br><span class="line">%s  对应字符串char*（%s &#x3D; %hs &#x3D; %hS 输出 窄字符）</span><br><span class="line">%S  对应宽字符串WCAHR*（%ws &#x3D; %S 输出宽字符串）</span><br><span class="line">%u  无符号十进制整数(unsigned int)</span><br><span class="line">%x  使用十六进制数字0xf的无符号十六进制整数　</span><br><span class="line">%X  使用十六进制数字0xf的无符号十六进制整数</span><br><span class="line">%%  打印一个百分号</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">%I64d 用于INT64 或者 long long</span><br><span class="line">%I64u 用于UINT64 或者 unsigned long long</span><br><span class="line">%I64x 用于64位16进制数据</span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%m.n : m指域宽，即对应的输出项在输出设备上所占的字符数。n指精度。用于说明输出的实型数的小数位数。为指定n时，隐含的精度为n&#x3D;6位。</span><br><span class="line"></span><br><span class="line">l 对整型指long型，对实型指double型。h用于将整型的格式字符修正为short型。</span><br></pre></td></tr></table></figure>





<h3 id="整数在内存中的存储"><a href="#整数在内存中的存储" class="headerlink" title="整数在内存中的存储"></a>整数在内存中的存储</h3><ol>
<li><p>正数 或者 无符号数</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正数直接把它的二进制形式存储在内存中，即正数的原码、反码、补码相同</span><br></pre></td></tr></table></figure>
</li>
<li><p>负数</p>
<ul>
<li><p>原码</p>
<p>负数的二进制形式，如 1000 0000 0001 0010</p>
</li>
<li><p>反码</p>
<p>除符号位(第一位为1)，其他位取反，如 1111 1111 1110 1101</p>
</li>
<li><p><strong>补码</strong></p>
<p>反码+1，如 1111 1111 1110 1110</p>
</li>
</ul>
</li>
<li><p>在计算机内存中，整数一律采用 <strong>补码</strong> 的形式来存储。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设计补码的目的，是为了让计算机能够在运算的过程，用加法的形式来计算减法，将加减运算统一为加法运算。</span><br><span class="line">一开始考虑的是用反码来算，但是发现一个问题，即，较小的数减去较大的数，没有问题，但是反过来，大数减小数就会少1。为了补上这个每次都会出现的误差，设计了补码。</span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意，<span class="selector-attr">[1000 0000 …… 0000 0000]</span>补 是一个特殊的补码，无法按照计算方法转换为原码(但是却可以用原码推出补码)，所以计算机直接规定这个补码对应的值就是 <span class="selector-tag">-2</span>的31次方（最大的负数）</span><br><span class="line"><span class="selector-attr">[0000 0000 …… 0000 0000]</span>自然是0了</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h3 id="整数取值范围以及数值溢出"><a href="#整数取值范围以及数值溢出" class="headerlink" title="整数取值范围以及数值溢出"></a>整数取值范围以及数值溢出</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设一个数据类型有<span class="selector-tag">n</span>个字节，4<span class="selector-tag">n</span>位(<span class="selector-tag">bit</span>)，那么它的容量是2的4<span class="selector-tag">n</span>次方</span><br><span class="line">无符号数的取值范围，0 ～ <span class="selector-attr">[ 2^(4n) ]</span><span class="selector-tag">-1</span></span><br><span class="line">有符号数的取值范围，<span class="selector-tag">-</span><span class="selector-attr">[ 2^(4n-1) ]</span> ～ <span class="selector-attr">[ 2^(4n-1) ]</span><span class="selector-tag">-1</span>，如 <span class="selector-tag">-128</span> ～ 127</span><br></pre></td></tr></table></figure>



<h3 id="小数的格式化输出"><a href="#小数的格式化输出" class="headerlink" title="小数的格式化输出"></a>小数的格式化输出</h3><ul>
<li>%f 以十进制形式输出 float 类型；</li>
<li>%lf 以十进制形式输出 double 类型；</li>
<li>%e 以指数形式输出 float 类型，输出结果中的 e 小写；</li>
<li>%E 以指数形式输出 float 类型，输出结果中的 E 大写；</li>
<li>%le 以指数形式输出 double 类型，输出结果中的 e 小写；</li>
<li>%lE 以指数形式输出 double 类型，输出结果中的 E 大写。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">很多简单的小数压根不能精确存储，所以也不能精确输出</span><br><span class="line">%<span class="selector-tag">f</span> 和 %<span class="selector-tag">lf</span> 默认保留六位小数，不足六位以 0 补齐，超过六位按四舍五入截断。</span><br><span class="line">将整数赋值给 <span class="selector-tag">float</span> 变量时会变成小数。</span><br><span class="line">以指数形式输出小数时，输出结果为科学计数法；也就是说，尾数部分的取值为：0 ≤ 尾数 &lt; 10。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>小数还有一种更加智能的输出方式，就是使用<code>%g</code>。</p>
<p>%g 会对比小数的十进制形式和指数形式，以最短的方式来输出小数，让输出结果更加简练。</p>
<p>所谓最短，就是输出结果占用最少的字符。</p>
</blockquote>
<ul>
<li><p>%g 默认最多保留六位有效数字，包括整数部分和小数部分；%f 和 %e 默认保留六位小数，只包括小数部分。</p>
<p>%g 不会在最后强加 0 来凑够有效数字的位数，而 %f 和 %e 会在最后强加 0 来凑够小数部分的位数。</p>
</li>
<li><p>%g 和 %lg 分别用来输出 float 类型和 double 类型，并且当以指数形式输出时，<code>e</code>小写。</p>
</li>
<li><p>%G 和 %lG 也分别用来输出 float 类型和 double 类型，只是当以指数形式输出时，<code>E</code>大写。</p>
</li>
</ul>
<h3 id="数字的后缀"><a href="#数字的后缀" class="headerlink" title="数字的后缀"></a>数字的后缀</h3><blockquote>
<p>一个数字，是有默认类型的：对于整数，默认是 int 类型；对于小数，默认是 double 类型。</p>
<p>如果不想让数字使用默认的类型，那么可以给数字加上后缀，手动指明类型： </p>
<ul>
<li>在整数后面紧跟 l 或者 L（不区分大小写）表明该数字是 long 类型；</li>
<li>在小数后面紧跟 f 或者 F（不区分大小写）表明该数字是 float 类型。</li>
</ul>
</blockquote>
<h3 id="除法注意事项"><a href="#除法注意事项" class="headerlink" title="除法注意事项"></a>除法注意事项</h3><blockquote>
<ul>
<li>当除数和被除数都是整数时，运算结果也是整数；如果不能整除，那么就直接丢掉小数部分，只保留整数部分，这跟将小数赋值给整数类型是一个道理。</li>
<li>一旦除数和被除数中有一个是小数，那么运算结果也是小数，并且是 double 类型的小数。</li>
<li>除数不能为0，这一点编译器不会报错，注意。运行时出现 Floating point exception (core dumped)</li>
</ul>
</blockquote>
<h3 id="对取余运算的说明"><a href="#对取余运算的说明" class="headerlink" title="对取余运算的说明"></a>对取余运算的说明</h3><blockquote>
<p>C语言中的取余运算只能针对整数，也就是说，% 的两边都必须是整数，不能出现小数，否则编译器会报错。</p>
<p>另外，余数可以是正数也可以是负数，由 % 左边的整数决定： </p>
<ul>
<li>如果 % 左边是正数，那么余数也是正数；</li>
<li>如果 % 左边是负数，那么余数也是负数。</li>
</ul>
</blockquote>
<h3 id="自增-和自减-–"><a href="#自增-和自减-–" class="headerlink" title="自增(++)和自减(–)"></a>自增(++)和自减(–)</h3><p>++a 和 a++ 优先级不同</p>
<blockquote>
<ul>
<li><del>++a 加加在前面叫做前自增。前自增先进行自增运算，再进行其他操作。</del></li>
<li><del>a++ 加加在后面叫做后自增。后自增先进行其他操作，再进行自增运算。</del></li>
</ul>
</blockquote>
<p><del>例子详见<a target="_blank" rel="noopener" href="http://c.biancheng.net/view/1772.html">C语言自增(++)和自减(–)</a></del></p>
<p>上面的解释不对。。没法解释这个：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    int b = 5;</span><br><span class="line">    a = a++;</span><br><span class="line">    b = ++b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a); //a == 5</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b = %d\n&quot;</span>, b); //b == 6</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>这个[答案][<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/24853/c-what-is-the-difference-between-i-and-i]%E5%BA%94%E8%AF%A5%E6%98%AF%E5%AF%B9%E7%9A%84%EF%BC%9A">https://stackoverflow.com/questions/24853/c-what-is-the-difference-between-i-and-i]应该是对的：</a></p>
<ul>
<li><p><code>++i</code> will increment the value of <code>i</code>, and then return the incremented value.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = ++i;</span><br><span class="line">(i is <span class="number">2</span>, j is <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>i++</code> will increment the value of <code>i</code>, but return the original value that <code>i</code> held before being incremented.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span>;</span><br><span class="line">j = i++;</span><br><span class="line">(i is <span class="number">2</span>, j is <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>另外，如果单独写一行，<code>++i;</code> <strong>可能</strong>比 <code>i++;</code> 稍微快一点点，因为 <code>i++</code> 需要另外找个地方保存没自增之前的值。说“可能”，是因为如果编译器优化，两者应该是一样的。</p>
<p><a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch06s03.html#iter.for">这里</a>也有解释：</p>
<blockquote>
<p>其中<code>++i</code>这个表达式相当于<code>i += 1</code>，++称为<strong>前缀自增运算符</strong>（<strong>Prefix Increment Operator</strong>），类似地，–称为前缀自减运算符（Prefix Decrement Operator），<code>--i</code>相当于<code>i = i - 1</code>[<a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch06s03.html#ftn.id2979059">11</a>]。如果把<code>++i</code>这个表达式看作一个函数调用，除了传入一个参数返回一个值（等于参数值加1）之外，还产生一个Side Effect，就是把变量<code>i</code>的值增加了1。</p>
<p><code>++</code>和<code>--</code>运算符也可以用在变量后面，例如<code>i++</code>和<code>i--</code>，为了和前缀运算符区别，称为<strong>后缀自增运算符</strong>（<strong>Postfix Increment Operator</strong>）和后缀自减运算符（Postfix Decrement Operator）。如果把<code>i++</code>这个表达式看作一个函数调用，除了传入一个参数返回一个值（就等于参数值）之外，还产生一个Side Effect，就是把变量<code>i</code>的值增加了1，它和<code>++i</code>的区别就在于<strong>返回值不同</strong>。同理，<code>--i</code>返回减1之后的值，而<code>i--</code>返回减1之前的值，但这两个表达式都产生同样的Side Effect，就是把变量<code>i</code>的值减了1。</p>
</blockquote>
<blockquote>
<p><code>a += 1</code>相当于<code>a = a + 1</code>。但有一点细微的区别，前者对表达式<code>a</code><strong>只求值一次</strong>，而后者<strong>求值两次</strong>，如果<code>a</code>是一个复杂的表达式，求值一次和求值两次的效率是不同的，例如<code>a[i+j] += 1</code>和<code>a[i+j] = a[i+j] + 1</code>。仅仅是效率上的差别吗？对于没有Side Effect的表达式，求值一次和求值两次的结果是一样的，但对于有Side Effect的表达式则不一定，例如<code>a[foo()] += 1</code>和<code>a[foo()] = a[foo()] + 1</code>，如果<code>foo()</code>函数调用有Side Effect，比如会打印一条消息，那么前者只打印一次，而后者打印两次。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>, c = <span class="number">30</span>, d = <span class="number">40</span>;</span><br><span class="line">    <span class="keyword">int</span> a1 = ++a, b1 = b++, c1 = --c, d1 = d--;</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d, a1=%d\n&quot;</span>, a, a1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;b=%d, b1=%d\n&quot;</span>, b, b1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c=%d, c1=%d\n&quot;</span>, c, c1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;d=%d, d1=%d\n&quot;</span>, d, d1);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ c12</span><br><span class="line">a=11, a1=11</span><br><span class="line">b=21, b1=20</span><br><span class="line">c=29, c1=29</span><br><span class="line">d=39, d1=40</span><br></pre></td></tr></table></figure>



<p>指针的自增详见<a href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89">数组指针</a></p>
<h3 id="变量的定义位置以及初始值"><a href="#变量的定义位置以及初始值" class="headerlink" title="变量的定义位置以及初始值"></a>变量的定义位置以及初始值</h3><ol>
<li><p>全局变量：在函数外面定义，注意，main函数也是函数</p>
<p>它的默认初始值始终是 0，因为全局变量存储在内存分区中的全局数据区，这个区域中的数据在程序载入内存后会被初始化为 0。</p>
</li>
<li><p>局部变量：在函数内部定义，注意，main函数里面定义的也是局部变量</p>
<p>不同的编译器对局部变量的处理差异很大，有的初始化为0，有的根本不管。</p>
<p>所以，要注意声明变量时要对局部变量<strong>初始化</strong></p>
</li>
</ol>
<h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><h4 id="自动数据类型转换"><a href="#自动数据类型转换" class="headerlink" title="自动数据类型转换"></a>自动数据类型转换</h4><blockquote>
<p>在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下： </p>
<ul>
<li>转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。</li>
<li>所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。</li>
<li>char 和 short 参与运算时，必须先转换成 int 类型。</li>
</ul>
</blockquote>
<h4 id="强制数据类型转换"><a href="#强制数据类型转换" class="headerlink" title="强制数据类型转换"></a>强制数据类型转换</h4><blockquote>
<p>格式：</p>
<ul>
<li>(int)(x+y);</li>
</ul>
</blockquote>
<p><strong>note</strong>：</p>
<blockquote>
<p>无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。</p>
</blockquote>
<h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><blockquote>
<p>在C语言中，有三个函数可以用来在显示器上输出数据，它们分别是： </p>
<ul>
<li>puts()：只能输出字符串，并且输出结束后会自动换行。</li>
<li>putchar()：只能输出单个字符。</li>
<li>printf()：可以输出各种类型的数据。</li>
</ul>
</blockquote>
<p>printf() 可以代替其它</p>
<blockquote>
<p>在C语言中，有多个函数可以从键盘获得用户输入：</p>
<ul>
<li>scanf()：和 printf() 类似，scanf() 可以输入多种类型的数据。</li>
<li>getchar()、getche()、getch()：这三个函数都用于输入单个字符。</li>
<li>gets()：获取一行数据，并作为字符串处理。</li>
</ul>
</blockquote>
<p>scanf() 不能代替其它</p>
<p>scanf() 以空格为分隔，不能输入带有空格的字符串，可以用 <strong>gets()</strong> 输入带有空格的字符串。</p>
<p>但是 gets() 现在已经不被支持了，不信你自己去看 man gets ，所以用 <strong>fgets()</strong> 代替。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//gets( bufSend ); //读取一行数据,这个太危险，已经不让用了</span></span><br><span class="line">fgets( bufSend, BUF_SIZE, <span class="built_in">stdin</span> ); <span class="comment">//读取一行数据</span></span><br></pre></td></tr></table></figure>





<h3 id="printf-格式控制符"><a href="#printf-格式控制符" class="headerlink" title="printf 格式控制符"></a><em>printf</em> 格式控制符</h3><table>
<thead>
<tr>
<th>格式控制符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>输出一个单一的字符</td>
</tr>
<tr>
<td>%hd、%d、%ld</td>
<td>以十进制、有符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%hu、%u、%lu</td>
<td>以十进制、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%ho、%o、%lo</td>
<td>以八进制、不带前缀、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%#ho、%#o、%#lo</td>
<td>以八进制、带前缀、无符号的形式输出 short、int、long 类型的整数</td>
</tr>
<tr>
<td>%hx、%x、%lx  %hX、%X、%lX</td>
<td>以十六进制、不带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字也小写；如果 X 大写，那么输出的十六进制数字也大写。</td>
</tr>
<tr>
<td>%#hx、%#x、%#lx  %#hX、%#X、%#lX</td>
<td>以十六进制、带前缀、无符号的形式输出 short、int、long 类型的整数。如果 x 小写，那么输出的十六进制数字和前缀都小写；如果 X 大写，那么输出的十六进制数字和前缀都大写。</td>
</tr>
<tr>
<td>%f、%lf</td>
<td>以十进制的形式输出 float、double 类型的小数</td>
</tr>
<tr>
<td>%e、%le  %E、%lE</td>
<td>以指数的形式输出 float、double 类型的小数。如果 e 小写，那么输出结果中的 e 也小写；如果 E 大写，那么输出结果中的 E 也大写。</td>
</tr>
<tr>
<td>%g、%lg  %G、%lG</td>
<td>以十进制和指数中较短的形式输出 float、double 类型的小数，并且小数部分的最后不会添加多余的 0。如果 g 小写，那么当以指数形式输出时 e 也小写；如果 G 大写，那么当以指数形式输出时 E 也大写。</td>
</tr>
<tr>
<td>%s</td>
<td>输出一个字符串</td>
</tr>
<tr>
<td>%p %P</td>
<td><code>%p</code>是一个新的格式控制符，它表示以十六进制的形式（带小写的前缀）输出数据的地址。如果写作<code>%P</code>，那么十六进制的前缀也将变成大写形式。</td>
</tr>
</tbody></table>
<p>format string 由 ordinary characters 和 conversion specifications 组成。</p>
<p>conversion specification 总是从 % 开始，以 conversion  specifier 结束，中间可能包含零或多个 flags，一个field width，一个 precision，和一个 length modifier。</p>
<p>printf() 格式控制符的完整形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[flag][width][.precision]type</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><p><code>type</code> 表示输出类型，比如 %d、%f、%c、%lf，type 就分别对应 d、f、c、lf；再如，<code>%-9d</code>中 type 对应 d。</p>
<p>type 这一项必须有，这意味着输出时必须要知道是什么类型。</p>
</li>
<li><p><code>width</code> 表示最小输出宽度，也就是至少占用几个字符的位置；例如，<code>%-9d</code>中 width 对应 9，表示输出结果最少占用 9 个字符的宽度。</p>
<p>当输出结果的宽度不足 width 时，以空格补齐（如果没有指定对齐方式，默认会在左边补齐空格）；</p>
<p>当输出结果的宽度超过 width 时，width 不再起作用，按照数据本身的宽度来输出。</p>
</li>
<li><p><code>.precision</code> 表示输出精度，也就是小数的位数。 </p>
<ul>
<li><p>当小数部分的位数大于 precision 时，会按照四舍五入的原则丢掉多余的数字；</p>
</li>
<li><p>当小数部分的位数小于 precision 时，会在后面补 0。</p>
<p>另外，<code>.precision</code> 也可以用于整数和字符串，但是功能却是相反的： </p>
</li>
<li><p>用于整数时，<code>.precision</code> 表示最小输出宽度。与 width 不同的是，整数的宽度不足时会在左边补 0，而不是补空格。</p>
</li>
<li><p>用于字符串时，<code>.precision</code> 表示最大输出宽度，或者说截取字符串。当字符串的长度大于 precision 时，会截掉多余的字符；当字符串的长度小于 precision 时，<code>.precision</code> 就不再起作用。</p>
</li>
</ul>
</li>
<li><p>flag 是标志字符。例如，<code>%#x</code>中 flag 对应 #，<code>%-9d</code>中 flags 对应<code>-</code>。下表列出了 printf() 可以用的 flag：</p>
<table>
<thead>
<tr>
<th align="center">标志字符</th>
<th align="left">含  义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-</td>
<td align="left"><code>-</code>表示左对齐。如果没有，就按照默认的对齐方式，默认一般为右对齐。</td>
</tr>
<tr>
<td align="center">+</td>
<td align="left">用于整数或者小数，表示输出符号（正负号）。如果没有，那么只有负数才会输出符号。</td>
</tr>
<tr>
<td align="center">空格</td>
<td align="left">用于整数或者小数，输出值为正时冠以空格，为负时冠以负号。</td>
</tr>
<tr>
<td align="center">#</td>
<td align="left">对于八进制（%o）和十六进制（%x / %X）整数，# 表示在输出时添加前缀；八进制的前缀是 0，十六进制的前缀是 0x / 0X。  对于小数（%f / %e / %g），# 表示强迫输出小数点。如果没有小数部分，默认是不输出小数点的，加上 # 以后，即使没有小数部分也会带上小数点。</td>
</tr>
</tbody></table>
</li>
</ol>
</blockquote>
<h2 id="循环结构和选择结构"><a href="#循环结构和选择结构" class="headerlink" title="循环结构和选择结构"></a>循环结构和选择结构</h2><h3 id="break-跳出循环"><a href="#break-跳出循环" class="headerlink" title="break 跳出循环"></a><em>break</em> 跳出循环</h3><blockquote>
<p>break 可以用于 switch 和 循环语句</p>
<p>在多层循环中，一个 break 语句只向外跳一层。</p>
</blockquote>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串分两种，一种是字符数组，一种是字符常量。</p>
<p>字符数组基本上和数组一样，除了 <code>\0</code> 的问题</p>
<h3 id="对字符串取地址"><a href="#对字符串取地址" class="headerlink" title="对字符串取地址"></a>对字符串取地址</h3><p>其实我一直纠结 <code>scanf</code> 函数里 <code>%s</code> 对应的字符串要不要取地址。先说结论，<strong>不要</strong>，但是加了也没事（很奇怪呀，不能理解，可能 <code>scanf</code> 的作者作了特殊处理？）</p>
<p>两者数值相同，但是类型不同，体现在地址加 1 的值不同。<code>&amp;str+1</code> 是 <code>str</code> 的值加 <code>sizeof(str)</code> （所以说包括 \0）</p>
<h3 id="0-结束符"><a href="#0-结束符" class="headerlink" title="\0 结束符"></a><strong><em>\0</em></strong> 结束符</h3><p>字符串本质上就是字符数组，但是需要在结尾加上<code>\0</code>表示结束。</p>
<ul>
<li><p>由<code>&quot; &quot;</code>包围的字符串会自动在末尾添加<code>&#39;\0&#39;</code>。例如，<code>&quot;abc123&quot;</code>从表面看起来只包含了 6 个字符，其实不然，C语言会在最后隐式地添加一个<code>&#39;\0&#39;</code>。</p>
</li>
<li><p>逐个字符地给数组赋值并不会自动添加<code>&#39;\0&#39;</code>，所以如果这样使用并不能正确输出字体串，例如，</p>
<p><code>char str[] = &#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;</code> 输出的却是：</p>
<blockquote>
<p>abcpq~i</p>
</blockquote>
</li>
<li><p>所以逐个字符地为数组赋值时，不要忘记在字符串结束加上标志<code>&#39;\0&#39;</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str[i] = <span class="number">0</span>;  <span class="comment">// 也可以写作 str[i] = &#x27;\0&#x27;; 根据 ASCII 码表，字符&#x27;\0&#x27;的编码值就是 0。</span></span><br></pre></td></tr></table></figure>

<p>或者一开始就对 字符数组(字符串) 初始化为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">30</span>] = &#123;<span class="number">0</span>&#125;;  <span class="comment">//将所有元素都初始化为 0，或者说 &#x27;\0&#x27;</span></span><br></pre></td></tr></table></figure>




</li>
</ul>
<h3 id="赋值与修改"><a href="#赋值与修改" class="headerlink" title="赋值与修改"></a>赋值与修改</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/2921.html">参考</a></p>
<p>没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串。所以字符数组就是字符串。</p>
<ol>
<li><p>赋值</p>
<p>可以整体赋值，也可以一个一个赋值。</p>
<ul>
<li><pre><code class="c">char str[30] = &#123;&quot;c.biancheng.net&quot;&#125;;
char str[30] = &quot;c.biancheng.net&quot;;  //这种形式更加简洁，实际开发中常用
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- &#96;&#96;&#96;c</span><br><span class="line">  char str[] &#x3D; &#123;&quot;c.biancheng.net&quot;&#125;;</span><br><span class="line">  char str[] &#x3D; &quot;c.biancheng.net&quot;;  &#x2F;&#x2F;或者不指定长度</span><br></pre></td></tr></table></figure></code></pre>
</li>
<li><p>单独赋值，要记得在最后加 \0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char c[20]=&#123;&#x27;c&#x27;, &#x27;  &#x27;, &#x27;p&#x27;, &#x27;r&#x27;, &#x27;o&#x27;, &#x27;g&#x27;, &#x27;r&#x27;, &#x27;a&#x27;,&#x27;\0&#x27;&#125;;  // 给部分数组元素赋值</span><br><span class="line"><span class="keyword">char</span> d[]=&#123;<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27; &#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;  <span class="comment">//对全体元素赋值时可以省去长度</span></span><br></pre></td></tr></table></figure>

<p>或者一开始全部赋值为0，<code>char str[30] = &#123;0&#125;;</code></p>
</li>
</ul>
</li>
<li><p>修改</p>
<p>只有一开始才可以整体赋值，后面只能一个一个修改。</p>
<ul>
<li><pre><code class="c">str[i] = 0;    //或者
str[i] = &#39;\0&#39;;
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   - 注意 &#96;char *a&#x3D;&quot;abcdef&quot;&#96; 与 &#96;char a[]&#x3D;&quot;abcdef&quot;&#96; 的区别：</span><br><span class="line"></span><br><span class="line">     1、字符串存放的内存区域不同：前者存放在常量区，不可修改，后则存放在栈中，可以修改；</span><br><span class="line"></span><br><span class="line">     2、变量 a 存放的内容不同：前者存放的是一个地址，而后者存放的是字符串 &quot;abcdef&quot; ，因此使用 sizeof 它们的结果是不同的，分别是 4 和 7 ；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 字符串长度</span><br><span class="line"></span><br><span class="line">字符串长度，就是字符串包含了多少个字符（不包括最后的结束符&#96;&#39;\0&#39;&#96;）。例如&#96;&quot;abc&quot;&#96;的长度是 3，而不是 4。</span><br><span class="line">在C语言中，我们使用&#96;string.h&#96;头文件中的 strlen() 函数来求字符串的长度，它的用法为：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">long length &#x3D; strlen(str);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
</li>
</ol>
<h3 id="sizeof-和-strlen"><a href="#sizeof-和-strlen" class="headerlink" title="sizeof 和 strlen"></a>sizeof 和 strlen</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">20</span>]=<span class="string">&quot;0123456789&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">strlen</span>(str); <span class="comment">//a=10; &gt;&gt;&gt;&gt; strlen 计算字符串的长度，以结束符 0x00 为字符串结束。</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="keyword">sizeof</span>(str); <span class="comment">//而b=20; &gt;&gt;&gt;&gt; sizeof 计算的则是分配的数组 str[20] 所占的内存空间的大小，不受里面存储的内容改变。</span></span><br></pre></td></tr></table></figure>

<h3 id="多维数组的赋值"><a href="#多维数组的赋值" class="headerlink" title="多维数组的赋值"></a>多维数组的赋值</h3><p>多维数组也可以像嵌套结构体一样，用嵌套Initializer初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[][<span class="number">2</span>] = &#123; &#123; <span class="number">1</span>, <span class="number">2</span> &#125;,</span><br><span class="line">		&#123; <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">		&#123; <span class="number">5</span>, &#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>注意，除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度。</p>
<h3 id="数组越界-访问"><a href="#数组越界-访问" class="headerlink" title="数组越界 - 访问"></a>数组越界 - 访问</h3><ul>
<li><p>C语言数组是静态的，不能自动扩容，当下标小于零或大于等于数组长度时，就发生了越界（<em>Out Of Bounds</em>），访问到数组以外的内存。</p>
</li>
<li><p>编译器并不会报错，极难检查。</p>
</li>
<li><p>发生数组越界时，如果我们对该内存有使用权限，那么程序将正常运行，但会出现不可控的结果；</p>
</li>
<li><p>如果我们对该内存没有使用权限，或者该内存压根就没有被分配，那么程序将会崩溃。</p>
</li>
</ul>
<h3 id="数组溢出-赋值"><a href="#数组溢出-赋值" class="headerlink" title="数组溢出 - 赋值"></a>数组溢出 - 赋值</h3><ul>
<li><p>当赋予数组的元素个数超过数组长度时，就会发生溢出（<em>Overflow</em>）。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般情况下数组溢出不会有什么问题，顶多是丢失多余的元素。</p>
</li>
<li><p>但是当以字符串的形式输出 <strong>字符数组(字符串)</strong> 时，就会产生不可控的情况。</p>
<blockquote>
<p>因为丢了<code>\0</code>呀</p>
</blockquote>
</li>
</ul>
<h3 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h3><blockquote>
<p>下面的是错的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[n];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要修改下顺序才可以</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">int</span> arr[n];</span><br></pre></td></tr></table></figure>

<p>这个我用了，但是编译没通过。。</p>
<p>还是用动态数组吧。</p>
<h3 id="输入不定长字符串"><a href="#输入不定长字符串" class="headerlink" title="输入不定长字符串"></a>输入不定长字符串</h3><p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/314401/how-to-read-a-line-from-the-console-in-c">参考</a></p>
<p>要注意的是，赞数最多的那个答案得到的字符串在最后有一个换行符，要记得去掉。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="return"><a href="#return" class="headerlink" title="return"></a><em>return</em></h3><ul>
<li>函数一旦遇到 return 语句就立即返回，后面的所有语句都不会被执行到了。</li>
<li>return 后面可以跟一份数据，表示将这份数据返回到函数外面；</li>
<li>return 后面也可以不跟任何数据，表示什么也不返回，仅仅用来结束函数。比如，void函数可以用 <strong>return</strong> 结束。</li>
</ul>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><ul>
<li>C语言代码由上到下依次执行，原则上函数定义要出现在函数调用之前，否则就会报错。但在实际开发中，经常会在函数定义之前使用它们，这个时候就需要提前声明。</li>
<li>所谓声明（<em>Declaration</em>），就是告诉编译器我要使用这个函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。</li>
</ul>
<blockquote>
<p>函数声明的格式非常简单，相当于去掉函数定义中的函数体，并在最后加上分号<code>;</code></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dataType  <span class="title">functionName</span><span class="params">( dataType1 param1, dataType2 param2 ... )</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也可以不写形参，只写数据类型： </p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dataType  <span class="title">functionName</span><span class="params">( dataType1, dataType2 ... )</span></span>;</span><br></pre></td></tr></table></figure>



<p>好像下面的 <code>void</code> 不能少：</p>
<blockquote>
<p>char * getstr(void);</p>
</blockquote>
<h3 id="递归和迭代"><a href="#递归和迭代" class="headerlink" title="递归和迭代"></a>递归和迭代</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">递归好理解</span><br><span class="line">迭代就是循环，效率比递归高得多得多                                                                                                                </span><br><span class="line">占位符(手动～)</span><br></pre></td></tr></table></figure>



<h3 id="指针变量作为函数参数"><a href="#指针变量作为函数参数" class="headerlink" title="指针变量作为函数参数"></a><a href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">指针变量作为函数参数</a></h3><h3 id="用数组作函数参数"><a href="#用数组作函数参数" class="headerlink" title="用数组作函数参数"></a><a href="#%E7%94%A8%E6%95%B0%E7%BB%84%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0">用数组作函数参数</a></h3><h3 id="从函数返回数组"><a href="#从函数返回数组" class="headerlink" title="从函数返回数组"></a>从函数返回数组</h3><p><a target="_blank" rel="noopener" href="https://www.runoob.com/cprogramming/c-return-arrays-from-function.html">参考</a></p>
<p>如果想要用一个函数生成一个数组，再把它返回来，需要在函数内把数组定义为 <code>static</code> 变量，并用<strong>指针</strong>返回。</p>
<h3 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a><a href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC">指针函数</a></h3><p>函数指针 在 <a href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89">这里</a></p>
<h3 id="可变参数的函数"><a href="#可变参数的函数" class="headerlink" title="可变参数的函数"></a>可变参数的函数</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/engraver-lxw/p/7225232.html">参考1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/linhaostudy/p/6695422.html">参考2</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fnlingnzb-learner/p/6401841.html">参考3</a></p>
<h3 id="命令行参数解析"><a href="#命令行参数解析" class="headerlink" title="命令行参数解析"></a>命令行参数解析</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qingergege/p/5914218.html">参考</a></p>
<h2 id="预处理命令"><a href="#预处理命令" class="headerlink" title="预处理命令"></a>预处理命令</h2><h3 id="define"><a href="#define" class="headerlink" title="#define"></a><em>#define</em></h3><ul>
<li><p>宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单粗暴的替换。字符串中可以含任何字符，它可以是常数、表达式、if 语句、函数等，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。</p>
</li>
<li><p>宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。</p>
</li>
<li><p>宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用<code>#undef</code>命令。</p>
</li>
<li><p>代码中的宏名如果被引号包围，那么预处理程序不对其作宏代替，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OK 100</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OK\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>宏定义允许嵌套，在宏定义的字符串中可以使用已经定义的宏名，在宏展开时由预处理程序层层代换。</p>
</li>
<li><p>C语言允许宏带有参数。在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，这点和函数有些类似。对带参数的宏，在展开过程中不仅要进行字符串替换，还要用实参去替换形参。</p>
<p>带参宏定义的一般形式为： </p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> 宏名(形参列表) 字符序列</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="宏参数的字符串化和连接"><a href="#宏参数的字符串化和连接" class="headerlink" title="宏参数的字符串化和连接"></a>宏参数的字符串化和连接</h3><h4 id="将宏参数转换为字符串"><a href="#将宏参数转换为字符串" class="headerlink" title="将宏参数转换为字符串"></a>将宏参数转换为字符串</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s</span></span><br></pre></td></tr></table></figure>

<p>那么，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, STR(c.biancheng.net));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, STR(<span class="string">&quot;c.biancheng.net&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>会被展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;c.biancheng.net&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\&quot;c.biancheng.net\&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>​    即使给宏参数“传递”的数据中包含引号，使用<code>#</code>仍然会在两头添加新的引号，而原来的引号会被转义。</p>
<h4 id="连接宏参数"><a href="#连接宏参数" class="headerlink" title="连接宏参数"></a>连接宏参数</h4><p><code>##</code>称为连接符，用来将宏参数或其他的串连接起来。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CON1(a, b) a##e##b</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CON2(a, b) a##b##00</span></span><br></pre></td></tr></table></figure>

<p>那么，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, CON1(<span class="number">8.5</span>, <span class="number">2</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, CON2(<span class="number">12</span>, <span class="number">34</span>));</span><br></pre></td></tr></table></figure>

<p>会被展开为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, <span class="number">8.5e2</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">123400</span>);</span><br></pre></td></tr></table></figure>



<h3 id="预定义宏"><a href="#预定义宏" class="headerlink" title="预定义宏"></a>预定义宏</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ANSI C 规定了以下几个预定义宏，它们在各个编译器下都可以使用： </span><br><span class="line">__LINE__：表示当前源代码的行号；`整数`</span><br><span class="line">__FILE__：表示当前源文件的名称；`字符串`</span><br><span class="line">__DATE__：表示当前的编译日期；</span><br><span class="line">__TIME__：表示当前的编译时间；</span><br><span class="line">__STDC__：当要求程序严格遵循ANSI C标准时该标识被赋值为<span class="number">1</span>；</span><br><span class="line">__cplusplus：当编写C++程序时该标识符被定义。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在打印调试信息时除了文件名和行号之外还可以打印出当前函数名，C99引入一个特殊的标识符<code>__func__</code>支持这一功能。这个标识符应该是一个变量名而不是宏定义，不属于预处理的范畴，但它的作用和<code>__FILE__</code>、<code>__LINE__</code>类似。</p>
</blockquote>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><h4 id="if-的用法"><a href="#if-的用法" class="headerlink" title="#if 的用法"></a><em>#if</em> 的用法</h4><p>开发一个C语言程序，让它输出红色的文字，并且要求跨平台，在 Windows 和 Linux 下都能运行</p>
<p>Windows 有专有的宏<code>_WIN32</code>，Linux 有专有的宏<code>__linux__</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> _WIN32</span></span><br><span class="line">        system(<span class="string">&quot;color 0c&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;http://c.biancheng.net\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">elif</span> __linux__</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\033[22;31mhttp://c.biancheng.net\n\033[22;30m&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;http://c.biancheng.net\n&quot;</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ifdef-的用法"><a href="#ifdef-的用法" class="headerlink" title="#ifdef 的用法"></a><em>#ifdef</em> 的用法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span>  宏名</span></span><br><span class="line">    程序段<span class="number">1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    程序段<span class="number">2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="ifndef-的用法"><a href="#ifndef-的用法" class="headerlink" title="#ifndef 的用法"></a><em>#ifndef</em> 的用法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> 宏名</span></span><br><span class="line">    程序段<span class="number">1</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span> </span></span><br><span class="line">    程序段<span class="number">2</span> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个很有用哦，在多文件编程互相包含的情况下 -&gt; <a href="#%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB">具体用法</a></p>
</blockquote>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>使用指针是间接获取数据，使用变量名是直接获取数据，前者比后者的代价要高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d\n&quot;</span>, a, *p);  <span class="comment">//两种方式都可以输出a的值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CPU 读写数据必须要知道数据在内存中的地址，普通变量和指针变量都是地址的助记符，虽然通过 *p 和 a 获取到的数据一样，但它们的运行过程稍有不同：a 只需要一次运算就能够取得数据，而 *p 要经过两次运算，多了一层“间接”。</p>
<p>程序被编译和链接后，a、p 被替换成相应的地址。使用 *p 的话，要先通过地址 0XF0A0 取得变量 p 本身的值，这个值是变量 a 的地址，然后再通过这个值取得变量 a 的数据，前后共有两次运算；而使用 a 的话，可以通过地址 0X1000 直接取得它的数据，只需要一步运算。</p>
<blockquote>
<p><strong>指针变量加减运算的结果跟数据类型的长度有关</strong></p>
</blockquote>
<p>不过C语言并没有规定变量的存储方式，如果连续定义多个变量，它们有可能是挨着的，也有可能是分散的，这取决于变量的类型、编译器的实现以及具体的编译模式，所以对于指向普通变量的指针，我们往往不进行加减运算，虽然编译器并不会报错，但这样做没有意义，因为不知道它后面指向的是什么数据。</p>
<h3 id="数组指针（指向数组的指针）"><a href="#数组指针（指向数组的指针）" class="headerlink" title="数组指针（指向数组的指针）"></a>数组指针（指向数组的指针）</h3><blockquote>
<p>arr 是数组名，虽然指向数组的第 0 个元素，表示数组首地址，但是，<strong>数组和指针绝不等价</strong>，严格来说应该是“arr 被转换成了一个指针”。</p>
</blockquote>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">99</span>, <span class="number">15</span>, <span class="number">100</span>, <span class="number">888</span>, <span class="number">252</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br></pre></td></tr></table></figure>

<p>可以用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure>

<p>求出数组的长度，但是不能用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(p) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>

<p>另外，可以使用<code>*p++</code>，但是不能替换成 <code>*arr++</code>，因为 arr 是常量，而 arr++ 会改变它的值，这显然是错误的。</p>
<blockquote>
<ul>
<li>*<strong>p++</strong> 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素，上面已经进行了详细讲解。</li>
<li>*<strong>++p</strong> 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。</li>
<li>*<em>(<em>p)++</em></em> 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。</li>
</ul>
</blockquote>
<h3 id="字符串指针"><a href="#字符串指针" class="headerlink" title="字符串指针"></a>字符串指针</h3><p>除了字符数组，C语言还支持另外一种表示字符串的方法，就是直接使用一个指针指向字符串，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str;</span><br><span class="line">str = <span class="string">&quot;http://c.biancheng.net&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>它和字符数组很类似，都可以使用<code>%s</code>输出整个字符串，都可以使用<code>*</code>或<code>[ ]</code>获取单个字符</p>
<p><strong>区别</strong>：在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。</p>
<p>即，字符数组在定义后可以读取和修改每个字符，而对于第二种形式的字符串，一旦被定义后就只能读取不能修改，任何对它的赋值都是错误的。</p>
<p>所以称这种形式为<strong>字符串常量</strong>。</p>
<h3 id="指针变量作为函数参数-1"><a href="#指针变量作为函数参数-1" class="headerlink" title="指针变量作为函数参数"></a>指针变量作为函数参数</h3><ul>
<li><p>用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。</p>
</li>
<li><p>像数组、字符串、动态分配的内存等都是一系列数据的集合，没有办法通过一个参数全部传入函数内部，只能传递它们的指针，在函数内部通过指针来影响这些数据集合。</p>
</li>
<li><p>有的时候，对于整数、小数、字符等基本类型数据的操作也必须要借助指针，一个典型的例子就是交换两个变量的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;  <span class="comment">//临时变量</span></span><br><span class="line">    temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">66</span>, b = <span class="number">99</span>;</span><br><span class="line">    swap(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>a、b 的值并没有发生改变，交换失败。这是因为 swap() 函数内部的 a、b 和 main() 函数内部的 a、b 是不同的变量，占用不同的内存，它们除了名字一样，没有其他任何关系。</p>
<p>改用指针变量作参数后就很容易解决上面的问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> *p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;  <span class="comment">//临时变量</span></span><br><span class="line">    temp = *p1;</span><br><span class="line">    *p1 = *p2;</span><br><span class="line">    *p2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">66</span>, b = <span class="number">99</span>;</span><br><span class="line">    swap(&amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d, b = %d\n&quot;</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我记得以前学的时候就是这个例子..</p>
</blockquote>
<p>调用 swap() 函数时，将变量 a、b 的地址分别赋值给 p1、p2，这样 <code>*p1</code>、<code>*p2</code> 代表的就是变量 a、b 本身，交换 <code>*p1</code>、<code>*p2</code> 的值也就是交换 a、b 的值。函数运行结束后虽然会将 p1、p2 销毁，但它对外部 a、b 造成的影响是“持久化”的，不会随着函数的结束而“恢复原样”。</p>
</li>
</ul>
<h3 id="用数组作函数参数-1"><a href="#用数组作函数参数-1" class="headerlink" title="用数组作函数参数"></a>用数组作函数参数</h3><p>数组是一系列数据的集合，无法通过参数将它们一次性传递到函数内部，如果希望在函数内部操作数组，必须传递数组指针。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> *intArr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//暂时想不起来占位符是什么，就手动注释了，表明这里有点东西，但是被我省略了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数 intArr 仅仅是一个数组指针，在函数内部无法通过这个指针获得数组长度，必须将数组长度作为函数参数传递到函数内部。</p>
<p>用数组做函数参数时，参数也能够以<strong>“</strong><del>真正的</del><strong>”</strong>数组形式给出。例如对于上面的 max() 函数，它的参数可以写成下面的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> intArr[<span class="number">6</span>], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//手动注释</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也可以省略数组长度，把形参简写为下面的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> intArr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//你知道我要说什么..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上这两种形式的数组定义都是<strong>假象</strong>，不管是<code>int intArr[6]</code>还是<code>int intArr[]</code>都不会创建一个数组出来，编译器也不会为它们分配内存，实际的数组是不存在的，它们最终还是会转换为<code>int *intArr</code>这样的指针。这就意味着，两种形式都不能将数组的所有元素“一股脑”传递进来，大家还得规规矩矩使用数组指针。</p>
<p><code>int intArr[6]</code>这种形式只能说明函数期望用户传递的数组有 6 个元素，并不意味着数组只能有 6 个元素，真正传递的数组可以有少于或多于 6 个的元素。</p>
<p>需要强调的是，不管使用哪种方式传递数组，都不能在函数内部求得数组长度，因为 intArr 仅仅是一个指针，而不是真正的数组，所以必须要<strong>额外</strong>增加一个参数来<strong>传递数组长度</strong>。</p>
<blockquote>
<p>C语言为什么不允许直接传递数组的所有元素，而必须传递数组指针呢？<br>参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。<br>对于像 int、float、char 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组是一系列数据的集合，数据的数量没有限制，可能很少，也可能成千上万，对它们进行内存拷贝有可能是一个漫长的过程，会严重拖慢程序的效率，为了防止技艺不佳的程序员写出低效的代码，C语言没有从语法上支持数据集合的直接赋值。</p>
</blockquote>
<p><strong>C语言标准规定</strong>，作为“类型的数组”的形参应该调整为“类型的指针”。在函数形参定义这个特殊情况下，编译器必须把数组形式改写成指向数组第 0 个元素的指针形式。编译器只向函数传递数组的地址，而不是整个数组的拷贝。</p>
<p>这种隐式转换意味着下面三种形式的函数定义是完全等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> *parr)</span></span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> arr[])</span></span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> arr[<span class="number">5</span>])</span></span>&#123; ...... &#125;</span><br></pre></td></tr></table></figure>

<p>在函数内部，arr 会被转换成一个指针变量，编译器为 arr 分配 4 个字节的内存，用 sizeof(arr) 求得的是指针变量的长度，而不是数组长度。要想在函数内部获得数组长度必须额外增加一个参数，在调用函数之前求得数组长度。</p>
<h3 id="指针作为函数返回值"><a href="#指针作为函数返回值" class="headerlink" title="指针作为函数返回值"></a>指针作为函数返回值</h3><p>C语言允许函数的返回值是一个指针（地址），我们将这样的函数称为指针函数。下面的例子定义了一个函数 strlong()，用来返回两个字符串中较长的一个： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strlong</span><span class="params">(<span class="keyword">char</span> *str1, <span class="keyword">char</span> *str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(str1) &gt;= <span class="built_in">strlen</span>(str2))&#123;</span><br><span class="line">        <span class="keyword">return</span> str1;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[<span class="number">30</span>], str2[<span class="number">30</span>], *str;</span><br><span class="line">    gets(str1);</span><br><span class="line">    gets(str2);</span><br><span class="line">    str = strlong(str1, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Longer string: %s\n&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    用指针作为函数返回值时需要注意的一点是，函数运行结束后会<strong>销毁</strong>在它内部定义的所有<strong>局部数据</strong>，包括局部变量、局部数组和形式参数，函数返回的指针请尽量不要指向这些数据，C语言没有任何机制来保证这些数据会一直有效，它们在后续使用过程中可能会引发运行时错误。</p>
<p>​    销毁指的是，程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。所以它的值可能会变，也可能不变，结果不确定。</p>
<p>​    </p>
<h3 id="二级指针"><a href="#二级指针" class="headerlink" title="二级指针"></a>二级指针</h3><p>如果一个指针指向的是另外一个指针，我们就称它为二级指针，或者指向指针的指针。</p>
<p>C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号<code>*</code>。</p>
<h3 id="空指针-NULL"><a href="#空指针-NULL" class="headerlink" title="空指针 NULL"></a>空指针 NULL</h3><p>一个指针变量可以指向计算机中的任何一块内存，不管该内存有没有被分配，也不管该内存有没有使用权限，只要把地址给它，它就可以指向，C语言没有一种机制来保证指向的内存的正确性，程序员必须自己提高警惕。</p>
<p>很多初学者会在无意间对没有初始化的指针进行操作，这是非常危险的。</p>
<p>可以对没有初始化的指针赋值为 NULL，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>NULL 是在<code>stdio.h</code>中定义的一个宏，注意区分大小写，null 没有任何特殊含义，只是一个普通的标识符。也不可将 NULL 和 0 等同起来。</p>
</blockquote>
<h3 id="void-指针"><a href="#void-指针" class="headerlink" title="void 指针"></a>void 指针</h3><p>void 用在函数定义中可以表示函数没有返回值或者没有形式参数，而 <em>void指针</em> 表示指针指向的数据的类型是未知的。</p>
<p>也就是说，<code>void *</code>表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换。</p>
<h3 id="数组和指针不等价"><a href="#数组和指针不等价" class="headerlink" title="数组和指针不等价"></a>数组和指针不等价</h3><p>数组和指针不等价的一个典型案例就是<strong>求数组的长度</strong>，这个时候只能使用数组名，不能使用数组指针。</p>
<p>站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。变量名用来指代一份数据，数组名用来指代一组数据（数据集合），它们都是有<strong>类型</strong>的，以便推断出所指代的数据的长度。</p>
<p>数组也有类型，sizeof 就是根据符号的类型来计算长度的。</p>
<p>对于数组 a，它的类型是<code>int [6]</code>，表示这是一个拥有 6 个 int 数据的集合，1 个 int 的长度为 4，6 个 int 的长度为 4×6 = 24，sizeof 很容易求得。</p>
<p>对于指针变量 p，它的类型是<code>int *</code>，在 32 位环境下长度为 4，在 64 位环境下长度为 8。</p>
<p>归根结底，a 和 p 这两个符号的类型不同，指代的数据也不同，它们不是一码事，sizeof 是根据符号类型来求长度的，a 和 p 的类型不同，求得的长度自然也不一样。</p>
<p>对于二维数组，也是类似的道理，例如<code>int a[3][3]=&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;;</code>，它的类型是<code>int [3][3]</code>，长度是 4×3×3 = 36。</p>
<p>与普通变量名相比，数组名既有一般性也有特殊性：一般性表现在数组名也用来指代特定的内存块，也有类型和长度；特殊性表现在数组名有时候会转换为一个指针，而不是它所指代的数据本身的值。</p>
<h3 id="数组在什么时候会转换为指针"><a href="#数组在什么时候会转换为指针" class="headerlink" title="数组在什么时候会转换为指针"></a>数组在什么时候会转换为指针</h3><p>数组名的本意是表示一组数据的集合，它和普通变量一样，都用来指代一块内存，但在使用过程中，数组名有时候会转换为指向数据集合的指针（地址），而不是表示数据集合本身。</p>
<p>数据集合包含了多份数据，直接使用一个集合没有明确的含义，将数组名转换为指向数组的指针后，可以很容易地访问其中的任何一份数据，使用时的语义更加明确。</p>
<p><strong>C语言标准规定</strong>，当数组名作为数组<strong>定义</strong>的标识符（也就是定义或声明数组时）、<strong>sizeof</strong> 或 <strong>&amp;</strong> 的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被<a id="tips">转换</a>为指向第 0 个元素的指针（地址）。</p>
<h3 id="对数组名取址-amp-arr"><a href="#对数组名取址-amp-arr" class="headerlink" title="对数组名取址 &amp;arr"></a>对数组名取址 &amp;arr</h3><p>一般情况下，数组名会被转换成指向数组第一个元素的指针，也就是数组指针。</p>
<p>那么对数组名取址，不是像我们想的那样，再对上面取地址，真正的指针是这样，但是数组名不一样。它其实是指向整个数组的指针，类型是二维数组指针。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[] = &#123;<span class="number">99</span>,<span class="number">15</span>,<span class="number">100</span>,<span class="number">33</span>,<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p = arr;        <span class="comment">//p的类型是 int *</span></span><br><span class="line">    <span class="keyword">int</span> (*p2)[<span class="number">5</span>]= &amp;arr;  <span class="comment">//p2的类型是 int (*) [5]</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0]= %d\n&quot;</span>,*p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;arr[0]= %d\n&quot;</span>,(*p2)[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体变量名就和数组名不一样了，要加 <code>&amp;</code> 才能表示结构体变量的地址。详见 -&gt; <a href="#%E7%BB%93%E6%9E%84%E4%BD%93">结构体说明</a></p>
<h3 id="数组下标"><a href="#数组下标" class="headerlink" title="数组下标[ ]"></a>数组下标<code>[ ]</code></h3><p>对数组的引用 <code>a[i]</code> 在编译时总是被编译器改写成<code>*(a+i)</code>的形式，C语言标准也要求编译器必须具备这种行为。</p>
<p>取下标操作符<code>[ ]</code>是建立在指针的基础上，它的作用是使一个指针和一个整数相加，产生出一个新的指针，然后从这个新指针（新地址）上取得数据；假设指针的类型为<code>T *</code>，所产生的结果的类型就是<code>T</code>。</p>
<p>取下标操作符的两个操作数是可以交换的，它并不在意操作数的先后顺序，就像在加法中 3+5 和 5+3 并没有什么不一样。以上面的数组 a 为例，如果希望访问第 3 个元素，那么可以写作<code>a[3]</code>，也可以写作<code>3[a]</code>，这两种形式都是正确的，只不过后面的形式从不曾使用，<del>它除了可以把初学者搞晕之外</del>，实在没有什么实际的意义。</p>
<blockquote>
<p>a[3] 等价于 *(a + 3)，3[a] 等价于 *(3 + a)，仅仅是把加法的两个操作数调换了位置。</p>
</blockquote>
<p>使用下标时，编译器会自动把下标的步长调整到数组元素的大小。数组 a 中每个元素都是 int 类型，长度为 4 个字节，那么<code>a[i+1]</code>和<code>a[i]</code>在内存中的距离是 4（而不是 1）。</p>
<h3 id="指针数组（数组每个元素都是指针）"><a href="#指针数组（数组每个元素都是指针）" class="headerlink" title="指针数组（数组每个元素都是指针）"></a>指针数组（数组每个元素都是指针）</h3><p>没什么好说的，先看两个例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">16</span>, b = <span class="number">932</span>, c = <span class="number">100</span>;</span><br><span class="line">    <span class="comment">//定义一个指针数组</span></span><br><span class="line">    <span class="keyword">int</span> *arr[<span class="number">3</span>] = &#123;&amp;a, &amp;b, &amp;c&#125;;<span class="comment">//也可以不指定长度，直接写作 int *parr[]</span></span><br><span class="line">    <span class="comment">//定义一个指向指针数组的指针</span></span><br><span class="line">    <span class="keyword">int</span> **parr = arr;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, *arr[<span class="number">0</span>], *arr[<span class="number">1</span>], *arr[<span class="number">2</span>]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d, %d, %d\n&quot;</span>, **(parr+<span class="number">0</span>), **(parr+<span class="number">1</span>), **(parr+<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面这个例子有点意思：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str[<span class="number">3</span>] = &#123;</span><br><span class="line">        <span class="string">&quot;c.biancheng.net&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C语言中文网&quot;</span>,</span><br><span class="line">        <span class="string">&quot;C Language&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n%s\n%s\n&quot;</span>, str[<span class="number">0</span>], str[<span class="number">1</span>], str[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="二维数组指针（指向二维数组的指针）"><a href="#二维数组指针（指向二维数组的指针）" class="headerlink" title="二维数组指针（指向二维数组的指针）"></a>二维数组指针（指向二维数组的指针）</h3><blockquote>
<p>好像有种说法是，这个是一维数组指针，因为虽然是把二维数组名赋值给它，但是二维数组名代表一维数组的地址。有点绕，但是不管它的定义是什么，它的用法就是这样</p>
<p>看了一下，同一个网站上的内容定义都不一样</p>
<p>还是规范一下定义吧。</p>
<p>普通的指针称为一级指针。指向一级指针的指针称为二级指针。</p>
<p>如果把一维数组指针定义为它指向一个一维数组，那么这个指针（地址箱）里存放的应该是二维数组的数组名（二级指针常量），也就是这个二维数组的第 0 个一维数组的地址。这个一维数组的地址又指向它的第 0 个元素。也就是说，一维数组指针属于二级指针。</p>
<p>把自己绕晕了。。不纠结它是几维数组了，统一称为数组指针，为了区分，可以加限定语（一级指针还是二级指针，这个是不会搞混的）</p>
<p>这样想概念清楚多了，我感觉一（二）维数组指针这个概念就和 1[a] 一样，就是为了把人绕晕才弄出来的。</p>
</blockquote>
<p>这个容易和指针数组搞混，先看下形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = a;  <span class="comment">//这个a是二维数组的数组名，也就是它第一个元素（第一个一维数组）的地址</span></span><br></pre></td></tr></table></figure>

<p>括号中的<code>*</code>表明 p 是一个指针，它指向一个数组，数组的类型为<code>int [4]</code>，这正是 a 所包含的每个一维数组的类型。<br><code>[ ]</code>的优先级高于<code>*</code>，<code>( )</code>是必须要加的，如果赤裸裸地写作<code>int *p[4]</code>，那么应该理解为<code>int *(p[4])</code>，p 就成了一个<a href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%EF%BC%88%E6%95%B0%E7%BB%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%98%AF%E6%8C%87%E9%92%88%EF%BC%89">指针数组</a>，而不是二维数组指针。</p>
<p>也就是说：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">4</span>] = a;          <span class="comment">//指针数组</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = a;        <span class="comment">//二维数组指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *(p1[<span class="number">4</span>]);  <span class="comment">//指针数组，可以去掉括号直接写作 int *p1[5];</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">4</span>];  <span class="comment">//二维数组指针，不能去掉括号</span></span><br></pre></td></tr></table></figure>

<p>指针数组和二维数组指针有着本质上的区别：指针数组是一个数组，只是每个元素保存的都是指针，以上面的 p1 为例，在32位环境下它占用 4×5 = 20 个字节的内存。二维数组指针是一个指针，它指向一个二维数组，以上面的 p2 为例，它占用 4 个字节的内存。</p>
<p>指针数组的类型是 <code>int [4]</code> 数组，每个元素的类型是 <code>int *</code> 指针。</p>
<p>二维数组指针的类型是 <code>int (*) [4]</code> ，指向的数据的类型是 <code>int [4]</code> 数组。</p>
<p><strong>助记</strong>，看括号里面的，里面是什么，本质上就是什么。</p>
<p><strong>先停一下</strong>，看到这里，你可能会对类型和指针指向的类型的疑惑，看<a href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB">这里</a></p>
<p>你可能会问，<code>int (*p)[4] = a;</code> 既然是一个指向数组的指针 p ，那么为什么不叫它<del>一维</del>数组指针，而叫它二维数组指针。</p>
<p>我们<a href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89">之前</a>学到过，数组指针是长这样的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123; <span class="number">99</span>, <span class="number">15</span>, <span class="number">100</span>, <span class="number">888</span>, <span class="number">252</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *p = arr;</span><br></pre></td></tr></table></figure>

<p><del>一维</del>数组指针本质上就是一般的指针，只不过存放的是数组的首地址，但是你看它的类型的是<code>int *</code> ,也就是说<code>p+1</code>的话，实际上加的是<code>int</code>的字节数，也就是4。</p>
<p>而二维数组指针<code>int (*p)[4] = a;</code> ，它的类型是<code>int (*) [4]</code>,如果 <code>p+1</code> ，实际上加的是 <code>int [4]</code> 的字节数，也就是4×4=16。因此，在二维数组里使用它，就可以很方便地用 <code>p+1</code> 访问下一行一维数组。</p>
<p>也可以这么看，<del>一维</del>数组指针指向的是一维数组的首地址，也是一维数组第一个元素的地址。</p>
<p>而二维数组指针指向的是二维数组的首地址，也是二维数组的第一行一维数组的首地址。</p>
<p><del>之前说过，数组名和指针决不等价，不能根据一维数组指针来求数组的元素的个数，那么二维数组指针应该正好可以相等吧？(存疑)</del></p>
<p><del>一维数组可不可以写成 <code>int a[0][4];</code>的形式？如果可以的话，应该可以认为二维数组指针和数组名相等吧。</del></p>
<p>不相等，或者说 a 和 *p 相等，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="number">2</span> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="number">3</span>     <span class="keyword">int</span> a[][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line"> <span class="number">4</span>     <span class="keyword">int</span> sizea = <span class="keyword">sizeof</span>(a);</span><br><span class="line"> <span class="number">5</span>     <span class="keyword">int</span> (*p)[<span class="number">4</span>] = a;</span><br><span class="line"> <span class="number">6</span>     <span class="keyword">int</span> sizep = <span class="keyword">sizeof</span>(p);</span><br><span class="line"> <span class="number">7</span>     <span class="keyword">int</span> sizepa = <span class="keyword">sizeof</span>(*p);</span><br><span class="line"> <span class="number">8</span></span><br><span class="line"> <span class="number">9</span>     <span class="built_in">printf</span>(<span class="string">&quot;a[0][2] = %d\n&quot;</span>,a[<span class="number">0</span>][<span class="number">2</span>] );</span><br><span class="line"><span class="number">10</span>     <span class="built_in">printf</span>(<span class="string">&quot;sizea = %d\n&quot;</span>,sizea );</span><br><span class="line"><span class="number">11</span>     <span class="built_in">printf</span>(<span class="string">&quot;sizep = %d\n&quot;</span>,sizep );</span><br><span class="line"><span class="number">12</span>     <span class="built_in">printf</span>(<span class="string">&quot;sizepa = %d\n&quot;</span>,sizepa );</span><br><span class="line"><span class="number">13</span>     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="number">14</span> &#125;</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">a[0][2] = 2</span><br><span class="line">sizea = 16   <span class="comment">#4个int</span></span><br><span class="line">sizep = 8    <span class="comment">#所有指针占用的字节数都是一样的，64位好像是8字节</span></span><br><span class="line">sizepa = 16  <span class="comment">#可以看出 *p 和 a 用 sizeof 的效果相同</span></span><br></pre></td></tr></table></figure>

<p>但是实际上这样写很麻烦，没必要这么用。</p>
<p>如果是这样：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ cat -n main.c &amp;&amp; echo &amp;&amp; ./c4</span><br><span class="line">     <span class="number">1</span>   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">     <span class="number">2</span>   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="number">3</span>       <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;&#125;;</span><br><span class="line">     <span class="number">4</span>       <span class="keyword">int</span> sizea = <span class="keyword">sizeof</span>(a);</span><br><span class="line">     <span class="number">5</span>       <span class="keyword">int</span> (*p)[<span class="number">4</span>] = a;</span><br><span class="line">     <span class="number">6</span>       <span class="keyword">int</span> *s = a;   <span class="comment">//我想知道这个会怎样 //warning: initialization of ‘int *’ from incompatible pointer type ‘int (*)[4]’</span></span><br><span class="line">     <span class="number">7</span>       <span class="keyword">int</span> sizep = <span class="keyword">sizeof</span>(p);</span><br><span class="line">     <span class="number">8</span>       <span class="keyword">int</span> sizepa = <span class="keyword">sizeof</span>(*p);</span><br><span class="line">     <span class="number">9</span></span><br><span class="line">    <span class="number">10</span>       <span class="built_in">printf</span>(<span class="string">&quot;s[0] = %d\n&quot;</span>,<span class="number">0</span>[s] ); <span class="comment">//所以说，s是一维数组指针</span></span><br><span class="line">    <span class="number">11</span>       <span class="built_in">printf</span>(<span class="string">&quot;s[1] = %d\n&quot;</span>,<span class="number">1</span>[s] ); <span class="comment">//由此可见，指针变量里存的真的就是一个首地址，但是为了界定</span></span><br><span class="line">    <span class="number">12</span>       <span class="built_in">printf</span>(<span class="string">&quot;s[3] = %d\n&quot;</span>,<span class="number">3</span>[s] ); <span class="comment">//指针对应的变量的内存范围，需要用指针的类型来指定</span></span><br><span class="line">    <span class="number">13</span></span><br><span class="line">    <span class="number">14</span>       <span class="built_in">printf</span>(<span class="string">&quot;a[0][2] = %d\n&quot;</span>,<span class="number">0</span>[a][<span class="number">2</span>] ); <span class="comment">//记得这个东西吗，数组下标也是一种运算符</span></span><br><span class="line">    <span class="number">15</span>       <span class="built_in">printf</span>(<span class="string">&quot;a[0][2] = %d\n&quot;</span>,<span class="number">0</span>[p][<span class="number">2</span>] ); <span class="comment">//既然数组下标只是一种运算符，那么这么写也是可以的喽</span></span><br><span class="line">    <span class="number">16</span>       <span class="built_in">printf</span>(<span class="string">&quot;sizea = %d\n&quot;</span>,sizea );</span><br><span class="line">    <span class="number">17</span>       <span class="built_in">printf</span>(<span class="string">&quot;sizep = %d\n&quot;</span>,sizep );</span><br><span class="line">    <span class="number">18</span>       <span class="built_in">printf</span>(<span class="string">&quot;sizepa = %d\n&quot;</span>,sizepa );</span><br><span class="line">    <span class="number">19</span>       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="number">20</span>   &#125;</span><br><span class="line"></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">s[<span class="number">3</span>] = <span class="number">3</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">a[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">2</span></span><br><span class="line">sizea = <span class="number">32</span></span><br><span class="line">sizep = <span class="number">8</span></span><br><span class="line">sizepa = <span class="number">16</span></span><br></pre></td></tr></table></figure>



<p>———————————————————————分割线—————————————————————————</p>
<p>回到正题，看例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123; &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">int</span> (*p)[<span class="number">4</span>] = a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(*(p+<span class="number">1</span>)));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><code>p</code>指向数组 a 的开头，也即第 0 行；<code>p+1</code>前进一行，指向第 1 行。</p>
<p><code>p</code> 是第0行的地址，p 指向第0行；<code>p+1</code> 是第1行的地址，指向第1行。</p>
</li>
<li><p><code>*(p+1)</code>表示取地址上的数据，也就是整个第 1 行数据。注意是一行数据，是多个数据，不是第 1 行中的第 0 个元素。</p>
<p><code>*(p+1)</code> 是第1行，即 <code>a[1]</code> ，在表达示中会被<a href="#tips">转换</a>成 <code>a[1]</code> 的首地址，即 <code>a[1][0]</code> 的地址。</p>
</li>
<li><p><code>*(p+1)+1</code>表示第 1 行第 1 个元素的地址。</p>
</li>
<li><p><code>*(*(p+1)+1)</code>表示第 1 行第 1 个元素的值。很明显，增加一个 * 表示取地址上的数据。</p>
</li>
</ol>
<p>根据上面的结论，可以很容易推出以下的等价关系：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a+i == p+i</span><br><span class="line">a[i] == p[i] == *(a+i) == *(p+i)</span><br><span class="line">a[i][j] == p[i][j] == *(a[i]+j) == *(p[i]+j) == *(*(a+i)+j) == *(*(p+i)+j)</span><br></pre></td></tr></table></figure>



<h3 id="类型和所占字节数的关系"><a href="#类型和所占字节数的关系" class="headerlink" title="类型和所占字节数的关系"></a>类型和所占字节数的关系</h3><p>把数据分为两种，一种是普通的数据，包括数组、结构体等(暂时)；另一种只有指针。</p>
<ul>
<li><p>普通的数据，类型决定它在内存中的字节数；</p>
<p>如 <code>int</code> 一般是4，<code>int [4]</code> 数组是 16</p>
</li>
<li><p>指针的类型，决定了它所指向的元素的长度。</p>
<p>如 <code>int *</code> ，去掉 * 号，就是 int ，占 4；</p>
<p>如 <code>int (*) [4]</code> ，去掉 * 号，就是<code>int [4]</code> ，占 16。</p>
</li>
<li><p>再提一下，数组的类型。它有点特别，不是直接读前面的数据类型。</p>
<p>比如 <code>int a[4];</code> 定义了一个数组，类型当然像上面说的，是 <code>int [4]</code> 。这表明它的每一个元素的类型是 <code>int</code> 。</p>
</li>
</ul>
<p>  指针的类型，也不是直接读的，还要加上 * 号。</p>
<p>  <code>int *p;</code> 它的类型是 <code>int *</code> ，表示它指向的数据的类型是 <code>int</code> 。</p>
<p>  这么看起来，数组和指针还真的有相似之处。难怪指针数组和二维数组指针容易混淆。</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *(p1[<span class="number">4</span>]); </span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<p>  你能分清楚哪个是哪个吗？</p>
<p>  等等，我又发现一个问题，我怎么感觉它们的类型都是 <code>int (*) [4]</code> 呀，虽然好像是写法上的巧合。</p>
<p>  那么，我来定义一下，</p>
<p>  <code>(int *) [4]</code> 是<strong>指针数组</strong>的类型；</p>
<p>  <code>(int [4]) *</code> 是<strong>二维数组指针</strong>的类型；</p>
<h3 id="指针数组-和-二维数组指针"><a href="#指针数组-和-二维数组指针" class="headerlink" title="指针数组 和 二维数组指针"></a>指针数组 和 二维数组指针</h3><p>上面讲得太乱了，我自己都看不下去了。。</p>
<p>再理一遍：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *(p1[<span class="number">4</span>]); </span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>首先看括号里的内容，括号里是什么就是什么。第一个是数组，第二个是指针。如果没有括号，记住 <code>[]</code> 的优先级比 * 高。</p>
</li>
<li><p>然后括号外面的就是它指向的数据的类型，或者是它每一个元素的类型。</p>
<ul>
<li>第一个外面的内容是 int * ，所以这个数组的元素的类型就是 int *。</li>
<li>第二个外面的内容是 int [4] ，所以这个指针指向的数据的类型是 int [4] ，也就是数组。</li>
</ul>
</li>
</ul>
<p>这么说清晰多了。根本不需要讨论数组和指针本身的类型嘛，只需要知道它指向或者包含的数据类型就可以了，不然就太乱了。</p>
<h3 id="函数指针（指向函数的指针）"><a href="#函数指针（指向函数的指针）" class="headerlink" title="函数指针（指向函数的指针）"></a>函数指针（指向函数的指针）</h3><p><a target="_blank" rel="noopener" href="http://akaedu.github.io/book/ch23s06.html">这个可能更清晰一些</a></p>
<p>一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。</p>
<p>函数指针的定义形式为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">returnType (*pointerName)(param <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure>

<p>returnType 为函数返回值类型，pointerNmae 为指针名称，param list 为函数参数列表。参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。</p>
<p>注意<code>( )</code>的优先级高于<code>*</code>，<strong>第一个括号不能省略</strong>，如果写作<code>returnType *pointerName(param list);</code>就成了函数原型，它表明函数的返回值类型为<code>returnType *</code>。</p>
<p>看个例子，自己体会：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回两个数中较大的一个</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y, maxval;</span><br><span class="line">    <span class="comment">//定义函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*pmax)(<span class="keyword">int</span>, <span class="keyword">int</span>) = max;  <span class="comment">//也可以写作int (*pmax)(int a, int b)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    maxval = (*pmax)(x, y);       <span class="comment">//pmax 是一个函数指针，在前面加 * 就表示对它指向的函数进行调用。</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Max value: %d\n&quot;</span>, maxval);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>下面的<a target="_blank" rel="noopener" href="http://c.biancheng.net/c/pointer/">参考</a></p>
<p>在给函数指针变量赋值时，函数名前面的取地址操作符 &amp; 可以省略。因为在编译时，C 语言编译器会隐含完成把函数名转换成对应指针形式的操作，故加 &amp; 只是为了显式说明编译器隐含执行该转换操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pf=&amp;func; <span class="comment">//正确</span></span><br><span class="line">pf=func; <span class="comment">//正确。也可省略&amp;   //对结构体变量取址就必须要用 &amp;</span></span><br></pre></td></tr></table></figure>

<p>当函数指针变量 pf 被初始化指向函数f()后，调用函数 func() 有如下三种形式。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result;</span><br><span class="line">result=func(<span class="number">2</span>); <span class="comment">//正确。编译器会把函数名转换成对应指针</span></span><br><span class="line">result=pf(<span class="number">2</span>); <span class="comment">//正确。直接使用函数指针</span></span><br><span class="line">result=(*pf)(<span class="number">2</span>); <span class="comment">//正确。先把函数指针转换成对应函数名</span></span><br></pre></td></tr></table></figure>

<p>函数调用时，编译器把函数名转换为对应指针形式，故前两种调用方式含义一样，而第三种调用方式，*pf 转换成对应的函数名 fun()，编译时，编译器还会把函数名转换成对应指针形式，从这个角度来理解，第三种调用方式走了些弯路。</p>
<p>实例：使用函数指针，编程实现一个简单计算器程序。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">void</span> (*pf) (<span class="keyword">int</span>,<span class="keyword">int</span>),<span class="keyword">int</span> opl,<span class="keyword">int</span> op2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>; <span class="comment">//加操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>; <span class="comment">//减操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mult</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>; <span class="comment">//乘操作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sel,x1,x2;</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;Select the operator:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;sel);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Input two numbers:&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span> (<span class="string">&quot;%d%d&quot;</span>,&amp;x1, &amp;x2);</span><br><span class="line">    <span class="keyword">switch</span>(sel)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            cal(add,x1,x2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span> :</span><br><span class="line">            cal(sub,x1,x2);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            cal(mult,x1,x2) ;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span> (<span class="string">&quot;Input error!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span> <span class="params">(<span class="keyword">void</span> (*pf) (<span class="keyword">int</span>, <span class="keyword">int</span>) , <span class="keyword">int</span> opl, <span class="keyword">int</span> op2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    pf (opl,op2) ; <span class="comment">//或者(*pf)(opl,op2);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result=(a + b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d + %d = %d\n&quot;</span>,a,b,result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sub</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result= (a - b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d - %d = %d\n&quot;</span>, a,b, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mult</span> <span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result= (a * b);</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;%d * %d = %d\n&quot;</span>,a,b,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="函数指针的应用"><a href="#函数指针的应用" class="headerlink" title="函数指针的应用"></a>函数指针的应用</h3><p><a target="_blank" rel="noopener" href="http://akaedu.github.io/book/ch23s08.html">参考</a></p>
<p>如果要根据一个变量的值来分别实现两种不同的功能，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">real_part</span><span class="params">(struct complex_struct z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (z.t == RECTANGULAR)</span><br><span class="line">		<span class="keyword">return</span> z.a;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> z.a * <span class="built_in">cos</span>(z.b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在抽象层上都是取复数的实部部分，根据是直角坐标还是极坐标有两种不同的实现（有点对象的感觉了）</p>
<p>但是，</p>
<blockquote>
<p>现在类型字段有两种取值，<code>RECTANGULAR</code>和<code>POLAR</code>，每个函数都要<code>if ... else ...</code>，如果类型字段有三种取值呢？每个函数都要<code>if ... else if ... else</code>，或者<code>switch ... case ...</code>。这样维护代码是不够理想的，现在用函数指针给出一种实现：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rect_real_part</span><span class="params">(struct complex_struct z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> z.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">pol_real_part</span><span class="params">(struct complex_struct z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> z.a * <span class="built_in">cos</span>(z.b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义指针数组</span></span><br><span class="line"><span class="keyword">double</span> (*real_part_tbl[])(struct complex_struct) = &#123; rect_real_part, pol_real_part &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> real_part(z) real_part_tbl[z.t](z)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当调用<code>real_part(z)</code>时，用类型字段<code>z.t</code>做索引，从指针数组<code>real_part_tbl</code>中取出相应的函数指针来调用，也可以达到<code>if ... else ...</code>的效果，但相比之下这种实现更好，每个函数都只做一件事情，而不必用<code>if ... else ...</code>兼顾好几件事情，比如<code>rect_real_part</code>和<code>pol_real_part</code>各做各的，互相独立，而不必把它们的代码都耦合到一个函数中。“<strong>低耦合，高内聚</strong>”（Low Coupling, High Cohesion）是程序设计的一条基本原则，这样可以更好地复用现有代码，使代码更容易维护。如果类型字段<code>z.t</code>又多了一种取值，只需要添加一组新的函数，修改函数指针数组，原有的函数仍然可以不加改动地复用。</p>
</blockquote>
<h3 id="数组与指针"><a href="#数组与指针" class="headerlink" title="数组与指针"></a>数组与指针</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chenyangyao/p/5222696.html">参考</a></p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组作为函数形参时会退化为指针。</span><br></pre></td></tr></table></figure>



<p><a target="_blank" rel="noopener" href="http://akaedu.github.io/book/ch23s03.html">更详细的解释</a></p>
<p>在函数原型中，如果参数是数组，则等价于参数是指针的形式，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int a[10])</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int *a)</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一种形式方括号中的数字可以不写，仍然是等价的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void func(int a[])</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数写成指针形式还是数组形式对编译器来说没区别，都表示这个参数是指针，之所以规定两种形式是为了给读代码的人提供有用的信息，如果这个参数指向一个元素，通常写成指针的形式，如果这个参数指向一串元素中的首元素，则经常写成数组的形式。</p>
<h3 id="空指针与野指针"><a href="#空指针与野指针" class="headerlink" title="空指针与野指针"></a>空指针与野指针</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33757398/article/details/81259636">参考</a></p>
<h3 id="指针总结"><a href="#指针总结" class="headerlink" title="指针总结"></a>指针总结</h3><blockquote>
<p>吾尝终日而思矣，不如须臾之所学也</p>
</blockquote>
<p>我想了那么多，还没有别人讲得好  —&gt; <a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_2024.html">参考</a></p>
<p><strong>C语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。对，从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键！</strong></p>
<p>优先级从高到低依次是：</p>
<ul>
<li>定义中被括号<code>( )</code>括起来的那部分。</li>
<li>后缀操作符：括号<code>( )</code>表示这是一个函数，方括号<code>[ ]</code>表示这是一个数组。</li>
<li>前缀操作符：星号<code>*</code>表示“指向xxx的指针”。</li>
</ul>
<p><img src="/passages/Learning-notes/190712_154218.png" alt="例4"></p>
<p><img src="/passages/Learning-notes/190712_155003.png" alt="例5"></p>
<p>常见指针变量的定义：</p>
<table>
<thead>
<tr>
<th>定  义</th>
<th>含  义</th>
</tr>
</thead>
<tbody><tr>
<td>int *p;</td>
<td>p 可以指向 int 类型的数据，也可以指向类似 int arr[n] 的数组。</td>
</tr>
<tr>
<td>int **p;</td>
<td>p 为二级指针，指向 int * 类型的数据。</td>
</tr>
<tr>
<td>int *p[n];</td>
<td>p 为指针数组。[ ] 的优先级高于 *，所以应该理解为 int *(p[n]);</td>
</tr>
<tr>
<td>int (*p)[n];</td>
<td>p 为二维数组指针。</td>
</tr>
<tr>
<td>int *p();</td>
<td>p 是一个函数，它的返回值类型为 int *。</td>
</tr>
<tr>
<td>int (*p)();</td>
<td>p 是一个函数指针，指向原型为 int func() 的函数。</td>
</tr>
</tbody></table>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>​    结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，**必须在前面加<code>&amp;</code>**，所以给 pstu 赋值只能写作： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> *<span class="title">pstu</span> =</span> &amp;stu1;</span><br></pre></td></tr></table></figure>

<p>​    还应该注意，结构体和结构体变量是两个不同的概念：结构体是一种<strong>数据类型</strong>，是一种创建变量的<strong>模板</strong>，编译器不会为它分配内存空间，就像 int、float、char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，才需要内存来存储。不可能去取一个结构体名的地址，也不能将它赋值给其他变量。</p>
<p>​    <strong>注意</strong>，要想取得结构体变量的地址，<strong>必须在前面加<code>&amp;</code>**；但是要取得</strong>结构体数组**变量的地址，就不能取地址，因为它本质上是一个数组。看下面的例子体会一下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体指针的使用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">        <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">        <span class="keyword">int</span> age;  <span class="comment">//年龄</span></span><br><span class="line">        <span class="keyword">char</span> group;  <span class="comment">//所在小组</span></span><br><span class="line">        <span class="keyword">float</span> score;  <span class="comment">//成绩</span></span><br><span class="line">    &#125; stu1 = &#123; <span class="string">&quot;Tom&quot;</span>, <span class="number">12</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">136.5</span> &#125;, *pstu = &amp;stu1;      <span class="comment">//这里必须要用&amp;取地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取结构体成员的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;</span>, (*pstu).name, (*pstu).num, (*pstu).age, (*pstu).group, (*pstu).score);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s的学号是%d，年龄是%d，在%c组，今年的成绩是%.1f！\n&quot;</span>, pstu-&gt;name, pstu-&gt;num, pstu-&gt;age, pstu-&gt;group, pstu-&gt;score);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体数组指针的使用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *name;  <span class="comment">//姓名</span></span><br><span class="line">    <span class="keyword">int</span> num;  <span class="comment">//学号</span></span><br><span class="line">    <span class="keyword">int</span> age;  <span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">char</span> group;  <span class="comment">//所在小组</span></span><br><span class="line">    <span class="keyword">float</span> score;  <span class="comment">//成绩</span></span><br><span class="line">&#125;stus[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;Zhou ping&quot;</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="string">&#x27;C&#x27;</span>, <span class="number">145.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Zhang ping&quot;</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">130.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Liu fang&quot;</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="string">&#x27;A&#x27;</span>, <span class="number">148.5</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Cheng ling&quot;</span>, <span class="number">2</span>, <span class="number">17</span>, <span class="string">&#x27;F&#x27;</span>, <span class="number">139.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Wang ming&quot;</span>, <span class="number">3</span>, <span class="number">17</span>, <span class="string">&#x27;B&#x27;</span>, <span class="number">144.5</span>&#125;</span><br><span class="line">&#125;, *ps;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//求数组长度</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(stus) / <span class="keyword">sizeof</span>(struct stu);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name\t\tNum\tAge\tGroup\tScore\t\n&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(ps=stus; ps&lt;stus+len; ps++)&#123;                       <span class="comment">//这里没用&amp;取地址</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\t%d\t%d\t%c\t%.1f\n&quot;</span>, ps-&gt;name, ps-&gt;num, ps-&gt;age, ps-&gt;group, ps-&gt;score);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h3><p>整体赋值仅限于定义结构体变量的时候，在使用过程中只能对成员逐一赋值</p>
<p>但是！</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/thisinnocence/article/details/82945938">可以用结构体变量给另一个同类型结构体变量赋值</a></p>
<h3 id="获取结构体成员"><a href="#获取结构体成员" class="headerlink" title="获取结构体成员"></a>获取结构体成员</h3><p>通过结构体指针可以获取结构体成员，一般形式为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*pointer).memberName         <span class="comment">//这边需要寻址，再获取成员，所以效率低吧</span></span><br></pre></td></tr></table></figure>

<p>或者： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pointer-&gt;memberName           <span class="comment">//好像这种效率高一点</span></span><br></pre></td></tr></table></figure>

<p>第一种写法中，<code>.</code>的优先级高于<code>*</code>，<code>(*pointer)</code>两边的括号不能少。如果去掉括号写作<code>*pointer.memberName</code>，那么就等效于<code>*(pointer.memberName)</code>，这样意义就完全不对了。</p>
<p>第二种写法中，<code>-&gt;</code>是一个新的运算符，习惯称它为“箭头”，有了它，可以通过结构体指针直接取得结构体成员；这也是<code>-&gt;</code>在C语言中的唯一用途。</p>
<p>上面的两种写法是等效的，我们<strong>通常采用后面的写法</strong>，这样更加直观。</p>
<h3 id="typedef-struct"><a href="#typedef-struct" class="headerlink" title="typedef struct"></a>typedef struct</h3><blockquote>
<p>看<code>typedef</code>声明怎么看呢，首先去掉<code>typedef</code>把它看成变量声明，看这个变量是什么类型的，那么<code>typedef</code>就定义了一个什么类型</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wzz110011/article/details/78883838">参考</a></p>
<p>结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>        <span class="comment">//定义结构体 struct Student</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">st1</span>;</span>    <span class="comment">//定义结构体变量 st1</span></span><br></pre></td></tr></table></figure>

<p>在定义结构体的同时定义结构体变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">&#125; st1, st2;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">&#125; st1, st2;            <span class="comment">//因为没有结构体名，后面就没法用该结构体定义新的变量。</span></span><br></pre></td></tr></table></figure>



<p>typedef struct：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>  <span class="comment">//定义结构体 Stu/struct Student</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line">Stu st1;                 <span class="comment">//定义结构体变量 st1</span></span><br></pre></td></tr></table></figure>

<p>或者更简单一点：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span>          <span class="comment">//定义结构体 Stu</span></span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> s;</span><br><span class="line">&#125;Stu;</span><br><span class="line"></span><br><span class="line">Stu st1;                 <span class="comment">//定义结构体变量 st1</span></span><br></pre></td></tr></table></figure>

<p>推荐使用最后一种。</p>
<p>需要注意的是，在定义链表的时候，因为在内部需要使用结构体自身，所以不能用最后一种定义，只能用第一种 typedef struct：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> elem;                <span class="comment">//代表数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link</span> * <span class="title">next</span>;</span>       <span class="comment">//代表指针域，指向直接后继元素</span></span><br><span class="line">&#125;Link;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">link_s</span>&#123;</span>        <span class="comment">//推荐这种命名方式，s: struct, t: type</span></span><br><span class="line">    <span class="keyword">char</span> elem;                <span class="comment">//代表数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">link_s</span> * <span class="title">next</span>;</span>     <span class="comment">//代表指针域，指向直接后继元素</span></span><br><span class="line">&#125;<span class="keyword">link_t</span>;</span><br></pre></td></tr></table></figure>



<p><code>typedef</code> 的另一个不好理解的<a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch16s02.html">例子</a>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef char array_t[10];</span><br><span class="line">array_t a;</span><br></pre></td></tr></table></figure>

<p>就相当于定义<code>char a[10];</code>。类型名也遵循标识符的命名规则，并且通常加个<code>_t</code>后缀，表示Type。</p>
<h3 id="结构体的递归定义"><a href="#结构体的递归定义" class="headerlink" title="结构体的递归定义"></a>结构体的递归定义</h3><p>先说结论：</p>
<p>结构体中可以递归地定义<strong>指针</strong>成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">t</span> *<span class="title">pt</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">t</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s</span> *<span class="title">ps</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>或者像这样，一个结构体也可以递归定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span> data[<span class="number">6</span>];</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p><strong>不能</strong>递归地定义<strong>变量</strong>成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是错的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">t</span> <span class="title">ot</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">t</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s</span> <span class="title">os</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://akaedu.github.io/book/ch23s09.html">解释</a></p>
<h3 id="结构体指针作为函数参数"><a href="#结构体指针作为函数参数" class="headerlink" title="结构体指针作为函数参数"></a>结构体指针作为函数参数</h3><p>​    结构体变量名代表的是整个集合本身，作为函数参数时传递的整个集合，也就是所有成员，而不是像数组一样被编译器转换成一个指针。如果结构体成员较多，尤其是成员为数组时，传送的时间和空间开销会很大，影响程序的运行效率。所以最好的办法就是使用<strong>结构体指针</strong>，这时由实参传向形参的只是一个<strong>地址</strong>，非常快速。</p>
<h3 id="C语言结构体中如何包含函数"><a href="#C语言结构体中如何包含函数" class="headerlink" title="C语言结构体中如何包含函数"></a>C语言结构体中如何包含函数</h3><p>准确地说，是包含函数指针，用函数指针来调用函数</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weibo1230123/article/details/81532318">参考</a></p>
<h3 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h3><p>枚举类型的定义形式为： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">typeName</span>&#123;</span> valueName1, valueName2, valueName3, ...... &#125;;</span><br></pre></td></tr></table></figure>

<p>例如，列出一个星期有几天： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们仅仅给出了名字，却没有给出名字对应的值，这是因为枚举值<strong>默认从 0 开始</strong>，往后<strong>逐个加 1</strong>（递增）；也就是说，week 中的 Mon、Tues …… Sun 对应的值分别为 0、1 …… 6。</p>
<p>我们也可以给每个名字都指定一个值： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues = <span class="number">2</span>, Wed = <span class="number">3</span>, Thurs = <span class="number">4</span>, Fri = <span class="number">5</span>, Sat = <span class="number">6</span>, Sun = <span class="number">7</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>更为简单的方法是只给第一个名字指定值： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br></pre></td></tr></table></figure>

<p>这样枚举值就从 1 开始递增，跟上面的写法是等效的。</p>
<p>枚举是一种类型，通过它可以定义枚举变量： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> <span class="title">a</span>, <span class="title">b</span>, <span class="title">c</span>;</span></span><br></pre></td></tr></table></figure>

<p>有了枚举变量，就可以把<strong>列表中的值</strong>赋给它： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span>&#123;</span> Mon = <span class="number">1</span>, Tues, Wed, Thurs, Fri, Sat, Sun &#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">week</span> <span class="title">a</span> =</span> Mon, b = Wed, c = Sat;</span><br></pre></td></tr></table></figure>



<p>需要注意的是：</p>
<ul>
<li><p>枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。</p>
</li>
<li><p>Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。</p>
</li>
<li><p>枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。</p>
<p>Mon、Tues、Wed 等都不是变量，它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用<code>&amp;</code>取得它们的地址。这就是枚举的本质。</p>
<p>也就是说，不占用运行时的内存。</p>
</li>
<li><p>枚举类型变量需要存放的是一个整数，它的长度和 int 应该相同。</p>
</li>
</ul>
<h3 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h3><p>​    结构体和共用体的区别在于：结构体的各个成员会占用<strong>不同</strong>的内存，互相之间没有影响；而共用体的所有成员占用<strong>同一段内存</strong>，修改一个成员会影响其余所有成员。</p>
<p>​    结构体占用的内存大于等于所有成员占用的内存的总和（成员之间<strong>可能会存在缝隙</strong>），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。</p>
<h3 id="大端小端以及判别方式"><a href="#大端小端以及判别方式" class="headerlink" title="大端小端以及判别方式"></a>大端小端以及判别方式</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/3047.html">参考</a></p>
<p>大端和小端是指数据在内存中的存储模式，它由 CPU 决定：</p>
<ol>
<li>大端模式（Big-endian）是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。这种存储模式有点儿类似于把数据当作字符串顺序处理，地址由小到大增加，而数据从高位往低位存放。<strong>网络字节序</strong> – 在网络中传播统一用这种方式</li>
<li>小端模式（Little-endian）是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。这种存储模式将地址的高低和数据的大小结合起来，高地址存放数值较大的部分，低地址存放数值较小的部分，这和我们的思维习惯是一致，比较容易理解。</li>
</ol>
<p>借助共用体，我们可以检测 CPU 是大端模式还是小端模式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">char</span> ch;</span><br><span class="line">    &#125; data;</span><br><span class="line"></span><br><span class="line">    data.n = <span class="number">0x00000001</span>;  <span class="comment">//也可以直接写作 data.n = 1;</span></span><br><span class="line">    <span class="keyword">if</span>(data.ch == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Little-endian\n&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Big-endian\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>共用体的各个成员是共用一段内存的。1 是数据的低位，如果 1 被存储在 data 的低字节，就是小端模式，这个时候 data.ch 的值也是 1。如果 1 被存储在 data 的高字节，就是大端模式，这个时候 data.ch 的值就是 0。</p>
<h3 id="位域（位段）"><a href="#位域（位段）" class="headerlink" title="位域（位段）"></a>位域（位段）</h3><p>​    有些数据在存储时并不需要占用一个完整的字节，只需要占用一个或几个二进制位即可。例如开关只有通电和断电两种状态，用 0 和 1 表示足以，也就是用一个二进位。正是基于这种考虑，C语言又提供了一种叫做<strong>位域</strong>的数据结构。</p>
<p>​    在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> m;</span><br><span class="line">    <span class="keyword">unsigned</span> n: <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> ch: <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    <code>:</code>后面的数字用来限定成员变量占用的位数。成员 m 没有限制，它占用 4 个字节（<em>Byte</em>）的内存。成员 n、ch 被<code>:</code>后面的数字限制，不能再根据数据类型计算长度，它们分别占用 4、6 位（<em>Bit</em>）的内存。</p>
<p>​    <strong>C语言标准规定</strong>，只有有限的几种数据类型可以用于位域。在 ANSI C 中，这几种数据类型是 int、signed int 和 unsigned int（int 默认就是 signed int）；到了 C99，_Bool 也被支持了。</p>
<p>​    但编译器在具体实现时<strong>都</strong>进行了扩展，额外支持了 char、signed char、unsigned char 以及 enum 类型，所以上面的代码虽然不符合C语言标准，但它依然能够被编译器支持。</p>
<p> 位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此<strong>使用<code>&amp;</code>获取位域成员的地址是没有意义的</strong>，C语言也禁止这样做。地址是字节（Byte）的编号，而不是位（Bit）的编号。</p>
<h3 id="无名位域"><a href="#无名位域" class="headerlink" title="无名位域"></a>无名位域</h3><p>位域成员可以没有名称，只给出数据类型和位宽：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bs</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m: <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">int</span>  : <span class="number">20</span>;  <span class="comment">//该位域成员不能使用</span></span><br><span class="line">    <span class="keyword">int</span> n: <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>无名位域一般用来作填充或者调整成员位置。因为没有名称，无名位域不能使用。</p>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><h4 id="按位与运算（-amp-）"><a href="#按位与运算（-amp-）" class="headerlink" title="按位与运算（&amp;）"></a>按位与运算（&amp;）</h4><p>​    按位与运算通常用来对某些位<strong>清 0</strong>，或者保留某些位。例如要把 n 的高 16 位清 0 ，保留低 16 位，可以进行<code>n &amp; 0XFFFF</code>运算（0XFFFF 在内存中的存储形式为 0000 0000 – 0000 0000 – 1111 1111 – 1111 1111）。</p>
<p>​    <code>&amp;</code>是<strong>根据内存中的二进制位进行运算</strong>的(补码)，而不是数据的二进制形式；其他位运算符也一样。以<code>-9&amp;5</code>为例，-9 的在内存中的存储和 -9 的二进制形式截然不同： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1111</span> <span class="number">1111</span> -- <span class="number">1111</span> <span class="number">1111</span> -- <span class="number">1111</span> <span class="number">1111</span> -- <span class="number">1111</span> <span class="number">0111</span>  （<span class="number">-9</span> 在内存中的存储）</span><br><span class="line"><span class="number">-0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">0000</span> -- <span class="number">0000</span> <span class="number">1001</span>  （<span class="number">-9</span> 的二进制形式，前面多余的 <span class="number">0</span> 可以抹掉）</span><br></pre></td></tr></table></figure>



<h4 id="按位或运算（-）"><a href="#按位或运算（-）" class="headerlink" title="按位或运算（|）"></a>按位或运算（|）</h4><p>​    按位或运算可以用来将某些位<strong>置 1</strong>，或者保留某些位。例如要把 n 的高 16 位置 1，保留低 16 位，可以进行<code>n | 0XFFFF0000</code>运算（0XFFFF0000 在内存中的存储形式为 1111 1111 – 1111 1111 – 0000 0000 – 0000 0000）。</p>
<h4 id="按位异或运算（-）"><a href="#按位异或运算（-）" class="headerlink" title="按位异或运算（^）"></a>按位异或运算（^）</h4><p>​    按位异或运算可以用来将某些二进制位<strong>反转</strong>。例如要把 n 的高 16 位反转，保留低 16 位，可以进行n ^ 0XFFFF0000运算（0XFFFF0000 在内存中的存储形式为 1111 1111 – 1111 1111 – 0000 0000 – 0000 0000）。</p>
<h2 id="重要知识点补充"><a href="#重要知识点补充" class="headerlink" title="重要知识点补充"></a>重要知识点补充</h2><h3 id="C语言预处理运算符-、-、"><a href="#C语言预处理运算符-、-、" class="headerlink" title="C语言预处理运算符 #、##、#@"></a>C语言预处理运算符 <code>#</code>、<code>##</code>、<code>#@</code></h3><p>apue 7.11 fig7.16 中提到了字符串创建算符 <code>#</code>。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/1487.html">这里</a>也有写到</p>
<h4 id="字符串化运算符"><a href="#字符串化运算符" class="headerlink" title="字符串化运算符 #"></a>字符串化运算符 <code>#</code></h4><p>用于创建字符串，#运算符后面应该跟一个形参（中间可以有空格或Tab），例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STR(s) #s  </span></span><br><span class="line"><span class="built_in">puts</span>(STR(Here is a Demo)); <span class="comment">// 相当于puts(&quot;Here is a Demo&quot;); </span></span><br></pre></td></tr></table></figure>

<p>常用实例，我们在调试代码的时候有时需要打印一些字符串的值，如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Dump_Str(s) printf(<span class="meta-string">&quot;%s = %s\n&quot;</span>,#s,s);</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> * pchName = <span class="string">&quot;Gui xue&quot;</span>;</span><br><span class="line">        Dump_Str(pchName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符 ##"></a>连接运算符 <code>##</code></h4><p>用于将两个Token连接成一个Token。这里提到一个需要概念Token ，先说明一下什么是Token。</p>
<p>人与人之间的沟通，通过说话，而每句话便是由单词组合在一起，形成特定的语义。这里的单词便可理解成 Token。</p>
<p>C语言编译器相当于一个翻译，要懂两种语言——C语言和机器语言；它的工作是将C语言翻译成机器语言。首先它应该读懂C语言中的“句子”，而对整个“句子”的理解，是建立在对每个“单词”理解的基础上的，所以首先我们要把句子分成多个单词——分词。</p>
<p>词法分析便是将C语言的“句子”按照词法规则拆分成 Token 序列。例如：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __CONCAT(x,y)   x ## y</span></span><br><span class="line"><span class="keyword">int</span>  n1 =<span class="number">15</span>;</span><br><span class="line"><span class="keyword">int</span>  n2 =<span class="number">200</span>;</span><br><span class="line">__CONCAT(n,<span class="number">1</span>); <span class="comment">// n1</span></span><br><span class="line">__CONCAT(n,<span class="number">2</span>); <span class="comment">// n2</span></span><br></pre></td></tr></table></figure>

<h4 id="字符化运算符"><a href="#字符化运算符" class="headerlink" title="字符化运算符 #@"></a>字符化运算符 <code>#@</code></h4><p>gcc 不支持，不写了，自己看</p>
<h3 id="typedef-和-define-的区别"><a href="#typedef-和-define-的区别" class="headerlink" title="typedef 和 #define 的区别"></a>typedef 和 #define 的区别</h3><p>​    typedef 在表现上有时候类似于 #define，但它和宏替换之间存在一个关键性的区别。正确思考这个问题的方法就是把 typedef 看成一种彻底的“封装”类型，声明之后不能再往里面增加别的东西。</p>
<ol>
<li><p>可以使用其他类型说明符对宏类型名进行扩展，但对 typedef 所定义的类型名却不能这样做。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERGE int</span></span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;  <span class="comment">//没问题</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> INTERGE;</span><br><span class="line"><span class="keyword">unsigned</span> INTERGE n;  <span class="comment">//错误，不能在 INTERGE 前面添加 unsigned</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在连续定义几个变量的时候，typedef 能够保证定义的所有变量均为同一类型，而 #define 则无法保证。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PTR_INT int *</span></span><br><span class="line">PTR_INT p1, p2;</span><br></pre></td></tr></table></figure>

<p>经过宏替换以后，第二行变为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, p2;</span><br></pre></td></tr></table></figure>

<p>这使得 p1、p2 成为不同的类型：p1 是指向 int 类型的指针，p2 是 int 类型。</p>
<p>相反，在下面的代码中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * PTR_INT</span><br><span class="line">PTR_INT p1, p2;</span><br></pre></td></tr></table></figure>

<p>p1、p2 类型相同，它们都是指向 int 类型的指针。</p>
</li>
</ol>
<h3 id="const-和指针"><a href="#const-和指针" class="headerlink" title="const 和指针"></a>const 和指针</h3><p>​    <code>const</code> 也可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。const 和指针一起使用会有几种不同的顺序，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> *p2;  <span class="comment">//这两个一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p3;</span><br></pre></td></tr></table></figure>

<p>​    在最后一种情况下，指针是只读的，也就是 p3 本身的值不能被修改；在前面两种情况下，指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。</p>
<p>​    当然，指针本身和它指向的数据都有可能是只读的，下面的两种写法能够做到这一点： </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> * <span class="keyword">const</span> p4;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * <span class="keyword">const</span> p5;</span><br></pre></td></tr></table></figure>

<p>​    const 和指针结合的写法多少有点让初学者摸不着头脑，大家可以这样来记忆：const 离变量名近就是用来修饰指针变量的，离变量名远就是用来修饰指针指向的数据，如果近的和远的都有，那么就同时修饰指针变量以及它指向的数据。 </p>
<p>​    如果 <code>const</code> 在 <code>int</code> 和 <code>p</code> 中间，那么它就是修饰 <code>p</code> 的，也就是指针本身不能变；如果 <code>const</code> 在 <code>* p</code> 前面，那么它就是修饰 <code>* p</code> 的，<code>* p</code> 是寻址，也就是 <code>p</code> 指向的数据不能变。如果有两个，那就是两个都不能变喽。</p>
<p>​    不需要去管 <code>int</code> 的位置，因为它与 <code>const</code> 是可以互换的。</p>
<p>注意，如果要定义一个指针指向字符串字面值，这个指针应该是<code>const char *</code>型，如果写成<code>char *p = &quot;abcd&quot;;</code>就不好了，有隐患，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">	char *p &#x3D; &quot;abcd&quot;;   &#x2F;&#x2F; const char *p &#x3D; ..</span><br><span class="line">...</span><br><span class="line">	*p &#x3D; &#39;A&#39;;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>p</code>指向<code>.rodata</code>段，不允许改写，但编译器不会报错，在运行时会出现段错误。</p>
<h3 id="const-和函数形参"><a href="#const-和函数形参" class="headerlink" title="const 和函数形参"></a>const 和函数形参</h3><p>​    在C语言中，单独定义 const 变量没有明显的优势，完全可以使用#define命令代替。const <strong>通常用在函数形参中</strong>，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。</p>
<h3 id="const-和非-const-类型转换"><a href="#const-和非-const-类型转换" class="headerlink" title="const 和非 const 类型转换"></a>const 和非 const 类型转换</h3><p>​    当一个指针变量 str1 被 const 限制时，并且类似<code>const char *str1</code>这种形式，说明指针指向的数据不能被修改；如果将 str1 赋值给另外一个未被 const 修饰的指针变量 str2，就有可能发生危险。因为通过 str1 不能修改数据，而赋值后通过 str2 能够修改数据了，意义发生了转变，所以编译器不提倡这种行为，会给出错误或警告。</p>
<p>​    也就是说，<code>const char *</code>和<code>char *</code>是不同的类型，不能将<code>const char *</code>类型的数据赋值给<code>char *</code>类型的变量。但反过来是可以的，编译器允许将<code>char *</code>类型的数据赋值给<code>const char *</code>类型的变量。</p>
<h3 id="生成一定范围内的随机数"><a href="#生成一定范围内的随机数" class="headerlink" title="生成一定范围内的随机数"></a>生成一定范围内的随机数</h3><p>​    在实际开发中，我们往往需要一定范围内的随机数，过大或者过小都不符合要求，那么，如何产生一定范围的随机数呢？我们可以利用取模的方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">10</span>;    <span class="comment">//产生0~9的随机数，注意10会被整除</span></span><br></pre></td></tr></table></figure>

<p>​    如果要规定上下限：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = rand() % <span class="number">51</span> + <span class="number">13</span>;    <span class="comment">//产生13~63的随机数</span></span><br></pre></td></tr></table></figure>

<p>​    分析：取模即取余，<code>rand()%51+13</code>我们可以看成两部分：<code>rand()%51</code>是产生 0~50 的随机数，后面<code>+13</code>保证 a 最小只能是 13，最大就是 50+13=63。</p>
<p>​    最后给出产生 13~63 范围内随机数的完整代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    a = rand() % <span class="number">51</span> + <span class="number">13</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="变长数组-1"><a href="#变长数组-1" class="headerlink" title="变长数组"></a>变长数组</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/view/vip_1837.html">参考</a></p>
<p>C99 可以这么写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">int</span> arr[n];</span><br></pre></td></tr></table></figure>

<p>但是不能这样写：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> arr[n];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br></pre></td></tr></table></figure>

<p>这种变长数组其实也是静态数组，虽然内存是在运行期间分配内存，但是一旦定义，它的长度就不能变了</p>
<p>还有一篇<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43760909/article/details/87936133">文章</a></p>
<h2 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h2><h3 id="fopen-函数的返回值"><a href="#fopen-函数的返回值" class="headerlink" title="fopen() 函数的返回值"></a>fopen() 函数的返回值</h3><p>fopen() 会获取文件信息，包括文件名、文件状态、当前读写位置等，并将这些信息保存到一个 FILE 类型的结构体变量中，然后将该变量的地址返回。</p>
<p>如果希望接收 fopen() 的返回值，就需要定义一个 FILE 类型的指针。例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(<span class="string">&quot;demo.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">FILE *fp = fopen(<span class="string">&quot;D:\\demo.txt&quot;</span>,<span class="string">&quot;rb+&quot;</span>);  <span class="comment">//以二进制方式打开 D 盘下的 demo.txt 文件，允许读和写。 </span></span><br></pre></td></tr></table></figure>

<p>表示以“只读”方式打开当前目录下的 demo.txt 文件，并使 fp 指向该文件，这样就可以通过 fp 来操作 demo.txt 了。fp 通常被称为文件指针。</p>
<h3 id="判断文件是否打开成功"><a href="#判断文件是否打开成功" class="headerlink" title="判断文件是否打开成功"></a>判断文件是否打开成功</h3><p>打开文件出错时，fopen() 将返回一个空指针，也就是 NULL，我们可以利用这一点来判断文件是否打开成功。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line"><span class="keyword">if</span>( (fp=fopen(<span class="string">&quot;D:\\demo.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>) == <span class="literal">NULL</span> )&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Fail to open file!\n&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">//退出程序（结束程序）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码是文件操作的规范写法，在打开文件时一定要判断文件是否打开成功，因为一旦打开失败，后续操作就都没法进行了，往往以“结束程序”告终。</p>
<h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>文件一旦使用完毕，应该用 fclose() 函数把文件关闭，以释放相关资源，避免数据丢失。fclose() 的用法为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>文件正常关闭时，fclose() 的返回值为0，如果返回非零值则表示有错误发生。</p>
<h3 id="文本文件和二进制文件的区别"><a href="#文本文件和二进制文件的区别" class="headerlink" title="文本文件和二进制文件的区别"></a>文本文件和二进制文件的区别</h3><p>​    根据我们以往的经验，文本文件通常用来保存肉眼可见的字符，比如<code>.txt</code>文件、<code>.c</code>文件、<code>.dat</code>文件等，用文本编辑器打开这些文件，我们能够顺利看懂文件的内容。<br>​    二进制文件通常用来保存视频、图片、程序等不可阅读的内容，用文本编辑器打开这些文件，会看到一堆乱码，根本看不懂。</p>
<h3 id="fopen-中的文本方式和二进制方式"><a href="#fopen-中的文本方式和二进制方式" class="headerlink" title="fopen() 中的文本方式和二进制方式"></a>fopen() 中的文本方式和二进制方式</h3><p>在C语言中，二进制方式很简单，读取文件时，会原封不动的读出文件的全部內容，写入数据时，也是把缓冲区中的內容原封不动的写到文件中。</p>
<p>文本方式和二进制方式并没有本质上的区别，只是对于换行符的处理不同。</p>
<p>C语言程序将<code>\n</code>作为换行符，类 UNIX/Linux 系统在处理文本文件时也将<code>\n</code>作为换行符，所以程序中的数据会原封不动地写入文本文件中，反之亦然。</p>
<p>但是 Windows 系统却不同，它将<code>\r\n</code>作为文本文件的换行符。<br>在 Windows 系统中，如果以文本方式打开文件，当读取文件时，程序会将文件中所有的<code>\r\n</code>转换成一个字符<code>\n</code>。也就是说，如果文本文件中有连续的两个字符是<code>\r\n</code>，则程序会丢弃前面的<code>\r</code>，只读入<code>\n</code>。<br>当写入文件时，程序会将<code>\n</code>转换成<code>\r\n</code>写入。也就是说，如果要写入的内容中有字符<code>\n</code>，则在写入该字符前，程序会自动先写入一个<code>\r</code>。<br>因此，如果用文本方式打开二进制文件进行读写，读写的内容就可能和文件的内容有出入。</p>
<p><strong>总起来说</strong>，对于 Windows 平台，为了保险起见，我们最好用<code>&quot;r&quot;</code>来打开文本文件，用<code>&quot;b&quot;</code>来打开二进制文件。对于 Linux 平台，使用<code>&quot;r&quot;</code>还是<code>&quot;b&quot;</code>都无所谓，既然默认是<code>&quot;r&quot;</code>，那我们什么都不写就行了。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>在C语言中，指针变量的值就是一个内存地址，<code>&amp;</code>运算符的作用也是取变量的内存地址。</p>
<p>但是这些地址都是虚拟地址，虚拟地址通过CPU的转换才能对应到物理地址，而且每次程序运行时，操作系统都会重新安排虚拟地址和物理地址的对应关系，哪一段物理内存空闲就使用哪一段。</p>
<p>除了在编程时可以使用固定的内存地址，<strong>给程序员带来方便</strong>外，使用虚拟地址还能够<strong>使不同程序的地址空间相互隔离</strong>，提高内存使用效率。</p>
<p>如果所有程序都直接使用物理内存，那么程序所使用的地址空间不是相互隔离的。恶意程序可以很容易改写其他程序的内存数据，以达到破坏的目的；有些非恶意、但是有 Bug 的程序也可能会不小心修改其他程序的数据，导致其他程序崩溃。</p>
<h3 id="中间层思想"><a href="#中间层思想" class="headerlink" title="中间层思想"></a>中间层思想</h3><p>在计算机中，为了让操作更加直观、易于理解、增强用户体验，开发者经常会使用一件法宝——<em>增加中间层</em>，即使用一种间接的方式来屏蔽复杂的底层细节，只给用户提供简单的接口。虚拟地址是使用中间层的一个典型例子。</p>
<p>实际上，计算机的整个发展过程就是不断引入新的中间层： </p>
<ul>
<li>计算机的早期，程序都是直接运行在硬件之上，自己负责硬件的管理工作；程序员也使用二进制进行编程，需要处理各种边界条件和安全问题。</li>
<li>后来人们不能忍受了，于是开发出了操作系统，让它来管理各种硬件，同时发明了汇编语言，减轻程序员的负担。</li>
<li>随着软件规模的不断增大，使用汇编语言编程开始变得捉襟见肘，不仅学习成本高，开发效率也很低，于是C语言诞生了。C语言编译器先将C代码翻译为汇编代码，再由汇编器将汇编代码翻译成机器指令。</li>
<li>随着计算机的发展，硬件越来越强大，软件越来越复杂，人们又不满足于使用C语言了，于是 C++、Java、C#、PHP 等现代化的编程语言诞生了。</li>
</ul>
<h3 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h3><p>CPU 通过地址总线来访问内存，一次能处理几个字节的数据，就命令地址总线读取几个字节的数据。32 位的 CPU 一次可以处理4个字节的数据，那么每次就从内存读取4个字节的数据；少了浪费主频，多了没有用。64位的处理器也是这个道理，每次读取8个字节。</p>
<p>对于程序来说，一个变量最好位于一个寻址步长的范围内，这样一次就可以读取到变量的值；如果跨步长存储，就需要读取两次，然后再拼接数据，效率显然降低了。</p>
<p>将一个数据尽量放在一个步长之内，避免跨步长存储，这称为<strong>内存对齐</strong>。在32位编译模式下，默认以4字节对齐；在64位编译模式下，默认以8字节对齐。</p>
<p>编译器之所以要内存对齐，是为了更加高效的存取成员，而代价就是浪费了一部分空间。</p>
<p>对于<strong>全局变量</strong>，GCC在 Debug 和 Release 模式下都会进行内存对齐，而VS只有在 Release 模式下才会进行对齐。</p>
<p>而对于<strong>局部变量</strong>，GCC和VS都不会进行对齐，不管是Debug模式还是Release模式。</p>
<h3 id="C语言程序的内存布局"><a href="#C语言程序的内存布局" class="headerlink" title="C语言程序的内存布局"></a>C语言程序的内存布局</h3><p>对于32位环境，理论上程序可以拥有 4GB 的虚拟地址空间，我们在C语言中使用到的变量、函数、字符串等都会对应内存中的一块区域。</p>
<p>但是，在这 4GB 的地址空间中，要拿出一部分给操作系统内核使用，应用程序无法直接访问这一段内存，这一部分内存地址被称为<strong>内核空间</strong>（Kernel Space）。</p>
<p>Windows 在默认情况下会将高地址的 2GB 空间分配给内核（也可以配置为 1GB），而 Linux 默认情况下会将高地址的 1GB 空间分配给内核。也就是说，应用程序只能使用剩下的 2GB 或 3GB 的地址空间，称为<strong>用户空间</strong>（User Space）。 </p>
<p>Linux 下 32 位环境的一种经典内存模型：</p>
<p><img src="/passages/Learning-notes/190716_141748.jpg" alt="Linux下32位环境的一种经典内存模型"></p>
<p>对各个内存分区的说明：</p>
<table>
<thead>
<tr>
<th align="center">内存分区</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">程序代码区 (code)</td>
<td>存放函数体的二进制代码。一个C语言程序由多个函数构成，C语言程序的执行就是函数之间的相互调用。</td>
</tr>
<tr>
<td align="center">常量区     (constant)</td>
<td>存放一般的常量、字符串常量等。这块内存只有读取权限，没有写入权限，因此它们的值在程序运行期间不能改变。</td>
</tr>
<tr>
<td align="center">全局数据区 (global data)</td>
<td>存放全局变量、静态变量等。这块内存有读写权限，因此它们的值在程序运行期间可以任意改变。</td>
</tr>
<tr>
<td align="center">堆区(heap)</td>
<td>一般由程序员分配和释放，若程序员不释放，程序运行结束时由操作系统回收。malloc()、calloc()、free() 等函数操作的就是这块内存。  <br>注意：这里所说的堆区与数据结构中的堆不是一个概念，堆区的分配方式倒是类似于链表。</td>
</tr>
<tr>
<td align="center">动态链接库</td>
<td>用于在程序运行期间加载和卸载动态链接库。</td>
</tr>
<tr>
<td align="center">栈区(stack)</td>
<td>存放函数的参数值、局部变量的值等，其操作方式类似于数据结构中的栈。</td>
</tr>
</tbody></table>
<p>程序代码区、常量区、全局数据区在程序加载到内存后就分配好了，并且在程序运行期间一直存在，不能销毁也不能增加（大小已被固定），只能等到程序运行结束后由操作系统收回，所以全局变量、字符串常量等在程序的任何地方都能访问，因为它们的内存一直都在。</p>
<p>函数被调用时，会将参数、局部变量、返回地址等与函数相关的信息压入栈中，函数执行结束后，这些信息都将被销毁。所以局部变量、参数只在当前函数中有效，不能传递到函数外部，因为它们的内存不在了。</p>
<p>常量区、全局数据区、栈上的内存由系统自动分配和释放，不能由程序员控制。程序员唯一能控制的内存区域就是堆（Heap）：它是一块巨大的内存空间，常常占据整个虚拟空间的绝大部分，在这片空间中，程序可以申请一块内存，并自由地使用（放入任何数据）。堆内存在程序主动释放之前会一直存在，不随函数的结束而失效。在函数内部产生的数据只要放到堆中，就可以在函数外部使用。</p>
<p>例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *str1 = <span class="string">&quot;c.biancheng.net&quot;</span>;  <span class="comment">//字符串在常量区，str1在全局数据区</span></span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//全局数据区</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = <span class="string">&quot;C语言中文网&quot;</span>;  <span class="comment">//字符串在常量区，str在栈区</span></span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;  <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">char</span> *str2 = <span class="string">&quot;01234&quot;</span>;  <span class="comment">//字符串在常量区，str2在栈区</span></span><br><span class="line">    <span class="keyword">char</span>  arr[<span class="number">20</span>] = <span class="string">&quot;56789&quot;</span>;  <span class="comment">//字符串和arr都在栈区       /* 这里需要注意 */</span></span><br><span class="line">    <span class="keyword">char</span> *pstr = func();  <span class="comment">//栈区</span></span><br><span class="line">    <span class="keyword">int</span> b;  <span class="comment">//栈区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str1: %#X\npstr: %#X\nstr2: %#X\n&quot;</span>, str1, pstr, str2);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;str1: %#X\n   &amp;n: %#X\n&quot;</span>, &amp;str1, &amp;n);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  &amp;a: %#X\n arr: %#X\n  &amp;b: %#X\n&quot;</span>, &amp;a, arr, &amp;b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n: %d\na :%d\nb: %d\n&quot;</span>, n, a, b);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;--------------&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, pstr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对代码的说明：</p>
<ol>
<li>全局变量的内存在编译时就已经分配好了，它的默认初始值是 0（它所占用的每一个字节都是0值），局部变量的内存在函数调用时分配，它默认初始值是不确定的，由编译器决定，一般是垃圾值。</li>
<li>函数 func() 中的局部字符串常量<code>&quot;C语言中文网&quot;</code>也被存储到常量区，不会随着 func() 的运行结束而销毁，所以最后依然能够输出。</li>
<li>字符数组 arr[20] 在栈区分配内存，字符串<code>&quot;56789&quot;</code>就保存在这块内存中，<strong>而不是在常量区</strong>，大家要注意区分。</li>
</ol>
<h3 id="栈溢出攻击-数组溢出"><a href="#栈溢出攻击-数组溢出" class="headerlink" title="栈溢出攻击(数组溢出)"></a>栈溢出攻击(数组溢出)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    gets(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str: %s\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输出的字符超过9个，就会发生数组溢出，把其他数据覆盖掉。</p>
<p>局部数组在栈上分配内存，并且不对数组溢出做检测，这是导致栈溢出的根源。除了上面讲到的 gets() 函数，strcpy()、scanf() 等能够向数组写入数据的函数都有导致栈溢出的风险。</p>
<h3 id="指向释放掉的内存"><a href="#指向释放掉的内存" class="headerlink" title="指向释放掉的内存"></a>指向释放掉的内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">&quot;C语言中文网&quot;</span>);</span><br><span class="line">    <span class="built_in">puts</span>(str);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line">    <span class="keyword">if</span>(str)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，第一次输出<code>C语言中文网</code>，第二次输出的是乱码或者什么也不输出。这是因为，freed() 只是释放掉了动态分配的内存，但并未改变 str 的值，str 的值不是 NULL，它仍然指向被释放掉的内存，所以会执行 if 语句里面的 puts() 函数。但由于此时的内存已经被释放掉了，原来的字符串已经不在了，所以输出的数据是未知的。</p>
<p>这就提醒我们，<strong>使用 free() 释放内存的同时要将指针置为<code>NULL</code>，否则下次就无法判断指向的内存是否有效</strong>。</p>
<h3 id="函数外部指针指向函数内部的变量、数组"><a href="#函数外部指针指向函数内部的变量、数组" class="headerlink" title="函数外部指针指向函数内部的变量、数组"></a>函数外部指针指向函数内部的变量、数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> **pp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *pstr;</span><br><span class="line">    func(&amp;pstr);           <span class="comment">//这里是取指针pstr的指针，二级指针</span></span><br><span class="line">    <span class="built_in">puts</span>(pstr);            <span class="comment">//这里的pstr指向arr，但是arr已经没有了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">char</span> **pp)</span></span>&#123;      <span class="comment">//pp是二级指针</span></span><br><span class="line">    <span class="keyword">char</span> arr[] = <span class="string">&quot;C语言中文网&quot;</span>;     <span class="comment">//这里的字符串存在栈区，函数结束就会被释放</span></span><br><span class="line">    *pp = arr;             <span class="comment">//*pp是pstr，相当于 pstr = arr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arr 数组在栈上分配内存，字符串<code>&quot;C语言中文网&quot;</code>就存储在这里，func() 函数运行结束后，这块内存被释放掉，但是函数外部的 pstr 仍然指向这里，所以执行<code>puts(pstr);</code>时，输出结果是未知的。</p>
<h3 id="内存泄露（Memory-Leak）"><a href="#内存泄露（Memory-Leak）" class="headerlink" title="内存泄露（Memory Leak）"></a>内存泄露（Memory Leak）</h3><p>使用 malloc()、calloc()、realloc() 动态分配的内存，如果没有指针指向它，就无法进行任何操作，这段内存会一直被程序占用，直到程序运行结束由操作系统回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    p = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">50</span> * <span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该程序中，第一次分配 100 字节的内存，并将 p 指向它；第二次分配 50 字节的内存，依然使用 p 指向它。</p>
<p>这就导致了一个问题，第一次分配的 100 字节的内存没有指针指向它了，而且我们也不知道这块内存的地址，所以就再也无法找回了，也没法释放了，这块内存就成了垃圾内存，虽然毫无用处，但依然占用资源，唯一的办法就是等程序运行结束后由操作系统回收。</p>
<p><strong>这就是内存泄露（Memory Leak），可以理解为程序和内存失去了联系，再也无法对它进行任何操作。</strong></p>
<h3 id="变量的存储类别和生存期"><a href="#变量的存储类别和生存期" class="headerlink" title="变量的存储类别和生存期"></a>变量的存储类别和生存期</h3><p>我们可以通过C语言中的关键字来控制变量的存放区域。C语言共有 4 个关键字用来指明变量的存储类别：<strong>auto</strong>（自动的）、<strong>static</strong>（静态的）、<strong>register</strong>（寄存器的）、<strong>extern</strong>（外部的）。</p>
<p>知道了变量的存储类别，就可以知道变量的生存期。通俗地讲，生存期指的是在程序运行过程中，变量从创建到销毁的一段时间，<strong>生存期的长短取决于变量的存储类别</strong>，也就是它所在的内存区域。</p>
<h4 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h4><p>auto 是自动或默认的意思，很少用到，因为所有的变量默认就是 auto 的。也就是说，定义变量时加不加 auto 都一样，所以一般把它省略，不必多此一举。</p>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p>static 声明的变量称为静态变量，不管它是全局的还是局部的，都存储在静态数据区（全局变量本来就存储在静态数据区，即使不加 static）。</p>
<p>静态数据区的数据在程序启动时就会初始化，直到程序运行结束；对于代码块中的静态局部变量，即使代码块执行结束，也不会销毁。</p>
<p><strong>注意：静态数据区的变量只能初始化（定义）一次，以后只能改变它的值，不能再被初始化，即使有这样的语句，也无效。</strong></p>
<p>因为全局数据区的数据在程序启动时就被初始化，所以不能再次初始化。一直到程序运行结束才会被操作系统回收内存。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result, i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i&lt;=<span class="number">100</span>; i++)&#123;</span><br><span class="line">        result = sum(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;1+2+3+...+99+100 = %d\n&quot;</span>, result);</span><br><span class="line"></span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 也可以不赋初值 0，静态数据区的变量默认初始化为 0</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    result += n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在 sum() 中定义了一个静态局部变量 result，它存储在静态数据区，sum() 函数执行结束也不会销毁，下次调用继续有效。静态数据区的变量只能初始化一次，第一次调用 sum() 时已经对 result 进行了初始化，所以再次调用时就不会初始化了，也就是说 static int result = 0; 语句无效。</p>
<p>静态局部变量虽然存储在静态数据区，但是它的作用域仅限于定义它的代码块，sum() 中的 result 在函数外无效，与 main() 中的 result 不冲突，除了变量名一样，没有任何关系。</p>
<p>静态数据区的变量只能初始化（定义）<strong>一次</strong>，这句话很重要。看例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Caculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> iSum=<span class="number">3</span>;  <span class="comment">//这条语句只会在第一次调用的时候生效，第二次会被忽略</span></span><br><span class="line">    <span class="keyword">int</span> iTemp;</span><br><span class="line">    iTemp=iSum;         <span class="comment">//iSum是静态变量</span></span><br><span class="line">    iSum=iTemp*<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,iSum);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Caculate();        <span class="comment">//得到iSum的平方</span></span><br><span class="line">    Caculate();        <span class="comment">//得到iSum的立方</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">9</span><br><span class="line">27</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>

<p><code>static</code> 还可以修饰<a href="#static%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0">static 全局变量</a></p>
<h4 id="register"><a href="#register" class="headerlink" title="register"></a>register</h4><p>一般情况下，变量的值是存储在内存中的，CPU 每次使用数据都要从内存中读取。如果有一些变量使用非常频繁，从内存中读取就会消耗很多时间，例如 for 循环中的增量控制 <code>i</code> 。</p>
<p>为了解决这个问题，可以将使用频繁的变量放在CPU的通用寄存器中，这样使用该变量时就不必访问内存，直接从寄存器中读取，大大提高程序的运行效率。</p>
<p>不过寄存器的数量是有限的，通常是把使用最频繁的变量定义为 register 的。</p>
<p>关于寄存器变量有以下事项需要注意：</p>
<ol>
<li>为寄存器变量分配寄存器是动态完成的，因此，只有局部变量和形式参数才能定义为寄存器变量。</li>
<li>局部静态变量不能定义为寄存器变量，因为一个变量只能声明为一种存储类别。</li>
<li>寄存器的长度一般和机器的字长一致，只有较短的类型如 int、char、short 等才适合定义为寄存器变量，诸如 double 等较大的类型，不推荐将其定义为寄存器类型。</li>
<li>CPU的寄存器数目有限，即使定义了寄存器变量，编译器可能并不真正为其分配寄存器，而是将其当做普通的auto变量来对待，为其分配栈内存。当然，有些优秀的编译器，能自动识别使用频繁的变量，如循环控制变量等，在有可用的寄存器时，即使没有使用 register 关键字，也自动为其分配寄存器，无须由程序员来指定。</li>
</ol>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangguang-it/p/6719261.html">参考1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/23014322">参考2</a></p>
<h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><h3 id="extern关键字"><a href="#extern关键字" class="headerlink" title="extern关键字"></a>extern关键字</h3><p> <code>extern</code> 关键字，它用来声明一个变量或函数。</p>
<p>C语言代码是由上到下依次执行的，不管是变量还是函数，原则上都要先定义再使用，否则就会报错。但在实际开发中，经常会在函数或变量定义之前就使用它们，这个时候就需要提前声明。</p>
<p>所谓声明（Declaration），就是告诉编译器我要使用这个变量或函数，你现在没有找到它的定义不要紧，请不要报错，稍后我会把定义补上。</p>
<ol>
<li><p>函数声明</p>
<p>对于函数声明来说，有没有 extern 都是一样的。</p>
<p>总结起来，函数声明有四种形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不使用 extern</span></span><br><span class="line"><span class="function">datatype <span class="title">function</span><span class="params">( datatype1 name1, datatype2 name2, ... )</span></span>;</span><br><span class="line"><span class="function">datatype <span class="title">function</span><span class="params">( datatype1, datatype2, ... )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用 extern</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> datatype <span class="title">function</span><span class="params">( datatype1 name1, datatype2 name2, ... )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> datatype <span class="title">function</span><span class="params">( datatype1, datatype2, ... )</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>变量声明</p>
<p>变量和函数不同，编译器只能根据 extern 来区分，有 extern 才是声明，没有 extern 就是定义。</p>
<p>变量的<strong>定义</strong>有两种形式，你可以在定义的同时初始化，也可以不初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datatype name = value;</span><br><span class="line">datatype name; </span><br></pre></td></tr></table></figure>

<p>而变量的<strong>声明</strong>只有一种形式，就是使用 extern 关键字：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> datatype name;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>extern 是“外部”的意思，很多教材讲到，extern 用来声明一个外部（其他文件中）的变量或函数，也就是说，变量或函数的定义在其他文件中。</p>
<p>但是这样讲不妥，因为除了定义在外部，定义在当前文件中也是正确的。例如，将 module.c 中的<code>int m = 100;</code>移动到 main.c 中的任意位置都是可以的。所以，<strong>extern 是用来声明的，不管具体的定义是在当前文件内部还是外部，都是正确的。</strong></p>
<h3 id="Windows和Linux下的可执行文件格式"><a href="#Windows和Linux下的可执行文件格式" class="headerlink" title="Windows和Linux下的可执行文件格式"></a>Windows和Linux下的可执行文件格式</h3><p>现在PC平台上流行的可执行文件格式主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format），它们都是 COFF（Common File Format）格式的变种。</p>
<p>COFF 是 Unix V3首先提出的规范，微软在此基础上制定了 PE 格式标准，并将它用于 Windows。后来 Unix V4 又在 COFF 的基础上引入了 ELF 格式，被 Linux 广泛使用。这也就是为什么 Windows 和 Linux 上的可执行文件如此相似的主要原因，因为它们都是源于同一种可执行文件格式 COFF。</p>
<p>从广义上讲，目标文件与可执行文件的存储格式几乎是一样的，我们可以将它们看成是同一种类型的文件，在 Windows 下，将它们统称为 PE 文件，在 Linux 下，将它们统称为 ELF文件。</p>
<p>另外，动态链接库（DLL，Dynamic Linking Library）（Windows 下的<code>.dll</code>和 Linux 下的<code>.so</code>）和静态链接库（Static Linking Library）（Windows 下的<code>.lib</code>和 Linux 下的<code>.a</code>）也是按照可执行文件的格式存储的。</p>
<p>静态链接库稍有不同，它是把多个目标文件捆绑在一起形成一个文件，再加上一些索引，你可以简单地把它理解为一个包含了很多目标文件的包。</p>
<h3 id="强符号和弱符号"><a href="#强符号和弱符号" class="headerlink" title="强符号和弱符号"></a>强符号和弱符号</h3><p>我们在编写代码的过程中经常会遇到一种叫做符号重复定义（Multiple Definition）的错误，这是因为在多个源文件中定义了名字相同的全局变量，并且都将它们初始化了。</p>
<p>在C语言中，编译器默认函数和初始化了的全局变量为强符号（Strong Symbol），未初始化的全局变量为弱符号（Weak Symbol）。强符号之所以强，是因为它们拥有确切的数据，变量有值，函数有函数体；弱符号之所以弱，是因为它们还未被初始化，没有确切的数据。</p>
<p>未初始化的全局变量指的是虽然定义了，但是没有给它赋值。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> weak1;</span><br></pre></td></tr></table></figure>

<p>链接器会按照如下的规则处理被多次定义的强符号和弱符号：</p>
<ol>
<li>不允许强符号被多次定义，也即不同的目标文件中不能有同名的强符号；如果有多个强符号，那么链接器会报符号重复定义错误。</li>
<li>如果一个符号在某个目标文件中是强符号，在其他文件中是弱符号，那么选择强符号。</li>
<li>如果一个符号在所有的目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li>
</ol>
<p>比如目标文件 a.o 定义全局变量 global 为 int 类型，占用4个字节，目标文件 b.o 定义 global 为 double 类型，占用8个字节，那么被链接后，符号 global 占用8个字节。请尽量不要使用多个不同类型的弱符号，否则有时候很难发现程序错误。</p>
<p>在 GCC 中，可以通过<code>__attribute__((weak))</code>来强制定义任何一个符号为弱符号。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ext;      <span class="comment">// ext 既非强符号也非弱符号，它是一个对外部变量的引用（使用）。</span></span><br><span class="line"><span class="keyword">int</span> weak1;           <span class="comment">// weak1 和 weak2 是弱符号，strong 和 main 是强符号</span></span><br><span class="line"><span class="keyword">int</span> strong = <span class="number">100</span>;</span><br><span class="line">__attribute__((weak)) weak2 = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>__attribute__((weak))</code>只对链接器有效，对编译器不起作用，编译器不区分强符号和弱符号，只要在一个源文件中定义两个相同的符号，不管它们是强是弱，都会报“重复定义”错误。</p>
<p>弱符号对于库来说十分有用，我们在开发库时，可以将某些符号定义为弱符号，这样就能够被用户定义的强符号覆盖，从而使得程序可以使用自定义版本的函数，增加了很大的灵活性。</p>
<h3 id="强引用和弱引用"><a href="#强引用和弱引用" class="headerlink" title="强引用和弱引用"></a>强引用和弱引用</h3><p>所谓引用（Reference），是指对符号的使用。在下面的代码中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>, b = <span class="number">200</span>, c;           <span class="comment">//符号定义</span></span><br><span class="line">c = a + b;                         <span class="comment">//符号引用</span></span><br></pre></td></tr></table></figure>

<p>目前我们所看到的符号引用，在所有目标文件被链接成可执行文件时，它们的地址都要被找到，如果没有符号定义，链接器就会报符号未定义错误，这种被称为强引用（Strong Reference）。</p>
<p>与之相对应的还有一种弱引用（Weak Reference），如果符号有定义，就使用它对应的地址，如果没有定义，也不报错。</p>
<p>链接器处理强引用和弱引用的过程几乎是一样的，只是对于未定义的弱引用，链接器不认为它是一个错误，一般默认其为 0（地址为 0），或者是一个特殊的值，以便程序代码能够识别。</p>
<p>一般我们用的都是强引用，<strong>弱引用的作用</strong>体现在程序的模块化开发上。我们可以将程序的扩展模块定义为弱引用，当我们将扩展模块和程序链接在一起时，程序就可以正常使用；如果我们去掉了某些模块，那么程序也可以正常链接，只是缺少了某些功能，这使得程序的功能更加容易裁剪和组合。</p>
<p>在变量声明或函数声明的前面加上<code>__attribute__((weak))</code>就会使符号变为弱引用。(没错，就是和上面一样)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((weak)) <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">__attribute__((weak)) <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;  <span class="comment">//也可以不写extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a: %d, func: %d\n&quot;</span>, &amp;a, func);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以将它编译成一个可执行文件，GCC 并不会报链接错误。但是当程序运行时，输出<code>&amp;a: 0, func: 0</code>后就会发生段错误（Segment Fault），这是因为符号 a 和 func 的地址都为 0，这个地址是禁止访问的。</p>
<p>可以改进一下程序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((weak)) <span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line">__attribute__((weak)) <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;&amp;a: %d, func: %d\n&quot;</span>, &amp;a, func);</span><br><span class="line">    <span class="keyword">if</span>(&amp;a)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is undefined!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(func)&#123;</span><br><span class="line">        func();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;func() is undefined!\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中需要判断的是地址，不是值，所以变量 a 前面需要加<code>&amp;</code>；而函数名本身就表示地址，所以 func 前边不需要<code>&amp;</code>。</p>
<h3 id="头文件-1"><a href="#头文件-1" class="headerlink" title="头文件"></a>头文件</h3><p>main.c 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;module.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a = %d\n&quot;</span>, a);</span><br><span class="line">    func();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;OS: %s\n&quot;</span>, OS);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>module.c 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c.biancheng.net\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>module.h 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OS <span class="meta-string">&quot;Windows 7&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>在 GCC 中，使用下面的命令来编译和运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.c module.c</span><br><span class="line">$ ./a.out</span><br></pre></td></tr></table></figure>

<p><code>.c</code>和<code>.h</code>文件都是源文件，除了后缀不一样便于区分外和管理外，其他的都是相同的，在<code>.c</code>中编写的代码同样也可以写在<code>.h</code>中，包括函数定义、变量定义、预处理等。</p>
<p>但是，.h 和 .c 在项目中承担的角色不一样：.c 文件主要负责实现，也就是定义函数和变量；.h 文件主要负责声明（包括变量声明和函数声明）、宏定义、类型定义等。这些不是C语法规定的内容，而是约定成俗的规范，或者说是长期形成的事实标准。</p>
<p>根据这份规范，头文件可以包含如下的内容：</p>
<ul>
<li>可以声明函数，但不可以定义函数。</li>
<li>可以声明变量，但不可以定义变量。</li>
<li>可以定义宏，包括带参的宏和不带参的宏。</li>
<li>结构体的定义、自定义数据类型一般也放在头文件中。</li>
</ul>
<p>在项目开发中，我们可以将一组相关的变量和函数定义在一个 .c 文件中，并用一个同名的 .h 文件（头文件）进行声明，其他模块如果需要使用某个变量或函数，那么引入这个头文件就可以。</p>
<p>这样做的另外一个<strong>好处</strong>是可以保护版权，我们在发布相关模块之前，可以将它们都编译成目标文件，或者打包成静态库，只要向用户提供头文件，用户就可以将这些模块链接到自己的程序中。</p>
<h3 id="尖括号-和-双引号"><a href="#尖括号-和-双引号" class="headerlink" title="尖括号 和 双引号"></a>尖括号 和 双引号</h3><ul>
<li><p>使用尖括号<code>&lt; &gt;</code>，编译器会到系统路径下查找头文件；</p>
</li>
<li><p>而使用双引号<code>&quot; &quot;</code>，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。</p>
</li>
</ul>
<p>虽然说使用双引号比使用尖括号多了一个查找路径，它的功能更为强大，我们完全可以使用双引号来包含标准头文件，<strong>但是</strong>，最好是用尖括号包含库文件，用双引号包含用户头文件。</p>
<p>当使用相对路径的方式引入头文件时，如果使用<code>&lt; &gt;</code>，那么“相对”的就是系统路径，也就是说，编译器会直接在这些系统路径下查找头文件；如果使用<code>&quot; &quot;</code>，那么首先“相对”的是当前路径，然后“相对”的才是系统路径，也就是说，编译器首先在当前路径下查找头文件，找不到的话才会继续在系统路径下查找。</p>
<p>而使用绝对路径的方式引入头文件时，&lt; &gt;和” “没有任何区别，因为头文件路径已经写死了（从根部开始查找），不需要“相对”任何路径。</p>
<h3 id="防止头文件被重复包含"><a href="#防止头文件被重复包含" class="headerlink" title="防止头文件被重复包含"></a>防止头文件被重复包含</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _XYZ_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _XYZ_H</span></span><br><span class="line"><span class="comment">/* 头文件内容 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">//_XYZ_H</span></span></span><br></pre></td></tr></table></figure>

<p>头文件只在第一次包含时起作用，再次包含无效。</p>
<h3 id="static全局变量和函数"><a href="#static全局变量和函数" class="headerlink" title="static全局变量和函数"></a>static全局变量和函数</h3><p>之前我们讲了<a href="#static">static 局部变量</a> </p>
<p>全局变量和函数的作用域默认是整个程序，也就是所有的源文件，这给程序的模块化开发带来了很大方便，让我们能够在模块 A 中调用模块 B 中定义的变量和函数，而不用把所有的代码都集中到一个模块。</p>
<p><strong>但是</strong>，有时候也会引发命名冲突的问题，例如在 a.c 中定义了一个变量 n，在 b.c 中又定义了一次，链接时就会发生重复定义错误，原因很简单，变量只能定义一次。</p>
<p>实际开发中，我们通常将不需要被其他模块调用的全局变量或函数用 <strong>static</strong> 关键字来修饰，static 能够将全局变量和函数的作用域限制在当前文件中，在其他文件中无效。</p>
<p>module.c 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> n = <span class="number">999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello World!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>main.c 源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;http://c.biancheng.net\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    say();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n = %d\n&quot;</span>, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ http://c.biancheng.net</span><br><span class="line">$ n = 100</span><br></pre></td></tr></table></figure>

<p>使用 static 修饰的变量或函数的作用域仅限于当前模块，对其他模块隐藏，利用这一特性可以在不同的文件中定义同名的变量或函数，而不必担心命名冲突。</p>
<p>总结起来，static 变量主要有两个作用： </p>
<ol>
<li><p>隐藏</p>
<p>程序有多个模块时，将全局变量或函数的作用范围限制在当前模块，对其他模块隐藏。 </p>
</li>
<li><p>保持变量内容的持久化</p>
<p>将局部变量存储到全局数据区，使它不会随着函数调用结束而被销毁。</p>
</li>
</ol>
<p>又找到一段说明：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">static定义变量的使用：</span><br><span class="line"></span><br><span class="line">一、静态局部变量：</span><br><span class="line"></span><br><span class="line">1、Static类内部变量同auto自动变量（即未加 Static 声明的局部变量）一样，是某个特定函数的局部变量，即只能在定义该变量的函数内使用该变量，2者作用域相同；两者的不同在于：auto自动变量会随着函数被调用和退出而存在和消失，而static类局部变量不会，它不管其所在的函数是否被调用，都将一直存在；不过，尽管该变量还继续存在，但不能使用它。倘若再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值。换言之，Static类型的内部变量是一种只能在某个特定函数中使用，但一直占据存储空间的变量。</span><br><span class="line"></span><br><span class="line">2、函数体内如果在定义静态变量的同时进行了初始化，则以后程序不再进行初始化操作（出现在函数内部的基本类型的的静态变量初始化语句只有在第一次调用才执行）。而对自动变量赋初值是在函数调用时进行，每调用一次函数重新给一次初值，相当于执行一次赋值语句。</span><br><span class="line"></span><br><span class="line">3、静态局部变量的初始化表达式必须是一个常量或者常量表达式。即使局部静态变量定义时没有赋初值，系统会自动赋初值0（对数值型变量）或空字符（对字符变量）；静态变量的初始值为0。而对自动变量auto来说，如果不赋初值则它的值将是个不确定的值。</span><br><span class="line"></span><br><span class="line">4、当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，因此仍以采用局部静态变量为宜。</span><br><span class="line"></span><br><span class="line">注：局部静态变量占用内存时间较长，并且可读性差，因此，除非必要，尽量避免使用局部静态变量。</span><br><span class="line"></span><br><span class="line">二、静态全局变量</span><br><span class="line"></span><br><span class="line">全局变量(外部变量)的说明之前再冠以static 就构成了静态的全局变量。</span><br><span class="line"></span><br><span class="line">全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。</span><br><span class="line"></span><br><span class="line">这两者在存储方式上并无不同。</span><br><span class="line"></span><br><span class="line">这两者的区别虽在于：</span><br><span class="line"></span><br><span class="line">1、非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。</span><br><span class="line"></span><br><span class="line">2、静态全局变量则限制了其作用域， 即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。</span><br><span class="line"></span><br><span class="line">由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。</span><br><span class="line"></span><br><span class="line">从以上分析可以看出：</span><br><span class="line"></span><br><span class="line">把局部变量改变为静态变量后是改变了它的存储方式，即改变了它的生存期。</span><br><span class="line"></span><br><span class="line">把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。</span><br><span class="line"></span><br><span class="line">因此static这个说明符在不同的地方所起的作用是不同的。应予以注意。</span><br></pre></td></tr></table></figure>



<h2 id="Linux-Programming"><a href="#Linux-Programming" class="headerlink" title="Linux Programming"></a>Linux Programming</h2><h3 id="priority-and-nice-value"><a href="#priority-and-nice-value" class="headerlink" title="priority and nice value"></a>priority and nice value</h3><p>所有进程的统一优先级（upri，这个词是我自己造的）的取值范围是 [0, 140)，可以在 <code>/proc/&lt;pid&gt;/sched</code> 文件的 <code>prio</code> 一行查看。这个值越小，优先级越大。</p>
<p>其中，普通进程的 upri 在 [100, 139]，默认是 120，可以通过 <code>nice</code> 值调整，它们之间的关系是：</p>
<blockquote>
<p>upri = 120 + nice</p>
</blockquote>
<p>nice 取值为 [-20, 19]，越小说明进程的优先级越大。</p>
<p>实时进程的 upri 取值为 [0, 99]，可以通过 <code>sched_getscheduler</code> 等函数改变。</p>
<p>这些函数里有个变量叫 <code>sched_priority</code>，这个东西就恶心了，刚好是和 upri 相反的。</p>
<p>对于普通进程，<code>sched_priority</code> 只能设置为 0；</p>
<p>对于实时进程，<code>sched_priority</code> 取值范围也是 [0, 99]，但是值越大，进程的优先级越大😒<br>$$<br>sched_priority =<br>\begin{cases}<br>0, &amp;normal\ policies\<br>99\ -\ upri, &amp;real-time\ policies<br>\end{cases}<br>$$<br>总之，用的时候要注意了。</p>
<h1 id="C编译"><a href="#C编译" class="headerlink" title="C编译"></a>C编译</h1><h2 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e5c6a255076b">详细的讲解</a></p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>标准头文件 &lt;math.h&gt; 对应的数学库默认也不会被链接，如果没有手动将它添加进来，就会发生函数未定义错误。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;      /* printf */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;       /* cos */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PI 3.14159265</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> param, result;</span><br><span class="line">    param = <span class="number">60.0</span>;</span><br><span class="line">    result = <span class="built_in">cos</span> ( param * PI / <span class="number">180.0</span> );</span><br><span class="line">    <span class="built_in">printf</span> (<span class="string">&quot;The cosine of %f degrees is %f.\n&quot;</span>, param, result );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ gcc math.c</span><br><span class="line">/usr/bin/ld: /tmp/ccGMJ5X5.o: <span class="keyword">in</span> <span class="keyword">function</span> `main<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">math.c:(.text+0x33): undefined reference to `cos&#x27;</span></span><br><span class="line">collect2: error: ld returned 1 <span class="built_in">exit</span> status</span><br><span class="line">$ gcc math.c -lm</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>​    数学库的文件名是 <code>libm.a</code> 。前缀<code>lib</code>和后缀<code>.a</code>是标准的，m 是基本名称，GCC 会在<code>-l</code>选项后紧跟着的基本名称的基础上自动添加这些前缀、后缀，本例中，基本名称为 m。</p>
<p>​    一般的标准库是 <code>libc.a</code> ，可以加上 <code>-lc</code> 选项，但是默认就有，所以省略了。</p>
<h3 id="gcc指定头文件路径及动态链接库路径"><a href="#gcc指定头文件路径及动态链接库路径" class="headerlink" title="gcc指定头文件路径及动态链接库路径"></a>gcc指定头文件路径及动态链接库路径</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/mybelief321/article/details/9099659">参考</a></p>
<h2 id="gdb-调试"><a href="#gdb-调试" class="headerlink" title="gdb 调试"></a>gdb 调试</h2><p><a target="_blank" rel="noopener" href="http://docs.linuxtone.org/ebooks/C&CPP/c/ch10s01.html#ftn.id2989122">参考</a></p>
<p><strong>gdb基本命令</strong></p>
<table>
<thead>
<tr>
<th>backtrace（或bt）</th>
<th>查看各级函数调用及参数</th>
</tr>
</thead>
<tbody><tr>
<td>finish</td>
<td>执行到当前函数返回，然后停下来等待命令</td>
</tr>
<tr>
<td>frame（或f） 帧编号</td>
<td>选择栈帧</td>
</tr>
<tr>
<td>info（或i） locals</td>
<td>查看当前栈帧局部变量的值</td>
</tr>
<tr>
<td>list（或l）</td>
<td>列出源代码，接着上次的位置往下列，每次列10行</td>
</tr>
<tr>
<td>list 行号</td>
<td>列出从第几行开始的源代码</td>
</tr>
<tr>
<td>list 函数名</td>
<td>列出某个函数的源代码</td>
</tr>
<tr>
<td>next（或n）</td>
<td>执行下一行语句</td>
</tr>
<tr>
<td>print（或p）<code>&lt;x&gt;[=0]</code></td>
<td>打印表达式的值，通过表达式可以修改变量的值或者调用函数</td>
</tr>
<tr>
<td>set var <code>&lt;x=0&gt;</code></td>
<td>修改变量的值</td>
</tr>
<tr>
<td>start</td>
<td>开始执行程序，停在main函数第一行语句前面等待命令</td>
</tr>
<tr>
<td>step（或s）</td>
<td>执行下一行语句，如果有函数调用则进入到函数中</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>break（或b） 行号</th>
<th>在某一行设置断点</th>
</tr>
</thead>
<tbody><tr>
<td>break 函数名</td>
<td>在某个函数开头设置断点</td>
</tr>
<tr>
<td>break…if…</td>
<td>设置条件断点</td>
</tr>
<tr>
<td>continue（或c）</td>
<td>从当前位置开始连续而非单步执行程序</td>
</tr>
<tr>
<td>delete breakpoints</td>
<td>删除断点</td>
</tr>
<tr>
<td>display 变量名</td>
<td>跟踪查看一个变量，每次停下来都显示它的值</td>
</tr>
<tr>
<td>disable breakpoints</td>
<td>禁用断点</td>
</tr>
<tr>
<td>enable breakpoints</td>
<td>启用断点</td>
</tr>
<tr>
<td>info（或i） breakpoints</td>
<td>查看当前设置了哪些断点</td>
</tr>
<tr>
<td>run（或r）</td>
<td>从头开始连续而非单步执行程序</td>
</tr>
<tr>
<td>undisplay</td>
<td>取消对先前设置的那些变量的跟踪</td>
</tr>
</tbody></table>
<h2 id="makefile介绍"><a href="#makefile介绍" class="headerlink" title="makefile介绍"></a>makefile介绍</h2><p><a target="_blank" rel="noopener" href="https://seisman.github.io/how-to-write-makefile/introduction.html">参考</a></p>
<p>模板：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a simple makefile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">all : hi</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hi : hi.o</span><br><span class="line">        @cc -o hi hi.o</span><br><span class="line">        @echo <span class="string">&quot;generate hi&quot;</span></span><br><span class="line">hi.o : hi.c</span><br><span class="line">        @cc -c hi.c</span><br><span class="line">        @echo <span class="string">&quot;generate hi.o&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY : install</span><br><span class="line">install : all</span><br><span class="line">        cp hi /usr/local/bin/</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">        rm -f *.o</span><br><span class="line"></span><br><span class="line">.PHONY : exec</span><br><span class="line">exec :</span><br><span class="line">        cd /usr/bin ; pwd</span><br></pre></td></tr></table></figure>





<p>下面正式开始：</p>
<p>test.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * test.c for makefile demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>makefile：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># helloworld is a binary file</span></span><br><span class="line"><span class="comment"># 注意命令之前要加tab，空格好像不行</span></span><br><span class="line"><span class="section">helloworld: test.o</span></span><br><span class="line">        echo <span class="string">&quot;good&quot;</span></span><br><span class="line">        gcc -o helloworld test.o</span><br><span class="line"></span><br><span class="line"><span class="section">test.o: test.c</span></span><br><span class="line">        gcc -c -o test.o test.c</span><br></pre></td></tr></table></figure>

<p>观察上面的makefile</p>
<ul>
<li>#号起始的行是注释行</li>
<li>target: prerequisite为依赖关系，即目标文件(target)依赖于前提文件(prerequisite)。可以有多个前提文件，用空格分开。</li>
<li>依赖关系后面的 <strong>Tab</strong> 缩进行是实现依赖关系进行的操作，即正常的UNIX命令。一个依赖关系可以附属有多个操作。</li>
</ul>
<p>用直白的话说，就是:</p>
<ul>
<li>想要helloworld吗？那你必须有test.o，并执行附属的操作。</li>
<li>如果没有test.o，那你必须搜索其他依赖关系，并创建test.o。</li>
</ul>
<p><strong>如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</strong></p>
<h3 id="宏-MACRO"><a href="#宏-MACRO" class="headerlink" title="宏(MACRO)"></a>宏(MACRO)</h3><p>make中可以使用宏(MACRO)。宏类似于文本类型的变量。比如下面的CC:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line"><span class="comment"># 这里的tab就变成两行了</span></span><br><span class="line"><span class="comment"># helloworld is a binary file</span></span><br><span class="line"><span class="section">helloworld: test.o</span></span><br><span class="line">　　echo <span class="string">&quot;good&quot;</span></span><br><span class="line">　　<span class="variable">$(CC)</span> -o helloworld test.o</span><br><span class="line"></span><br><span class="line"><span class="section">test.o: test.c</span></span><br><span class="line">　　<span class="variable">$(CC)</span> -c -o test.o test.c</span><br></pre></td></tr></table></figure>

<p>我们用CC来代表”gcc”。在makefile中，使用$(CC)的方式来调用宏的值。make会在运行时，使用宏的值(gcc)来替代$(CC)。 </p>
<p>shell的环境变量可以直接作为宏调用。如果同一个自定义的宏同时也有同名环境环境变量，make将优先使用自定义宏。</p>
<p>(可以使用$make -e helloworld来优先使用环境变量)</p>
<p>另一个例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">     insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>

<p>于是，我们就可以很方便地在我们的makefile中以 <code>$(objects)</code> 的方式来使用这个变量了，于是<br>我们的改良版makefile就变成下面这个样子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">    cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">    cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">    cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">    cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">    cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">    cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">    cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">    cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>于是如果有新的 <code>.o</code> 文件加入，我们只需简单地修改一下 <code>objects</code> 变量就可以了。</p>
<h3 id="让make自动推导-隐晦规则"><a href="#让make自动推导-隐晦规则" class="headerlink" title="让make自动推导(隐晦规则)"></a>让make自动推导(隐晦规则)</h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个 <code>.o</code> 文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p>
<p>只要make看到一个 <code>.o</code> 文件，它就会自动的把 <code>.c</code> 文件加在依赖关系中，如果make找到一个 <code>whatever.o</code> ，那么 <code>whatever.c</code> 就会是 <code>whatever.o</code> 的依赖文件。并且 <code>cc -c whatever.c</code> 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的 新makefile又出炉了。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>上面文件内容中， <code>.PHONY</code> 表示 <code>clean</code> 是个伪目标文件。</p>
<h3 id="另类风格的makefiles"><a href="#另类风格的makefiles" class="headerlink" title="另类风格的makefiles"></a>另类风格的makefiles</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">    insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : <span class="variable">$(objects)</span></span><br><span class="line">    cc -o edit <span class="variable">$(objects)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span> : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。<br>还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个<br>新的 <code>.o</code> 文件，那就理不清楚了。</p>
<h3 id="内部宏"><a href="#内部宏" class="headerlink" title="内部宏"></a>内部宏</h3><p>make中有内部定义的宏，可以直接使用。$@中包含有当前依赖关系的目标文件名，而$^包含当前目标的前提文件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="comment"># helloworld is a binary file</span></span><br><span class="line"><span class="section">helloworld: test.o</span></span><br><span class="line">　　echo <span class="variable">$@</span></span><br><span class="line">　　<span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">test.o: test.c</span></span><br><span class="line">　　<span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$^</span></span><br></pre></td></tr></table></figure>

<p>内部宏       功能</p>
<p>$*          当前依赖关系中的目标文件名，不包括后缀。</p>
<p>$*          当前依赖关系中，发生改变的前提文件                         //这里写错了吧</p>
<p>$$          字符”$”</p>
<p>如果目标或者前提文件是一个完整路径，我们可以附加D和F来提取文件夹部分和文件名部分，比如$(@F)表示目标文件的文件名部分。</p>
<h3 id="后缀依赖"><a href="#后缀依赖" class="headerlink" title="后缀依赖"></a>后缀依赖</h3><p>在makefile中使用</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">.SUFFIXES: .c .o</span></span><br></pre></td></tr></table></figure>

<p>来说明.c和.o是后缀。</p>
<p>我们可以使用后缀依赖的方式，比如:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line"></span><br><span class="line"><span class="section">.SUFFIXES: .c .o</span></span><br><span class="line"></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#--------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># helloworld is a binary file</span></span><br><span class="line"><span class="section">helloworld: test.o</span></span><br><span class="line">        echo <span class="variable">$@</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"></span><br><span class="line"><span class="section">test.o: test.c        #这下面没有操作，上面的 .c.o: 会执行命令</span></span><br></pre></td></tr></table></figure>

<p>我们定义.c和.o为后缀。并有后缀依赖关系.c.o:。前者为前提，后者为目标。(注意，与一般的依赖关系顺序不同)</p>
<p>上面的test.o和test.c有依赖关系，但没有操作。make会发现该依赖关系符合.c.o的后缀依赖，并执行该后缀依赖后面的操作。</p>
<p>如果项目很大型的时候，后缀依赖非常有用。**符合后缀依赖的文件往往有类似的操作，我们可以将这些操作用后缀依赖表示，而避免重复输入。</p>
<h3 id="清空目标文件的规则"><a href="#清空目标文件的规则" class="headerlink" title="清空目标文件的规则"></a><strong>清空目标文件的规则</strong></h3><p><code>makefile</code> 的续行符为\</p>
<p><code>makefile</code> 中经常会定义下面依赖关系，如果 <code>make</code> 后没有跟随文件名，那么将执行该依赖关系。</p>
<p><code>make</code> 会找文件中的第一个目标文件（<code>target</code>），并把这个文件作为最终的目标文件。所以不用 <code>all</code> 好像也可以。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all:</span></span><br></pre></td></tr></table></figure>

<p>clean 常用于清理历史文件。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br></pre></td></tr></table></figure>



<p>看例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line"><span class="section">.SUFFIXES: .c .o</span></span><br><span class="line"><span class="section">.c.o:</span></span><br><span class="line">        <span class="variable">$(CC)</span> -c -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="comment">#--------------------------</span></span><br><span class="line"><span class="section">all: helloworld</span></span><br><span class="line">        @echo <span class="string">&quot;ALL&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># helloworld is a binary file</span></span><br><span class="line"><span class="section">helloworld: test.o</span></span><br><span class="line">        @echo <span class="variable">$@</span></span><br><span class="line">        <span class="variable">$(CC)</span> -o <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line"><span class="section">test.o: test.c</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        -rm helloworld *.o</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>: echo前面的@和rm前面的-。@后的命令将不显示命令本身。-后面的命令将忽略错误(比如删除不存在的文件)。</p>
<p> <code>clean</code> 不是一个文件，它只不过是一个动作名字，有点像c语言中的label一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要<strong>在make命令后明显得指出这个label的名字</strong>(make clean)。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p>
<p>更为稳健的做法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit <span class="variable">$(objects)</span></span><br></pre></td></tr></table></figure>

<p> <code>.PHONY</code> 表示 <code>clean</code> 是一个“伪目标”。而在 <code>rm</code> 命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然， <code>clean</code> 的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“<strong>clean从来都是放在文件的最后</strong>”。</p>
<h3 id="Makefile里有什么？"><a href="#Makefile里有什么？" class="headerlink" title="Makefile里有什么？"></a>Makefile里有什么？</h3><p>Makefile里主要包含了五个东西：<strong>显式规则</strong>、<strong>隐晦规则</strong>、<strong>变量定义</strong>、<strong>文件指示</strong>和<strong>注释</strong>。</p>
<ol>
<li>显式规则。显式规则说明了如何生成一个或多个目标文件。这是由Makefile的书写者明显指出要生成的文件、文件的依赖文件和生成的命令。</li>
<li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较简略地书写Makefile，这是由make所支持的。</li>
<li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点像C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li>
<li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。</li>
<li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用 <code>#</code> 字符，这个就像C/C++中的 <code>//</code> 一样。如果你要在你的Makefile中使用 <code>#</code> 字符，可以用反斜杠进行转义，如： <code>\#</code>  。</li>
</ol>
<p>最后，还值得一提的是，在Makefile中的命令，<strong>必须</strong>要以 <code>Tab</code> 键开始。</p>
<h3 id="Makefile的文件名"><a href="#Makefile的文件名" class="headerlink" title="Makefile的文件名"></a>Makefile的文件名</h3><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“<strong>GNUmakefile</strong>”、“<strong>makefile</strong>”、“<strong>Makefile</strong>”的文件。</p>
<p>不同 <code>make</code> 对三者的支持度不同：</p>
<p>“<strong>makefile</strong>” &gt; “<strong>Makefile</strong>” &gt; “<strong>GNUmakefile</strong>”</p>
<p>一般前两者都支持。第二个更醒目一点。</p>
<p>也可以使用别的文件名来书写Makefile，比如：“Make.Linux”，</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -f Make.Linux</span><br></pre></td></tr></table></figure>



<h3 id="引用其它的Makefile"><a href="#引用其它的Makefile" class="headerlink" title="引用其它的Makefile"></a>引用其它的Makefile</h3><p>在Makefile使用 <code>include</code> 关键字可以把别的Makefile包含进来，这很像C语言的<code>#include</code> ，被包含的文件会原模原样的放在当前文件的包含位置。 <code>include</code> 的语法是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make *.mk</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure>

<p>如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p>
<h2 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h2><p>规则包含两个部分，一个是依赖关系，一个是生成目标的方法。</p>
<p>Makefile中只应该有<strong>一个最终目标</strong>，其它的目标都是被这个目标所连带出来的，所以一定要让make知道你的最终目标是什么。一般来说，定义在Makefile中的目标可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么，第一个目标会成为最终的目标。make所完成的也就是这个目标。</p>
<h3 id="规则举例"><a href="#规则举例" class="headerlink" title="规则举例"></a>规则举例</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">foo.o: foo.c defs.h       # foo模块</span></span><br><span class="line">    cc -c -g foo.c</span><br></pre></td></tr></table></figure>

<p> <code>foo.o</code> 是我们的目标， <code>foo.c</code> 和<code>defs.h</code> 是目标所依赖的源文件，而只有一个命令 <code>cc -c -g foo.c</code> （以Tab键开头）。这个规则告诉我们两件事：</p>
<ol>
<li>文件的依赖关系， <code>foo.o</code> 依赖于 <code>foo.c</code> 和 <code>defs.h</code> 的文件，如果 <code>foo.c</code>和 <code>defs.h</code> 的文件日期要比 <code>foo.o</code> 文件日期要新，或是 <code>foo.o</code> 不存在，那么依赖关系发生。</li>
<li>生成或更新 <code>foo.o</code> 文件，就是那个cc命令。它说明了如何生成 <code>foo.o</code> 这个文件。（当然，foo.c文件include了defs.h文件）</li>
</ol>
<h3 id="规则的语法"><a href="#规则的语法" class="headerlink" title="规则的语法"></a>规则的语法</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets : prerequisites</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>或是：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">targets : prerequisites ; command</span><br><span class="line">    command</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ul>
<li><p>targets是文件名，以空格分开，可以使用通配符。一般来说，我们的目标基本上是一个文件，但也有可能是多个文件。</p>
</li>
<li><p>command是命令行，如果其不与“target:prerequisites”在一行，那么，必须以 <code>Tab</code> 键开头，如果和prerequisites在一行，那么可以用分号做为分隔。</p>
</li>
<li><p>prerequisites也就是目标所依赖的文件（或依赖目标）。如果其中的某个文件要比目标文件要新，那么，目标就被认为是“过时的”，被认为是需要重生成的。</p>
</li>
</ul>
<h3 id="在规则中使用通配符"><a href="#在规则中使用通配符" class="headerlink" title="在规则中使用通配符"></a>在规则中使用通配符</h3><p>make支持三个通配符：<code>*</code> ， <code>?</code> 和 <code>~</code> 。这是和Unix的B-Shell是相同的。</p>
<p>有一点需要<strong>注意</strong>：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects = *.o</span><br></pre></td></tr></table></figure>

<p>objects的值就是<code>*.o</code> 。Makefile中的变量其实就是C/C++中的宏。如果你要让通配符在变量中展开，也就是让objects的值是所有 <code>.o</code> 的文件名的集合，那么，你可以这样：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objects := <span class="variable">$(<span class="built_in">wildcard</span> *.o)</span></span><br></pre></td></tr></table></figure>



<h3 id="文件搜寻"><a href="#文件搜寻" class="headerlink" title="文件搜寻"></a>文件搜寻</h3><p>当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p>
<p>Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VPATH = src:../headers</span><br></pre></td></tr></table></figure>

<p>上面的定义指定两个目录，“src”和“../headers”，make会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p>
<p>另一个设置文件搜索路径的方法是使用make的 “<code>vpath</code>” 关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.h ../headers</span><br></pre></td></tr></table></figure>

<p>该语句表示，要求make在“../headers”目录下搜索所有以 <code>.h</code> 结尾的文件。（如果某文件在当前目录没有找到的话）</p>
<p>我们可以连续地使用vpath语句，以指定不同搜索策略。如果连续的vpath语句中出现了相同的pattern ，或是被重复了的pattern，那么，make会按照vpath语句的先后顺序来执行搜索。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br><span class="line"><span class="keyword">vpath</span> %.c bar</span><br></pre></td></tr></table></figure>

<p>其表示 .c 结尾的文件，先在“foo”目录，然后是“blish”，最后是“bar”目录。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vpath</span> %.c foo:bar</span><br><span class="line"><span class="keyword">vpath</span> %   blish</span><br></pre></td></tr></table></figure>

<p>而上面的语句则表示 <code>.c</code> 结尾的文件，先在“foo”目录，然后是“bar”目录，最后才是“blish”目录。</p>
<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>如“clean”，这是一个“伪目标”。</p>
<p>因为，我们并不生成“clean”这个文件。“伪目标”并不是一个文件，只是一个标签，由于“伪目标”不是 文件，所以make无法生成它的依赖关系和决定它是否要执行。我们只有通过显式地指明这个“目标”才能让其生效。当然，“伪目标”的取名不能和文件名重名，不然其就失去了“伪目标”的意义了。</p>
<p>当然，为了避免和文件重名的这种情况，我们可以使用一个特殊的标记“.PHONY”来显式地指明一个目标是“ 伪目标”，向make说明，不管是否有这个文件，这个目标就是“伪目标”。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br></pre></td></tr></table></figure>



<p>伪目标一般没有依赖的文件。但是，我们也可以为伪目标指定所依赖的文件。伪目标同样可以作为“默认目标”，只要将其放在第一个。一个示例就是，如果你的Makefile需要一口气生成若干个可执行文件，但你只 想简单地敲一个make完事，并且，所有的目标文件都写在一个Makefile中，那么你可以使用“伪目标”这个特性：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all : prog1 prog2 prog3</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">prog1 : prog1.o utils.o</span><br><span class="line">    cc -o prog1 prog1.o utils.o</span><br><span class="line"></span><br><span class="line">prog2 : prog2.o</span><br><span class="line">    cc -o prog2 prog2.o</span><br><span class="line"></span><br><span class="line">prog3 : prog3.o sort.o utils.o</span><br><span class="line">    cc -o prog3 prog3.o sort.o utils.o</span><br></pre></td></tr></table></figure>

<p>我们知道，Makefile中的第一个目标会被作为其默认目标。我们声明了一个“all”的伪目标，其依赖于其它 三个目标。由于默认目标的特性是，总是被执行的，但由于“all”又是一个伪目标，伪目标只是一个标签不 会生成文件，所以不会有“all”文件产生。于是，其它三个目标的规则总是会被决议。也就达到了我们一口 气生成多个目标的目的。 <code>.PHONY : all</code> 声明了“all”这个目标为“伪目标”。（注：这里的显式 “<code>.PHONY : all</code>” 不写的话一般情况也可以正确的执行，这样make可通过隐式规则推导出， “all” 是一 个伪目标，执行make不会生成“all”文件，而执行后面的多个目标。建议：<strong>显式写出是一个好习惯。</strong>）</p>
<p>从上面的例子我们可以看出，目标也可以成为依赖。所以，伪目标同样也可成为依赖。看下面的例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : cleanall cleanobj cleandiff</span><br><span class="line"></span><br><span class="line">cleanall : cleanobj cleandiff</span><br><span class="line">    rm program</span><br><span class="line"></span><br><span class="line">cleanobj :</span><br><span class="line">    rm *.o</span><br><span class="line"></span><br><span class="line">cleandiff :</span><br><span class="line">    rm *.diff</span><br></pre></td></tr></table></figure>

<p>“make cleanall” 将清除所有要被清除的文件。“cleanobj” 和 “cleandiff” 这两个伪目标有点像“子程序”的意思。我们可以输入 “make cleanall” 和 “make cleanobj” 和 “make cleandiff” 命令来达到清除不同种类文件的目的。</p>
<h3 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bigoutput littleoutput : text.g</span><br><span class="line">    generate text.g -<span class="variable">$(<span class="built_in">subst</span> output,,<span class="variable">$@</span>)</span> &gt; <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>上述规则等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bigoutput : text.g</span><br><span class="line">    generate text.g -big &gt; bigoutput</span><br><span class="line">littleoutput : text.g</span><br><span class="line">    generate text.g -little &gt; littleoutput</span><br></pre></td></tr></table></figure>

<p>其中， <code>-$(subst output,,$@)</code> 中的 <code>$</code> 表示执行一个Makefile的函数，函数名为subst，后面的为参数。关于函数，将在后面讲述。这里的这个函数是替换字符串的意思， <code>$@</code> 表示目标的集合，就像一个数组， <code>$@</code> 依次取出目标，并执于命令。</p>
<h3 id="静态模式"><a href="#静态模式" class="headerlink" title="静态模式"></a>静态模式</h3><p>静态模式可以更加容易地定义多目标的规则，可以让我们的规则变得更加的有弹性和灵活。我们还是先来看一下语法：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"></span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure>

<p>上面的例子中，指明了我们的目标从$object中获取， <code>%.o</code> 表明要所有以 <code>.o</code> 结尾的目标，也就是 <code>foo.o bar.o</code> ，也就是变量 <code>$object</code> 集合的模式，而依赖模式 <code>%.c</code> 则取模式<code>%.o</code> 的 <code>%</code> ，也就是 <code>foo bar</code> ，并为其加下 <code>.c</code> 的后缀，于是，我们的依赖目标就是 <code>foo.c bar.c</code> 。而命令中的 <code>$&lt;</code> 和 <code>$@</code> 则是自动化变量， <code>$&lt;</code> 表示第一个依赖文件，<code>$@</code> 表示目标集（也就是“foo.o bar.o”）。于是，上面的规则展开后等价于下面的规则：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> foo.c -o foo.o</span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> bar.c -o bar.o</span><br></pre></td></tr></table></figure>



<h3 id="自动生成依赖性"><a href="#自动生成依赖性" class="headerlink" title="自动生成依赖性"></a>自动生成依赖性</h3><p>我们可以使用C/C++编译的一个功能。大多数的C/C++编译器都支持一个“-M”的选项，即自动找寻源文件中 包含的头文件，并生成一个依赖关系。例如，如果我们执行下面的命令:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc -M main.c</span><br></pre></td></tr></table></figure>

<p>其输出是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c defs.h</span><br></pre></td></tr></table></figure>

<p>但是GNU的C/C++编译器，你得用 <code>-MM</code> 参数，不然， <code>-M</code>参数会把一些标准库的头文件也包含进来。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cc -MM math.c</span><br><span class="line">math.o: math.c</span><br><span class="line">$</span><br></pre></td></tr></table></figure>











<h2 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h2><p>make的命令默认是被 <code>/bin/sh</code> ——UNIX的标准Shell解释执行的。除非你特别指定一个其它的Shell。Makefile中， <code>#</code> 是注释符，很像C/C++中的<code>//</code> ，其后的本行字符都被注释。</p>
<h3 id="显示命令"><a href="#显示命令" class="headerlink" title="显示命令"></a>显示命令</h3><p>通常，make会把其要执行的命令行在命令执行前输出到屏幕上。当我们用 <code>@</code> 字符在命令行前，那么， 这个命令将不被make显示出来，最具代表性的例子是，我们用这个功能来向屏幕显示一些信息。如:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@echo 正在编译XXX模块......</span><br></pre></td></tr></table></figure>

<p>如果make执行时，带入make参数 <code>-n</code> 或 <code>--just-print</code> ，那么其只是显示命令，但不会执行 命令，这个功能很有利于我们调试我们的Makefile，看看我们书写的命令是执行起来是什么样子的或是什么顺序的。</p>
<p>而make参数 <code>-s</code> 或 <code>--silent</code> 或 <code>--quiet</code> 则是全面禁止命令的显示。</p>
<h3 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h3><p>如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一 条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就不能把这两条命令写在两行上，而 应该把这两条命令写在一行上，用分号分隔。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">        @cd /usr/bin</span><br><span class="line">        @pwd</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">exec</span></span><br><span class="line">/home/purian</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>所以应该写成：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">exec:</span></span><br><span class="line">        @cd /home/hchen; pwd    <span class="comment">#不能写成 @cd /home/hchen; @pwd</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ make <span class="built_in">exec</span></span><br><span class="line">/usr/bin</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>所以为什么要这么设计啊？</p>
<h3 id="命令出错"><a href="#命令出错" class="headerlink" title="命令出错"></a>命令出错</h3><p>有些时候，命令的出错并不表示就是错误的。例如mkdir命令，我们一定需要建立一个目录，如果目录不存在，那么mkdir就成功执行，万事大吉，如果目录存在，那么就出错了。我们之所以使用mkdir的意思就是 一定要有这样的一个目录，于是我们就不希望mkdir出错而终止规则的运行。</p>
<p>为了做到这一点，忽略命令的出错，我们可以在Makefile的命令行前加一个减号 <code>-</code> （在Tab键之后），标记为不管命令出不出错都认为是成功的。如：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">clean:</span></span><br><span class="line">    -rm -f *.o</span><br></pre></td></tr></table></figure>

<p>还有一个全局的办法是，给make加上 <code>-i</code> 或是 <code>--ignore-errors</code> 参数，那么，Makefile中所有命令都会忽略错误。而如果一个规则是以 <code>.IGNORE</code> 作为目标的，那么这个规则中的所有命令将会忽略错误。这些是不同级别的防止命令出错的方法，你可以根据你的不同喜欢设置。</p>
<p>还有一个 make 的参数的是 <code>-k</code> 或是 <code>--keep-going</code> ，这个参数的意思是，如果某规则中的命令出错了，那么就终止该规则的执行，但继续执行其它规则。</p>
<h3 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h3><p>在一些大的工程中，我们会把我们不同模块或是不同功能的源文件放在不同的目录中，我们可以在每个目录中都书写一个该目录的Makefile，这有利于让我们的Makefile变得更加地简洁，而不至于把所有的东西全 部写在一个Makefile中，这样会很难维护我们的Makefile，这个技术对于我们模块编译和分段编译有着非常大的好处。</p>
<p>例如，我们有一个子目录叫subdir，这个目录下有个Makefile文件，来指明了这个目录下文件的编译规则。那么我们总控的Makefile可以这样书写：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span></span><br></pre></td></tr></table></figure>

<p>其等价于：</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C subdir</span><br></pre></td></tr></table></figure>



<h3 id="定义命令包"><a href="#定义命令包" class="headerlink" title="定义命令包"></a>定义命令包</h3><p>如果Makefile中出现一些相同命令序列，那么我们可以为这些相同的命令序列定义一个变量。定义这种命令序列的语法以 <code>define</code> 开始，以 <code>endef</code> 结束，如:</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> run-yacc</span><br><span class="line">yacc <span class="variable">$(<span class="built_in">firstword</span> <span class="variable">$^</span>)</span></span><br><span class="line">mv y.tab.c <span class="variable">$@</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure>

<p>这里，“run-yacc”是这个命令包的名字，其不要和Makefile中的变量重名。在 <code>define</code> 和<code>endef</code> 中的两行就是命令序列。这个命令包中的第一个命令是运行Yacc程序，因为Yacc程序总是生成“y.tab.c”的文件，所以第二行的命令就是把这个文件改改名字。还是把这个命令包放到一个示例中来看看吧。</p>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c : foo.y</span><br><span class="line">    $(run-yacc)</span><br></pre></td></tr></table></figure>











<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>在Makefile中的定义的变量，就像是C/C++语言中的宏一样，他代表了一个文本字串，在Makefile中执行的时候其会自动原模原样地展开在所使用的地方。其与C/C++所不同的是，你可以在Makefile中改变其值。在Makefile中，变量可以使用在“目标”，“依赖目标”， “命令”或是Makefile的其它部分中。</p>
<h1 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h1><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="cp一个文件到多个目录"><a href="#cp一个文件到多个目录" class="headerlink" title="cp一个文件到多个目录"></a>cp一个文件到多个目录</h3><p>把 <code>c001/makefile</code> 复制到 <code>c002</code> .. <code>c100</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> c&#123;00&#123;2..9&#125;,0&#123;10..99&#125;,100&#125; | xargs -n 1 cp -v c001/makefile</span><br><span class="line">$ <span class="built_in">echo</span> c&#123;0&#123;38..99&#125;,100&#125; | xargs -n 1 cp -fv c037/main.c            //强制替换文件</span><br></pre></td></tr></table></figure>

<p>上面的命令中，目录的路径（dir1、dir2、dir3…dirN）被管道作为输入到 xargs 命令中，含义是：</p>
<ol>
<li><code>-n 1</code> – 告诉 xargs 命令每个命令行最多使用一个参数，并发送到 cp 命令中。</li>
<li><code>cp</code>     – 用于复制文件。</li>
<li><code>-v</code>     – 启用详细模式来显示更多复制细节。</li>
</ol>
<h3 id="查看文件夹大小"><a href="#查看文件夹大小" class="headerlink" title="查看文件夹大小"></a>查看文件夹大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -sh * <span class="comment">#当前目录下所有文件</span></span><br></pre></td></tr></table></figure>



<h3 id="文件夹权限"><a href="#文件夹权限" class="headerlink" title="文件夹权限"></a>文件夹权限</h3><table>
<thead>
<tr>
<th align="center">r</th>
<th>列出文件夹的内容</th>
</tr>
</thead>
<tbody><tr>
<td align="center">w</td>
<td>创建或删除文件</td>
</tr>
<tr>
<td align="center">x</td>
<td>可以搜索或进入该目录</td>
</tr>
</tbody></table>
<p>如果权限是 <code>100</code> :</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls -ld mod</span><br><span class="line">d--x------ 1 purian purian 4096 Jul 24 16:02 mod  <span class="comment">#不可读，但是可执行</span></span><br><span class="line">$ ls mod                                          <span class="comment">#无法列出文件</span></span><br><span class="line">ls: cannot open directory <span class="string">&#x27;mod&#x27;</span>: Permission denied</span><br><span class="line">$ ls mod/demo1                                    <span class="comment">#但是如果你知道里面有什么文件可以查看</span></span><br><span class="line">mod/demo1</span><br><span class="line">$ less mod/demo1                                  <span class="comment">#可以读</span></span><br><span class="line">$ vi mod/demo1                                    <span class="comment">#甚至可以写</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>



<p>注意，目录的权限将会覆盖该目录中文件的权限。即，如果文件权限足够，但是目录权限不够，那就不能操作。</p>
<p>另外，要删除目录以及目录下所有文件，三个权限都要有。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod 700 mod &amp;&amp; rm -rf mod</span><br></pre></td></tr></table></figure>



<p>再看个例子吧：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">$ touch mod/demo&#123;1..4&#125;                            <span class="comment">#创建四个文件</span></span><br><span class="line">$ ls -l mod</span><br><span class="line">total 0</span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:33 demo1   <span class="comment">#皆为可读可写</span></span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:33 demo2</span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:33 demo3</span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:33 demo4</span><br><span class="line">$ ls -ld mod</span><br><span class="line">drwxrwxrwx 1 purian purian 4096 Jul 25 09:33 mod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ chmod o-x mod                                </span><br><span class="line">$ ls -ld mod</span><br><span class="line">drwxrwxrw- 1 purian purian 4096 Jul 25 09:33 mod  <span class="comment">#去掉others的x权限</span></span><br><span class="line">$ su len                                          <span class="comment">#切换到其他用户</span></span><br><span class="line">Password:</span><br><span class="line">$ <span class="built_in">cd</span> mod</span><br><span class="line">bash: <span class="built_in">cd</span>: mod: Permission denied                  <span class="comment">#无法进入目录</span></span><br><span class="line">$ ls -l mod               </span><br><span class="line">ls: cannot access <span class="string">&#x27;mod/demo1&#x27;</span>: Permission denied  <span class="comment">#无法访问具体的文件</span></span><br><span class="line">ls: cannot access <span class="string">&#x27;mod/demo2&#x27;</span>: Permission denied</span><br><span class="line">ls: cannot access <span class="string">&#x27;mod/demo3&#x27;</span>: Permission denied</span><br><span class="line">ls: cannot access <span class="string">&#x27;mod/demo4&#x27;</span>: Permission denied</span><br><span class="line">total 0</span><br><span class="line">-????????? ? ? ? ?            ? demo1             <span class="comment">#可以列出文件的名字</span></span><br><span class="line">-????????? ? ? ? ?            ? demo2             <span class="comment">#但是更多的信息完全看不到</span></span><br><span class="line">-????????? ? ? ? ?            ? demo3</span><br><span class="line">-????????? ? ? ? ?            ? demo4</span><br><span class="line">$ less mod/demo1                                  <span class="comment">#无法读文件的内容</span></span><br><span class="line">mod/demo1: Permission denied</span><br><span class="line">$ cat &gt; demo1 &lt;&lt; <span class="string">eof                              #无法写入内容到文件</span></span><br><span class="line"><span class="string">&gt; e</span></span><br><span class="line"><span class="string">&gt; eof</span></span><br><span class="line">bash: demo1: Permission denied</span><br><span class="line">$ touch mod/demo5                                 <span class="comment">#不能在目录内创建新文件</span></span><br><span class="line">touch: cannot touch <span class="string">&#x27;mod/demo5&#x27;</span>: Permission denied</span><br><span class="line">$ mv mod/demo4 mod/demo5                          <span class="comment">#不能改名或是移动</span></span><br><span class="line">mv: failed to access <span class="string">&#x27;mod/demo5&#x27;</span>: Permission denied</span><br><span class="line">$ rm mod/demo4                                    <span class="comment">#也不能删除</span></span><br><span class="line">/bin/rm: cannot remove <span class="string">&#x27;mod/demo4&#x27;</span>: Permission denied</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ sudo chmod 773 mod &amp;&amp; ls -ld mod                <span class="comment">#去掉其他人的r权限，但是有w和x权限</span></span><br><span class="line">drwxrwx-wx 1 purian purian 4096 Jul 25 09:33 mod</span><br><span class="line">$ <span class="built_in">cd</span> mod &amp;&amp; <span class="built_in">cd</span> ..                                 <span class="comment">#可以进入目录</span></span><br><span class="line">$ ls -l mod                                       <span class="comment">#但是无法列出目录里有什么文件</span></span><br><span class="line">ls: cannot open directory <span class="string">&#x27;mod&#x27;</span>: Permission denied</span><br><span class="line">$ <span class="built_in">cd</span> mod &amp;&amp; ls &amp;&amp; <span class="built_in">cd</span> ..                           <span class="comment">#进入目录也无法列出。。</span></span><br><span class="line">ls: cannot open directory <span class="string">&#x27;.&#x27;</span>: Permission denied</span><br><span class="line">$ <span class="built_in">cd</span> ..                                           <span class="comment">#因为上面的命令第二个出错，所以第三个没有执行</span></span><br><span class="line">$ ls mod/demo*                                    <span class="comment">#shell无法自动扩展</span></span><br><span class="line">ls: cannot access <span class="string">&#x27;mod/demo*&#x27;</span>: No such file or directory</span><br><span class="line">$ ls -l mod/demo1                                 <span class="comment">#但是如果你知道里面有什么，还是可以访问的</span></span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:55 mod/demo1</span><br><span class="line">$ touch mod/demo5                                 <span class="comment">#可以在里面创建新文件</span></span><br><span class="line">$ ls mod/demo5                                  </span><br><span class="line">mod/demo5</span><br><span class="line">$ mv mod/demo5 mod/demo6                          <span class="comment">#可以重命名也可以移动，注意移动到的目录要有权限</span></span><br><span class="line">$ rm mod/demo6                                    <span class="comment">#可以删除</span></span><br><span class="line">$ less mod/demo1                                  <span class="comment">#可以读</span></span><br><span class="line">$ cat &gt; mod/demo1 &lt;&lt; <span class="string">eof                          #也可以写</span></span><br><span class="line"><span class="string">&gt; eof</span></span><br><span class="line">$</span><br><span class="line"></span><br><span class="line">$ sudo chmod 775 mod &amp;&amp; ls -ld mod                <span class="comment">#去掉w权限，保留r和x权限</span></span><br><span class="line">drwxrwxr-x 1 purian purian 4096 Jul 25 10:03 mod</span><br><span class="line">$ <span class="built_in">cd</span> mod &amp;&amp; <span class="built_in">cd</span> ..                                 <span class="comment">#可以进入目录</span></span><br><span class="line">$ ls -l mod                                       <span class="comment">#可以列出清单</span></span><br><span class="line">total 0</span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:55 demo1</span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:33 demo2</span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:33 demo3</span><br><span class="line">$ ls -l mod/demo1                                 <span class="comment">#可以访问具体文件</span></span><br><span class="line">-rw-rw-rw- 1 purian purian 0 Jul 25 09:55 mod/demo1</span><br><span class="line">$ touch mod/demo5                                 <span class="comment">#不能创建新文件</span></span><br><span class="line">touch: cannot touch <span class="string">&#x27;mod/demo5&#x27;</span>: Permission denied</span><br><span class="line">$ mv mod/demo3 mod/demo4                          <span class="comment">#不能改名或移动</span></span><br><span class="line">mv: cannot move <span class="string">&#x27;mod/demo3&#x27;</span> to <span class="string">&#x27;mod/demo4&#x27;</span>: Permission denied</span><br><span class="line">$ rm mod/demo3                                    <span class="comment">#不能删除</span></span><br><span class="line">/bin/rm: cannot remove <span class="string">&#x27;mod/demo3&#x27;</span>: Permission denied</span><br><span class="line">$ less mod/demo1                                  <span class="comment">#可以读</span></span><br><span class="line">$ cat &gt; mod/demo1 &lt;&lt; <span class="string">eof                          #可以写</span></span><br><span class="line"><span class="string">&gt; eof</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>从上面的分析可以看出：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>权限</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>- 列出目录清单<br>- shell 名称展开(这个是基于上面的)</td>
</tr>
<tr>
<td>w</td>
<td>- 创建、移动、改名和删除目录中的文件</td>
</tr>
<tr>
<td>x</td>
<td>- 进入目录<br>- 访问目录内具体的文件信息(需要知道文件名)<br>- 读写文件内容<br>+ 注意，虽然创建、移动、改名和删除目录中的文件是 <code>w</code> 的功能<br>+ 但是，如果你没有 <code>x</code> 的进入目录和访问文件的权限<br>+ 你依然不能创建、移动、改名或者删除目录中的文件<br>+ 所以说如果要使 <code>w</code> 生效，必须设置 <code>x</code></td>
</tr>
</tbody></table>
<h3 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h3><p>虽然我们通常看到一个八进制的权限掩码用三位数字来表示，但是从技术层面上来讲， 用四位数字来表示它更<br>确切些。为什么呢？因为，除了读取，写入，和执行权限之外，还有 其它的，较少用到的权限设置。</p>
<p>其中之一是 <strong>setuid</strong> 位（八进制4000)。当应用到一个可执行文件时，它把有效用户 ID 从真正的用户（实际运行<br>程序的用户）设置成程序所有者的 ID。这种操作通常会应用到 一些由超级用户所拥有的程序。当一个普通用户<br>运行一个程序，这个程序由根用户(root) 所有，并且设置了 setuid 位，这个程序运行时具有超级用户的特<br>权，这样程序就可以 访问普通用户禁止访问的文件和目录。很明显，因为这会引起安全方面的问题，所有可以<br>设置 setuid 位的程序个数，必须控制在绝对小的范围内。</p>
<p>第二个是 <strong>setgid</strong> 位（八进制2000），这个相似于 setuid 位，把有效用户组 ID 从真正的 用户组 ID 更改为文件<br>所有者的组 ID。如果设置了一个目录的 setgid 位，则目录中新创建的文件具有这个目录用户组的所有权，而<br>不是文件创建者所属用户组的所有权。对于共享目录来说， 当一个普通用户组中的成员，需要访问共享目录中<br>的所有文件，而不管文件所有者的主用户组时， 那么设置 setgid 位很有用处。</p>
<p>第三个是 <strong>sticky</strong> 位（八进制1000）。这个继承于 Unix，在 Unix 中，它可能把一个可执行文件标志为“不可<br>交换的”。在 Linux 中，会忽略文件的 sticky 位，但是如果一个目录设置了 sticky 位， 那么它能阻止用户删<br>除或重命名文件，除非用户是这个目录的所有者，或者是文件所有者，或是超级用户。这个经常用来控制访问<br>共享目录，比方说 /tmp。</p>
<p>这里有一些例子，使用 chmod 命令和符号表示法，来设置这些特殊的权限。</p>
<p>首先， 授予一个程序 <strong>setuid</strong> 权限。</p>
<blockquote>
<p>chmod u+s program</p>
</blockquote>
<p>下一步，授予一个目录 <strong>setgid</strong> 权限：</p>
<blockquote>
<p>chmod g+s dir</p>
</blockquote>
<p>最后，授予一个目录 <strong>sticky</strong> 权限：</p>
<blockquote>
<p>chmod +t dir</p>
</blockquote>
<p>当浏览 ls 命令的输出结果时，你可以确认这些特殊权限。这里有一些例子。首先，一个程序被设置为setuid属性：</p>
<blockquote>
<p>-rwsr-xr-x</p>
</blockquote>
<p>具有 setgid 属性的目录：</p>
<blockquote>
<p>drwxrwsr-x</p>
</blockquote>
<p>设置了 sticky 位的目录：</p>
<blockquote>
<p>drwxrwxrwt</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Set UID，SUID</span><br><span class="line">权值：4</span><br><span class="line">符号：x --&gt; s</span><br><span class="line">特点：仅对可执行文件有效。</span><br><span class="line">功能：可执行文件执行时，拥有文件所有者的权限。</span><br><span class="line">案例：&#x2F;usr&#x2F;bin&#x2F;passwd 权限为4755，普通用户可执行passwd命令时，对应的普通用户，随机秒变高富帅，获得了root权限，可以修改普通用户平常根本想都不敢想、无法修改的root拥有的&#x2F;etc&#x2F;shadow系统文件（如果&#x2F;usr&#x2F;bin&#x2F;passwd 权限为755，则普通用户执行passwd的时候，会出现无权限修改root own的&#x2F;etc&#x2F;shadow文件的问题）</span><br><span class="line"></span><br><span class="line">Set GID，SGID</span><br><span class="line">权值：2</span><br><span class="line">符号：x --&gt; s</span><br><span class="line">特点：文件、目录都可施法？好像只能目录，可执行文件不行× 可以的，是你可执行文件的组没设对</span><br><span class="line">功能：可执行文件、目录执行时，相同用户组的 拥有文件所有者权限。</span><br><span class="line">案例：SGID多用在特定的多人团队的项目开发上，在系统中用得较少</span><br><span class="line"></span><br><span class="line">Sticky Bit，SBit</span><br><span class="line">权值：1</span><br><span class="line">符号：x --&gt; t</span><br><span class="line">特点：仅对目录有效。</span><br><span class="line">功能：当目录SBit&#x3D;1，权限变为rwx rwx rwt时，在此文件夹下删除、重命名、移动的操作只允许是对应创建者用户或root（如果SBit&#x3D;0，则用户间创建的文件可以互相删除，互相伤害）</span><br><span class="line">案例：&#x2F;tmp 权限为1777，该目录下不同用户间不可互删文件，只能删自己的（如果&#x2F;test 权限为777，则test目录下不同用户间可互删文件）</span><br><span class="line"></span><br><span class="line">【Linux文件特殊权限“隐藏关卡”】</span><br><span class="line">SUID SGID StickyBit 均含有类似“设置后就有了创建者相应权限”的功能（可能不严谨，大家明白意思就好），那么当创建者也没有执行权限（x位为0，例如rw-rw-rw-）时，那么就会出现暗藏关卡——大写SST，即rwSrwSrwT，代表空权限。就像鸟哥书里说的那样“拥有者都无法执行了，哪里来的权限给其他人使用呢？当然就是空的”</span><br></pre></td></tr></table></figure>



<p><strong>Note</strong>: the set-user-ID and set-group-ID permission bits don’t have any effect for shell scripts on Linux.</p>
<h3 id="safe-rm"><a href="#safe-rm" class="headerlink" title="safe-rm"></a>safe-rm</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install safe-rm</span><br><span class="line">man safe-rm                      <span class="comment">#自己去看说明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#稍微讲一下吧</span></span><br><span class="line"><span class="comment">#首先创建软链接</span></span><br><span class="line"><span class="comment">#然后把路径加入到$PATH中，注意要放在前面</span></span><br><span class="line"><span class="comment">#大概前面的会覆盖后面的</span></span><br><span class="line"><span class="comment">#你问我为什么不把/bin/rm删掉，然后创建一个软链接指向safe-rm？</span></span><br><span class="line"><span class="comment">#我会告诉你safe-rm需要要调用rm，删掉rm之后就没法用了吗？</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#其实上面这些安装好后就自动配置好了</span></span><br><span class="line"><span class="comment">#但是，sudo的环境变量是不会改变的</span></span><br><span class="line"><span class="comment">#必须要更改sudoers的配置，把路径 /usr/share/safe-rm/bin 加到环境变量里面</span></span><br><span class="line"><span class="comment">#https://blog.csdn.net/x356982611/article/details/71169794</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#safe-rm的配置文件在</span></span><br><span class="line"><span class="comment"># /etc/safe-rm.conf</span></span><br><span class="line"><span class="comment"># ~/.config/safe-rm</span></span><br><span class="line"><span class="comment">#可以在里面设置一下哪些目录不能删</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#最后一件事</span></span><br><span class="line"><span class="comment">#如果全部配置好了，你可以大胆地使用 sudo rm -rf /</span></span><br><span class="line"><span class="comment">#但是千万不要用 sudo rm -rf /*</span></span><br><span class="line"><span class="comment">#safe-rm保护的是目录，目录里面的东西它不会管，当然也可以具体配置里面的文件不能删</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还有一点sudo用到的是 /etc/safe-rm.conf 里的配置</span></span><br><span class="line"><span class="comment">#如果只在 ~/.config/safe-rm 配置，用rm删不掉，加上 sudo 就会删掉</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还有最后一点。。</span></span><br><span class="line"><span class="comment">#配置好后删不掉，但是可以改名，然后删掉。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还有一件事。。</span></span><br><span class="line"><span class="comment">#换zsh，需要把环境变量写到.zshrc中</span></span><br><span class="line"><span class="built_in">export</span> PATH=/usr/share/safe-rm/bin:<span class="variable">$PATH</span> </span><br><span class="line"><span class="comment">#如果你写成 export PATH=/usr/share/safe-rm/bin 。。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种方法，更方便一点</span></span><br><span class="line"><span class="comment">##重命令 rm</span></span><br><span class="line">mv /bin/rm /bin/rrm</span><br><span class="line"><span class="comment">##把 safe-rm 脚本里的 /bin/rm 改成 /bin/rrm</span></span><br><span class="line">vi /usr/bin/safe-rm</span><br><span class="line"><span class="comment">##创建链接取代 rm</span></span><br><span class="line">ln -s /usr/bin/safe-rm /bin/rm</span><br></pre></td></tr></table></figure>



<h3 id="shell-通配符"><a href="#shell-通配符" class="headerlink" title="shell 通配符"></a>shell 通配符</h3><p><strong>shell常见通配符：</strong></p>
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>含义</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>匹配 0 或多个字符</td>
<td>a*b  a与b之间可以有任意长度的任意字符, 也可以一个也没有, 如aabcb, axyzb, a012b, ab。</td>
</tr>
<tr>
<td>?</td>
<td>匹配任意一个字符</td>
<td>a?b  a与b之间必须也只能有一个字符, 可以是任意字符, 如aab, abb, acb, a0b。</td>
</tr>
<tr>
<td>[list]</td>
<td>匹配 list 中的任意单一字符</td>
<td>a[xyz]b   a与b之间必须也只能有一个字符, 但只能是 x 或 y 或 z, 如: axb, ayb, azb。</td>
</tr>
<tr>
<td>[!list]</td>
<td>匹配 除list 中的任意单一字符</td>
<td>a[!0-9]b  a与b之间必须也只能有一个字符, 但不能是阿拉伯数字, 如axb, aab, a-b。</td>
</tr>
<tr>
<td>[c1-c2]</td>
<td>匹配 c1-c2 中的任意单一字符 如：[0-9] [a-z]</td>
<td>a[0-9]b  0与9之间必须也只能有一个字符 如a0b, a1b… a9b。</td>
</tr>
<tr>
<td>{string1,string2,…}</td>
<td>匹配 sring1 或 string2 (或更多)其一字符串</td>
<td>a{abc,xyz,123}b    a与b之间只能是abc或xyz或123这三个字符串之一。</td>
</tr>
</tbody></table>
<p>普遍使用的字符类：</p>
<ul>
<li><p>[:alnum:] 匹配任意一个字母或数字</p>
</li>
<li><p>[:alpha:]  匹配任意一个字母</p>
</li>
<li><p>[:digit:]    匹配任意一个数字</p>
</li>
<li><p>[:lower:]  匹配任意一个小写字母</p>
</li>
<li><p>[:upper]  匹配任意一个大写字母</p>
</li>
</ul>
<p>通配符范例：</p>
<ul>
<li>g*                           文件名以“g”开头的文件</li>
<li>b*.txt                     以”b”开头，中间有零个或任意多个字符，并以”.txt”结尾的文件</li>
<li>Data???                  以“Data”开头，其后紧接着3个字符的文件</li>
<li>[abc]*                    文件名以”a”,”b”,或”c”开头的文件</li>
<li>BACKUP.[0-9][0-9][0-9]  以”BACKUP.”开头，并紧接着3个数字的文件</li>
<li>[[:upper:]]*          以大写字母开头的文件</li>
<li>[![:digit:]]*            不以数字开头的文件</li>
<li>*[[:lower:]123]    文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件</li>
<li>mkdir -p playground/dir-{00{1..9},0{10..99},100}</li>
</ul>
<p>shell 除了有通配符之外，由shell 负责预先先解析后，将处理结果传给命令行之外，shell还有一系列自己的其他特殊字符。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IFS</td>
<td>由 <space> 或 <tab> 或 <enter> 三者之一组成(我们常用 space )。</enter></tab></space></td>
</tr>
<tr>
<td>CR</td>
<td>由 <enter> 产生。</enter></td>
</tr>
<tr>
<td>=</td>
<td>设定变量。</td>
</tr>
<tr>
<td>$</td>
<td>作变量或运算替换(请不要与 shell prompt 搞混了)。</td>
</tr>
<tr>
<td>&gt;</td>
<td>重导向 stdout。 *</td>
</tr>
<tr>
<td>&lt;</td>
<td>重导向 stdin。 *</td>
</tr>
<tr>
<td>|</td>
<td>命令管线。 *</td>
</tr>
<tr>
<td>&amp;</td>
<td>重导向 file descriptor ，或将命令置于背境执行。 *</td>
</tr>
<tr>
<td>( )</td>
<td>将其内的命令置于 nested subshell 执行，或用于运算或命令替换。 *</td>
</tr>
<tr>
<td>{ }</td>
<td>将其内的命令置于 non-named function 中执行，或用在变量替换的界定范围。</td>
</tr>
<tr>
<td>;</td>
<td>在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 *</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>在前一个命令结束时，若返回值为 true，继续执行下一个命令。 *</td>
</tr>
<tr>
<td>||</td>
<td>在前一个命令结束时，若返回值为 false，继续执行下一个命令。 *</td>
</tr>
<tr>
<td>!</td>
<td>执行 history 列表中的命令。*</td>
</tr>
</tbody></table>
<p>加入”*” 都是作用在命令名直接。可以看到shell 元字符，基本是作用在命令上面，用作多命令分割（或者参数分割）。因此看到与通配符有相同的字符，但是实际上作用范围不同。所以不会出现混淆。</p>
<h3 id="POSIX-字符集"><a href="#POSIX-字符集" class="headerlink" title="POSIX 字符集"></a>POSIX 字符集</h3><table>
<thead>
<tr>
<th align="center">字符集</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">[:alnum:]</td>
<td align="center">字母数字字符。在 ASCII 中，等价于：[A-Za-z0-9]</td>
</tr>
<tr>
<td align="center">[:word:]</td>
<td align="center">与[:alnum:]相同, 但增加了下划线字符</td>
</tr>
<tr>
<td align="center">[:alpha:]</td>
<td align="center">字母字符。在 ASCII 中，等价于：[A-Za-z]</td>
</tr>
<tr>
<td align="center">[:blank:]</td>
<td align="center">空格和 tab 字符。</td>
</tr>
<tr>
<td align="center">[:cntrl:]</td>
<td align="center">ASCII 的控制码。包含了0到31，和127的 ASCII 字符。</td>
</tr>
<tr>
<td align="center">[:digit:]</td>
<td align="center">数字0到9</td>
</tr>
<tr>
<td align="center">[:graph:]</td>
<td align="center">可视字符。在 ASCII 中，它包含33到126的字符。</td>
</tr>
<tr>
<td align="center">[:lower:]</td>
<td align="center">小写字母。</td>
</tr>
<tr>
<td align="center">[:punct:]</td>
<td align="center">标点符号字符</td>
</tr>
<tr>
<td align="center">[:print:]</td>
<td align="center">可打印的字符。在[:graph:]中的所有字符，再加上空格字符。</td>
</tr>
<tr>
<td align="center">[:space:]</td>
<td align="center">空白字符，包括空格，tab，回车，换行，vertical tab, 和 form feed.在 ASCII 中， 等价于：[ \t\r\n\v\f]</td>
</tr>
<tr>
<td align="center">[:upper:]</td>
<td align="center">大写字母</td>
</tr>
<tr>
<td align="center">[:xdigit:]</td>
<td align="center">用来表示十六进制数字的字符。在 ASCII 中，等价于：[0-9A-Fa-f]</td>
</tr>
</tbody></table>
<p>这个 shell 和正则都可以用，主要是因为 shell 扩展的 [A-Z] 有 ASCII 和 字典顺序两种顺序</p>
<p>shell 和正则有一些不同的地方：</p>
<ol>
<li>在 shell 中，<code>ls /bin/zi*p</code> 指的是以 <code>zi</code> 开头，以 <code>p</code> 结尾的，但是正则需要插入符号 <code>^</code> 和美元符号 <code>$</code> 作为锚点</li>
<li>在 shell 中，[!0-9] 表示否定，而正则中是 [<code>^</code>0-9]。</li>
</ol>
<h3 id="BRE-和-ERE"><a href="#BRE-和-ERE" class="headerlink" title="BRE 和 ERE"></a>BRE 和 ERE</h3><p>基本正则表达式（BRE）和扩展的正则表达式（ERE）</p>
<p>BRE 可以辨别以下元字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ $ . [ ] *</span><br></pre></td></tr></table></figure>

<p>其它的所有字符被认为是文本字符。ERE 添加了以下元字符：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">( ) &#123; &#125; ? + |</span><br></pre></td></tr></table></figure>

<p>grep 使用 <code>-E</code> 选项可以支持 ERE。</p>
<p>或者使用 egrep 程序来代替。</p>
<p>要知道 BRE 里面也是可以使用 <code>|</code> 的，但是要用 <code>\</code> 转义。</p>
<p><code>*</code> 在 BRE 和 ERE 中都可以直接使用，都不用转义。</p>
<p><code>()</code> 的作用就是把某些内容括起来，比如:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ls | grep -Eh <span class="string">&#x27;^(s|h|a)&#x27;</span></span><br><span class="line">$ ls | grep -Eh <span class="string">&#x27;^s|h|a&#x27;</span>      <span class="comment">#这两个是不一样的</span></span><br></pre></td></tr></table></figure>







<h4 id="任意字符"><a href="#任意字符" class="headerlink" title=". 任意字符"></a><code>.</code> 任意字符</h4><p><strong>BRE</strong> 的 <code>.</code> 表示任意字符，有且只有一个</p>
<p><strong>ERE</strong> 可以使用 限定符来指定一个元素被匹配的次数。</p>
<h4 id="匹配零个或一个元素，使前面的元素可有可无"><a href="#匹配零个或一个元素，使前面的元素可有可无" class="headerlink" title="? - 匹配零个或一个元素，使前面的元素可有可无"></a><code>?</code> - 匹配零个或一个元素，使前面的元素可有可无</h4><p>如果下面两种格式都可行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(nnn) nnn-nnnn</span><br><span class="line">nnn nnn-nnnn</span><br></pre></td></tr></table></figure>

<p>也就是括号可有可无，那么可以用下面的正则表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>因为在 ERE 中括号是元字符，所以要用 <code>\</code> 转义成普通字符，在 BRE 中恰好相反。</p>
<h4 id="匹配零个或多个元素"><a href="#匹配零个或多个元素" class="headerlink" title="* - 匹配零个或多个元素"></a><code>*</code> - 匹配零个或多个元素</h4><p>比方说我们想要知道是否一个字符串是一句话；也就是说，字符串开始于 一个大写字母，然后包含任意多个大写和小写的字母和空格，最后以句号收尾。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[[:upper:]][[:upper:][:lower:] ]*.$</span><br></pre></td></tr></table></figure>

<p>这个表达式由三个元素组成：一个包含[:upper:]字符集的中括号表达式，一个包含[:upper:]和[:lower:] 两个字符集以及一个空格的中括号表达式，和一个被反斜杠字符转义过的圆点。第二个元素末尾带有一个 *元字符，所以在开头的大写字母之后，可能会跟随着任意数目的大写和小写字母和空格。</p>
<h4 id="匹配一个或多个元素"><a href="#匹配一个或多个元素" class="headerlink" title="+ - 匹配一个或多个元素"></a><code>+</code> - 匹配一个或多个元素</h4><p>这个和 <code>*</code> 很类似呀，只是它要求至少有一个元素。</p>
<p>下面的正则表达式只匹配 那些由一个或多个字母字符组构成的文本行，字母字符之间由单个空格分开：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([[:alpha:]]+ ?)+$</span><br></pre></td></tr></table></figure>

<h4 id="匹配特定个数的元素"><a href="#匹配特定个数的元素" class="headerlink" title="{ } - 匹配特定个数的元素"></a><code>&#123; &#125;</code> - 匹配特定个数的元素</h4><table>
<thead>
<tr>
<th align="center">限定符</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">{n}</td>
<td align="center">匹配前面的元素，如果它确切地出现了 n 次。</td>
</tr>
<tr>
<td align="center">{n,m}</td>
<td align="center">至少出现了 n 次，但是不多于 m 次。</td>
</tr>
<tr>
<td align="center">{n,}</td>
<td align="center">至少出现了 n 次。</td>
</tr>
<tr>
<td align="center">{,m}</td>
<td align="center">最多出现 m 次。</td>
</tr>
</tbody></table>
<p>回到之前处理电话号码的例子，我们能够使用这种指定重复次数的方法来简化我们最初的正则表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\(?[0-9][0-9][0-9]\)? [0-9][0-9][0-9]-[0-9][0-9][0-9][0-9]$</span><br></pre></td></tr></table></figure>

<p>可以换成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\(?[0-9]&#123;3&#125;\)? [0-9]&#123;3&#125;-[0-9]&#123;4&#125;$</span><br></pre></td></tr></table></figure>







<h3 id="find-查找文件名"><a href="#find-查找文件名" class="headerlink" title="find - 查找文件名"></a>find - 查找文件名</h3><p>处理古怪的文件名</p>
<p>类 Unix 的系统允许在文件名中嵌入空格（甚至换行符）。这就给一些程序，如为其它程序构建参数列表的 xargs 程序，造成了问题。一个嵌入的空格会被看作是一个界定符，生成的 命令会把每个空格分离的单词解释为单 独的参数。为了解决这个问题，find 命令和 xarg 程序 允许可选择的使用一个 null 字符作为参数分隔符。一个 null 字符被定义在 ASCII 码中，由数字 零来表示（相反的，例如，空格字符在 ASCII 码中由数字32表示）。find 命令提供的 -print0 行为， 则会产生由 null 字符分离的输出，并且 xargs 命令有一个 –null 选项，这个选 项会接受由null 字符 分离的输入。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -iname <span class="string">&#x27;*.jpg&#x27;</span> -print0 | xargs --null ls -l</span><br></pre></td></tr></table></figure>

<p>使用这项技术，我们可以保证所有文件，甚至那些文件名中包含空格的文件，都能被正确地处理。</p>
<h3 id="grep-查找文件内容"><a href="#grep-查找文件内容" class="headerlink" title="grep - 查找文件内容"></a>grep - 查找文件内容</h3><p><code>grep -v</code> 反向查找，查找除了列出来的以外的内容</p>
<p>常用的 grep 选项有：<br><code>-c</code> 只输出匹配行的计数。<br><code>-i</code> 不区分大小写（只适用于单字符）。<br><code>-h</code> 查询多文件时不显示文件名。<br><code>-l</code> 查询多文件时只输出包含匹配字符的文件名。<br><code>-n</code> 显示匹配行及行号。<br><code>-s</code> 不显示不存在或无匹配文本的错误信息。<br><code>-v</code> 显示不包含匹配文本的所有行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ grep -nrsE <span class="string">&quot;main\(.*\)&quot;</span> ./  | grep -vE <span class="string">&quot;cscope|html|Binary|Makefile&quot;</span> | grep <span class="string">&quot;main(.*)&quot;</span></span><br><span class="line"><span class="comment"># 查找 main 函数，去掉一些文件内容，再重新染上颜色</span></span><br></pre></td></tr></table></figure>



<p>grep 的正则表达式，手册页上讲得挺清楚的，我就不翻译了。</p>
<p><img src="/passages/Learning-notes/grep-manual.png" alt="grep-manual"></p>
<p>主要分为 <code>BRE</code> 和 <code>ERE</code> ，<strong>在 grep 中</strong> ，这两个可以做到相同的事。区别在于， <code>?</code> 、<code>+</code>、<code>&#123;</code>、<code>|</code>、<code>(</code> 和 <code>)</code> 这几个字符（是不是少了个 <code>&#125;</code>？），如果不加 <code>\</code> 转义，那么在 <code>BRE</code> 中，它们就会作为普通字符参与字符匹配。</p>
<p>相反，在 <code>ERE</code> 中，这几个字符本身就是元字符，如果给这几个字符加了 <code>\</code> 转义，它们反而会变成普通字符。</p>
<h3 id="awk-抽取域"><a href="#awk-抽取域" class="headerlink" title="awk - 抽取域"></a>awk - 抽取域</h3><p>这里有个<a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2017-10/147270.htm">教程</a>，讲得挺详细的。但是有些语法可能不对。</p>
<p>在碰到 awk 错误时，可相应查找：<br>• 确保整个 awk 命令用单引号括起来。<br>• 确保命令内所有引号成对出现。<br>• 确保用花括号括起动作语句，用圆括号括起条件语句。<br>• 可能忘记使用花括号，也许你认为没有必要，但 awk 不这样认为，将按之解释语法。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;BEGIN &#123;print &quot;Name\t\tBelt\n-----------------------------&quot;&#125; &#123;print $1&quot;  \t&quot;$4&#125; END &#123;print &quot;End-of-report&quot;&#125;&#x27;</span> awk.de</span><br><span class="line">Name            Belt</span><br><span class="line">-----------------------------</span><br><span class="line">M.Tansley       Green</span><br><span class="line">J.Lulu          green</span><br><span class="line">P.Bunny         Yellow</span><br><span class="line">J.Troll         Brown-3</span><br><span class="line">L.Tansley       Brown-2</span><br><span class="line">$ awk <span class="string">&#x27;&#123;if($4~/Brown/) print $0&#125;&#x27;</span> awk.de         <span class="comment">##大小写敏感</span></span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ awk <span class="string">&#x27;$4~/[Gg]reen/ &#123;print $0&#125;&#x27;</span> awk.de          <span class="comment">##用正则表达式使不区分大小写</span></span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">$ awk <span class="string">&#x27;$0 ~ /Brown/&#x27;</span> awk.de                      <span class="comment">##这个和上面一样的</span></span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ awk <span class="string">&#x27;$0 !~ /Brown/&#x27;</span> awk.de                     <span class="comment">##不匹配，和上面相反</span></span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">$ awk <span class="string">&#x27;&#123;if ($3~/83/) print $0&#125;&#x27;</span> awk.de           <span class="comment">##找出第三列包含83，并把整行打印出来</span></span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">$ awk <span class="string">&#x27;$3==&quot;48311&quot; &#123;print $0&#125;&#x27;</span> awk.de            <span class="comment">##精确匹配</span></span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">$ awk <span class="string">&#x27;$3!=&quot;48311&quot; &#x27;</span> awk.de                      <span class="comment">##精确不匹配。。</span></span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123;if($6&lt;$7) print $1&quot;  \tTry better at the next comp&quot;&#125;&#x27;</span> awk.de    <span class="comment">##小于</span></span><br><span class="line">M.Tansley       Try better at the next comp</span><br><span class="line">J.Lulu          Try better at the next comp</span><br><span class="line">$ awk <span class="string">&#x27;$6&lt;$7 &#123;print $1&quot;  \tTry better at the next comp&quot;&#125;&#x27;</span> awk.de  <span class="comment">##去掉if后，条件放在花括号外面</span></span><br><span class="line">M.Tansley       Try better at the next comp</span><br><span class="line">J.Lulu          Try better at the next comp</span><br><span class="line">$ awk <span class="string">&#x27;$1 ~/^...a/&#x27;</span> awk.de                       <span class="comment">##抽取第一列第四个字符为a的行</span></span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ awk <span class="string">&#x27;$0~/(Yellow|Brown)/&#x27;</span> awk.de               <span class="comment">##输出所有级别为Yellow或Brown的记录，必须要用圆括号括起来</span></span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123;if ($1==&quot;P.Bunny&quot; &amp;&amp; $4==&quot;Yellow&quot;) print $0&#125;&#x27;</span> awk.de <span class="comment">##与</span></span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">$ awk <span class="string">&#x27;&#123;if ($4==&quot;[yY]ellow&quot; || $4~/[bB]rown/) print$0&#125;&#x27;</span> awk.de <span class="comment">#或，||左边的语法错了</span></span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br></pre></td></tr></table></figure>

<p>缺省情况下，awk 将打印所有匹配记录，因此 <code>&#123;print $0&#125;</code> 写不写均可。</p>
<p>贴一下完整的 <code>awk.de</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br></pre></td></tr></table></figure>



<h4 id="awk内置变量"><a href="#awk内置变量" class="headerlink" title="awk内置变量"></a>awk内置变量</h4><p>后面标星号的是常用变量：</p>
<table>
<thead>
<tr>
<th align="left">变量</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$n</td>
<td align="left">当前记录的第n个字段，字段间由FS分隔</td>
</tr>
<tr>
<td align="left">$0</td>
<td align="left">完整的输入记录</td>
</tr>
<tr>
<td align="left">ARGC *</td>
<td align="left">命令行参数的数目</td>
</tr>
<tr>
<td align="left">ARGIND</td>
<td align="left">命令行中当前文件的位置(从0开始算)</td>
</tr>
<tr>
<td align="left">ARGV *</td>
<td align="left">包含命令行参数的数组</td>
</tr>
<tr>
<td align="left">CONVFMT</td>
<td align="left">数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组</td>
</tr>
<tr>
<td align="left">ERRNO</td>
<td align="left">最后一个系统错误的描述</td>
</tr>
<tr>
<td align="left">ENVIRON *</td>
<td align="left">支持队列中系统环境变量的使用</td>
</tr>
<tr>
<td align="left">FIELDWIDTHS</td>
<td align="left">字段宽度列表(用空格键分隔)</td>
</tr>
<tr>
<td align="left">FILENAME *</td>
<td align="left">当前文件名</td>
</tr>
<tr>
<td align="left">FNR *</td>
<td align="left">各文件分别计数的行号</td>
</tr>
<tr>
<td align="left">FS *</td>
<td align="left">字段分隔符(默认是任何空格)</td>
</tr>
<tr>
<td align="left">IGNORECASE</td>
<td align="left">如果为真，则进行忽略大小写的匹配</td>
</tr>
<tr>
<td align="left">NF *</td>
<td align="left">一条记录的字段的数目</td>
</tr>
<tr>
<td align="left">$NF *</td>
<td align="left">最后一个Field（列），即输出最后一个字段的内容</td>
</tr>
<tr>
<td align="left">NR *</td>
<td align="left">已经读出的记录数，就是行号，从1开始</td>
</tr>
<tr>
<td align="left">OFMT</td>
<td align="left">数字的输出格式(默认值是%.6g)</td>
</tr>
<tr>
<td align="left">OFS *</td>
<td align="left">输出记录分隔符（输出换行符），输出时用指定的符号代替换行符</td>
</tr>
<tr>
<td align="left">ORS *</td>
<td align="left">输出记录分隔符(默认值是一个换行符)</td>
</tr>
<tr>
<td align="left">RLENGTH</td>
<td align="left">由match函数所匹配的字符串的长度</td>
</tr>
<tr>
<td align="left">RS *</td>
<td align="left">记录分隔符(默认是一个换行符)</td>
</tr>
<tr>
<td align="left">RSTART</td>
<td align="left">由match函数所匹配的字符串的第一个位置</td>
</tr>
<tr>
<td align="left">SUBSEP</td>
<td align="left">数组下标分隔符(默认值是/034)</td>
</tr>
</tbody></table>
<p>有些变量是整形，在 <code>printf</code> 中要有 <code>%d</code> 来引用，例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;printf&quot;awk %s lsP%d.txt &gt;&gt; demo.md\n&quot;,$0,$(NR-1)&#125;&#x27;</span> awkstr.txt</span><br></pre></td></tr></table></figure>



<p>所有学生记录被打印，并带有其记录号。使用 NF 变量显示每一条读记录中有多少个域，并在E N D部分打印输入文件名。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;print NF,NR,$0&#125; END&#123;print FILENAME&#125;&#x27;</span> awk.de</span><br><span class="line">7 1 M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">7 2 J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">7 3 P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">7 4 J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">7 5 L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">awk.de</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;/usr/local/etc/apt&quot;</span> | awk -F/ <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> <span class="comment">#打印最后一个字段</span></span><br><span class="line">apt</span><br></pre></td></tr></table></figure>

<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">= += -= *= /= %= ^= **=</td>
<td align="left">赋值</td>
</tr>
<tr>
<td align="left">?:</td>
<td align="left">C条件表达式</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑或</td>
</tr>
<tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑与</td>
</tr>
<tr>
<td align="left">~ 和 !~</td>
<td align="left">匹配正则表达式和不匹配正则表达式</td>
</tr>
<tr>
<td align="left">&lt; &lt;= &gt; &gt;= != ==</td>
<td align="left">关系运算符</td>
</tr>
<tr>
<td align="left">空格</td>
<td align="left">连接</td>
</tr>
<tr>
<td align="left">+ -</td>
<td align="left">加，减</td>
</tr>
<tr>
<td align="left">* / %</td>
<td align="left">乘，除与求余</td>
</tr>
<tr>
<td align="left">+ - !</td>
<td align="left">一元加，减和逻辑非</td>
</tr>
<tr>
<td align="left">^ ***</td>
<td align="left">求幂</td>
</tr>
<tr>
<td align="left">++ –</td>
<td align="left">增加或减少，作为前缀或后缀</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">字段引用</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">数组成员</td>
</tr>
</tbody></table>
<p>设置输入域到域变量名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#双引号括起来的内容原样输出，不会替换</span></span><br><span class="line">$ awk <span class="string">&#x27;&#123;name=$1;belts=$4; if(belts ~/Yellow/)print name&quot; is belt &quot;belts&#125;&#x27;</span> awk.de</span><br><span class="line">P.Bunny is belt Yellow</span><br><span class="line"><span class="comment">#自定义一个变量，27也可以用双引号引起来</span></span><br><span class="line">$ awk <span class="string">&#x27;BEGIN &#123;BASELINE=27&#125; &#123;if($6&lt;BASELINE)print$0&#125;&#x27;</span> awk.de</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line"><span class="comment">#修改数值域取值</span></span><br><span class="line">$ awk <span class="string">&#x27;&#123;if($1==&quot;M.Tansley&quot;) $6=$6-1; print $1,$6,$7&#125;&#x27;</span> awk.de</span><br><span class="line">M.Tansley 39 44</span><br><span class="line">J.Lulu 24 26</span><br><span class="line">P.Bunny 35 28</span><br><span class="line">J.Troll 26 26</span><br><span class="line">L.Tansley 30 28</span><br></pre></td></tr></table></figure>

<p>下面的例子有双重花括号：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;if($1==&quot;J.Troll&quot;) &#123;$1=&quot;J.L.Troll&quot;;print $1&#125;&#125;&#x27;</span> awk.de</span><br><span class="line">J.L.Troll</span><br></pre></td></tr></table></figure>

<p>创建新域：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;BEGIN&#123;print &quot;Name\t\tDifference&quot;&#125;&#123;if($6&lt;$7) &#123;$8=$7-$6;print $1&quot;  \t&quot;$8&#125;&#125;&#x27;</span> awk.de</span><br><span class="line">Name            Difference</span><br><span class="line">M.Tansley       4</span><br><span class="line">J.Lulu          2</span><br></pre></td></tr></table></figure>

<p>计算统计数：<strong>例1</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;(tot+=$6); END&#123;print &quot;Club student total points: &quot; tot&#125;&#x27;</span> awk.de</span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">Club student total points: 155</span><br></pre></td></tr></table></figure>

<p>注意与下面的区别：<strong>例2</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;tot+=$6&#125; END&#123;print &quot;Club student total points: &quot; tot&#125;&#x27;</span> awk.de</span><br><span class="line">Club student total points: 155</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"><span class="comment">#注意，并不是说有没有分号无所谓</span></span><br><span class="line">$ awk <span class="string">&#x27;&#123;(tot+=$6)&#125;; END&#123;print &quot;Club student total points: &quot; tot&#125;&#x27;</span> awk.de</span><br><span class="line">Club student total points: 155</span><br></pre></td></tr></table></figure>

<p>想不明白可以参考：<strong>例3</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;($1); END &#123;print&quot;End-of-report&quot;&#125;&#x27;</span> awk.de</span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">End-of-report</span><br><span class="line">$ awk <span class="string">&#x27;&#123;($1)&#125;; END &#123;print&quot;End-of-report&quot;&#125;&#x27;</span> awk.de</span><br><span class="line">End-of-report</span><br></pre></td></tr></table></figure>

<p>越来越糊涂了：<strong>例4</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;($1)&#125;&#x27;</span> awk.de</span><br><span class="line">$ awk <span class="string">&#x27;($1)&#x27;</span> awk.de</span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ awk <span class="string">&#x27;&#x27;</span> awk.de</span><br><span class="line">$ awk <span class="string">&#x27;$0&#x27;</span> awk.de</span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br></pre></td></tr></table></figure>

<p>有点头绪了：<strong>例5</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;$4~/[Gg]reen/ &#123;print $0&#125;&#x27;</span> awk.de</span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">$ awk <span class="string">&#x27;$4~/[Gg]reen/&#x27;</span> awk.de</span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">$ awk <span class="string">&#x27;&#123;$4~/[Gg]reen/&#125;&#x27;</span> awk.de</span><br><span class="line">$ awk <span class="string">&#x27;&#123;$4~/[Gg]reen/ print $0&#125;&#x27;</span> awk.de</span><br><span class="line">awk: line 1: syntax error at or near <span class="built_in">print</span></span><br><span class="line">$ awk <span class="string">&#x27;&#123;$4~/[Gg]reen/; print $0&#125;&#x27;</span> awk.de</span><br><span class="line">M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;&#123;if($4~/Brown/) print $0&#125;&#x27;</span> awk.de</span><br><span class="line">J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ awk <span class="string">&#x27;&#123;if($4~/Brown/)&#125;&#x27;</span> awk.de</span><br><span class="line">$ awk <span class="string">&#x27;if($4~/Brown/) &#123;print $0&#125;&#x27;</span> awk.de</span><br><span class="line">awk: line 1: syntax error at or near <span class="keyword">if</span></span><br><span class="line">$ awk <span class="string">&#x27;if($4~/Brown/)&#x27;</span> awk.de</span><br><span class="line">awk: line 1: syntax error at or near <span class="keyword">if</span></span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>看了很多教程，都没有能够说清楚的，既然这样，我自己来总结吧。虽然不一定是对的，但总比没有强[摊手]</p>
<p>格式：<code>awk [options] &#39;BEGIN&#123; action;… &#125; pattern&#123; action;… &#125; END&#123; action;… &#125;&#39; file ...</code></p>
<p><strong>第一步</strong>：执行[option]相关内容，也就是<code>-f，-F，-v</code>选项内容。</p>
<p><strong>第二步</strong>：执行BEGIN{action;… } 语句块中的语句。BEGIN 语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN 语句块中。</p>
<p><strong>第三步</strong>：从文件或标准输入(stdin) 读取每一行，然后执行pattern{action;… }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。pattern语句块中的通用命令是最重要的部分，也是可选的。如果没有提供pattern 语句块，则默认执行{ print } ，即打印每一个读取到的行，awk 读取的每一行都会执行该语句块。</p>
<p><strong>第四步</strong>：当读至输入流末尾时，<a href>也就是所有行都被读取完执行完后</a>，再执行END{action;…} 语句块。END 语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END 语句块中完成，它也是一个可选语句块。</p>
<p>看上面的<strong>例5</strong>，都没有 BEGIN 和 END，只有中间的部分。</p>
<ol>
<li>其中 <code>awk &#39;$4~/[Gg]reen/ &#123;print $0&#125;&#39; awk.de</code> 是标准的 <code>pattern&#123;action;… &#125;</code> 模式，也就是 正则+打印。</li>
<li>所以去掉后面的打印，只剩下 <code>awk &#39;$4~/[Gg]reen/&#39; awk.de</code> 依然是一样的，因为默认执行{ print }。</li>
<li>如果你给前面的 <code>pattern</code> 加上花括号，那么 <code>awk &#39;&#123;$4~/[Gg]reen/&#125;&#39; awk.de</code> 就会变成 <code>action</code> ，不再是模式，但是它本身并不能做出有意义的行为，而且由于行为部分没有缺省，也不会默认执行{ print }。</li>
<li><code>awk &#39;&#123;$4~/[Gg]reen/ print $0&#125;&#39; awk.de</code> 语法出错。</li>
<li>加个分号 <code>awk &#39;&#123;$4~/[Gg]reen/; print $0&#125;&#39; awk.de</code> 就对了，表明连续执行两个动作，第一个动作没有具体的效果，第二个才是实际能够感知到的行为。</li>
</ol>
<p>至于 <code>awk &#39;&#123;if($4~/Brown/) print $0&#125;&#39; awk.de</code></p>
<ol>
<li><p><code>awk &#39;&#123;if($4~/Brown/) print $0&#125;&#39; awk.de</code> ：不能把 <code>if($4~/Brown/)</code> 当成模式，它是行为的一部分，是行为的前提，这样记住就好了，事实上正是如此。</p>
</li>
<li><p>所以 <code>awk &#39;&#123;if($4~/Brown/)&#125;&#39; awk.de</code> 就好判断了，既然 <code>&#123;if($4~/Brown/)&#125;</code> 是行为，那么不会默认执行{ print }，而这个行为本身也没有实际动作(它只是个判断句而已)，所以不会表现出什么现象。</p>
</li>
<li><p><code>awk &#39;if($4~/Brown/) &#123;print $0&#125;&#39; awk.de</code> 语法错误， <code>if($4~/Brown/)</code> 是行为，要放在花括号里面。</p>
</li>
<li><p>同理。</p>
</li>
</ol>
<p>另外，从例1 和例2 应该可以总结出一个<strong>规律</strong>：可以在 <code>BEGIN</code> 、<code>中间部分</code> 和 <code>END</code> 之间加入分号，即</p>
<p>格式：<code>awk [options] &#39;BEGIN&#123; action;… &#125; ; pattern&#123; action;… &#125; ; END&#123; action;… &#125;&#39; file ...</code></p>
<p>不然解释不通了。。</p>
<p>还有一点，中间部分应该可以扩展，中间用分号隔开，即：</p>
<p>格式：<code>awk [options] &#39;BEGIN&#123; action;… &#125; ; pattern1&#123; action;… &#125; ; pattern2&#123; action;… &#125; ; END&#123; action;… &#125;&#39; file ...</code></p>
<p>处理的时候除了 <code>BEGIN</code> 和 <code>END</code> 是单独处理的，其余的每一行都要经过中间的 <code>模式+行为</code> 的处理。每一行处理完了再接着处理下一行。比如说下面的这个，它有两个 <code>模式+行为</code> ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;i=1;j=2 &#123;print i,j&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>



<h4 id="awk-内置函数-split"><a href="#awk-内置函数-split" class="headerlink" title="awk 内置函数 split"></a>awk 内置函数 split</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunada2005/p/3493941.html">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ cat log.txt</span><br><span class="line"></span><br><span class="line">ipv4     2 udp      17 70 src=127.0.0.1 dst=127.0.0.1 sport=8119 dport=8118 src=127.0.0.1 dst=127.0.0.1 sport=8118 dport=8119 [ASSURED] iqprio=0 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 unknown  2 465 src=192.168.1.1 dst=224.0.0.1 [UNREPLIED] src=224.0.0.1 dst=192.168.1.1 iqprio=1 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 tcp      6 9 TIME_WAIT src=127.0.0.1 dst=127.0.0.1 sport=56205 dport=5740 src=127.0.0.1 dst=127.0.0.1 sport=5740 dport=56205 [ASSURED] iqprio=0 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 unknown  2 466 src=192.168.1.1 dst=224.0.0.22 [UNREPLIED] src=224.0.0.22 dst=192.168.1.1 iqprio=1 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 udp      17 4 src=192.168.3.8 dst=192.168.3.1 sport=49868 dport=53 [UNREPLIED] src=192.168.3.1 dst=192.168.3.8 sport=53 dport=49868 iqprio=1 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 tcp      6 9 TIME_WAIT src=127.0.0.1 dst=127.0.0.1 sport=56211 dport=5740 src=127.0.0.1 dst=127.0.0.1 sport=5740 dport=56211 [ASSURED] iqprio=0 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 tcp      6 0 TIME_WAIT src=127.0.0.1 dst=127.0.0.1 sport=58410 dport=5916 src=127.0.0.1 dst=127.0.0.1 sport=5916 dport=58410 [ASSURED] iqprio=0 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 icmp     1 23 src=192.168.3.8 dst=192.168.3.1 <span class="built_in">type</span>=8 code=0 id=1 src=192.168.3.1 dst=192.168.3.8 <span class="built_in">type</span>=0 code=0 id=1 iqprio=0 swaccel=0 hwaccel=0 use=2</span><br><span class="line">ipv4     2 tcp      6 11 TIME_WAIT src=127.0.0.1 dst=127.0.0.1 sport=56216 dport=5740 src=127.0.0.1 dst=127.0.0.1 sport=5740 dport=56216 [ASSURED] iqprio=0 swaccel=0 hwaccel=0 use=2</span><br><span class="line"></span><br><span class="line">$ awk <span class="string">&#x27;$1 ~ /ipv4/ &#123; if($3~/udp/) &#123;split($6,src,&quot;=&quot;);  split($7,dst,&quot;=&quot;); split($8,sport,&quot;=&quot;); split($9,dport,&quot;=&quot;);  printf(&quot;%s(%s) -&gt; %s(%s)\n&quot;,src[2],sport[2],dst[2],dport[2])&#125; ;  if($3~/tcp/) &#123;split($7,src,&quot;=&quot;);  split($8,dst,&quot;=&quot;); split($9,sport,&quot;=&quot;); split($10,dport,&quot;=&quot;);  printf(&quot;%s(%s) -&gt; %s(%s)\n&quot;,src[2],sport[2],dst[2],dport[2])&#125;  ;   if($3~/icmp/) &#123;split($6,src,&quot;=&quot;);  split($7,dst,&quot;=&quot;);  printf(&quot;%s -&gt; %s\n&quot;,src[2],dst[2]) &#125; ;  if($3~/unknown/) &#123;split($6,src,&quot;=&quot;);  split($7,dst,&quot;=&quot;);  printf(&quot;%s -&gt; %s\n&quot;,src[2],dst[2]) &#125;  &#125;&#x27;</span> log.txt   &gt;  all.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个命令很长，我给你分析一下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;$1 ~ /ipv4/ &#123; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if($3~/udp/) </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    split($6,src,&quot;=&quot;);  split($7,dst,&quot;=&quot;); split($8,sport,&quot;=&quot;); split($9,dport,&quot;=&quot;);  printf(&quot;%s(%s) -&gt; %s(%s)\n&quot;,src[2],sport[2],dst[2],dport[2])</span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if($3~/tcp/) </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	split($7,src,&quot;=&quot;);  split($8,dst,&quot;=&quot;); split($9,sport,&quot;=&quot;); split($10,dport,&quot;=&quot;);  printf(&quot;%s(%s) -&gt; %s(%s)\n&quot;,src[2],sport[2],dst[2],dport[2])</span></span><br><span class="line"><span class="string">&#125;; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if($3~/icmp/) </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	split($6,src,&quot;=&quot;);  split($7,dst,&quot;=&quot;);  printf(&quot;%s -&gt; %s\n&quot;,src[2],dst[2]) </span></span><br><span class="line"><span class="string">&#125;;  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">if($3~/unknown/) </span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">	split($6,src,&quot;=&quot;);  split($7,dst,&quot;=&quot;);  printf(&quot;%s -&gt; %s\n&quot;,src[2],dst[2]) </span></span><br><span class="line"><span class="string">&#125; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#125;&#x27;</span> log.txt   &gt;  all.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="打印某列以后的所有列"><a href="#打印某列以后的所有列" class="headerlink" title="打印某列以后的所有列"></a>打印某列以后的所有列</h4><p>需要把下面的数据写到结构体里面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0501</span> ps_store_full Flash reserved <span class="keyword">for</span> PS store is full</span><br><span class="line"><span class="number">0x0502</span> ps_key_not_found PS key <span class="keyword">not</span> found</span><br><span class="line"><span class="number">0x0503</span> i2c_ack_missing Acknowledge <span class="keyword">for</span> i2c was <span class="keyword">not</span> received.</span><br><span class="line"><span class="number">0x0504</span> i2c_timeout I2C read <span class="keyword">or</span> write timed out.</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">ble_error_t</span> <span class="title">ble_errors</span>[] =</span> &#123;</span><br><span class="line">    &#123;<span class="number">0x0501</span>, <span class="string">&quot;ps_store_full&quot;</span>, <span class="string">&quot;Flash reserved for PS store is full&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x0502</span>, <span class="string">&quot;ps_key_not_found&quot;</span>, <span class="string">&quot;PS key not found&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x0503</span>, <span class="string">&quot;i2c_ack_missing&quot;</span>, <span class="string">&quot;Acknowledge for i2c was not received.&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="number">0x0504</span>, <span class="string">&quot;i2c_timeout&quot;</span>, <span class="string">&quot;I2C read or write timed out.&quot;</span>&#125;,</span><br><span class="line">    <span class="comment">/* ...... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>即第一个字段是 <code>code</code>，第二个字段是 <code>name</code>，后面所有的字段是 <code>description</code></p>
<p>前两个字段好表示，用 <code>awk</code> 就可以了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;printf&quot;    &#123;%s, \&quot;%s\&quot;, \&quot;%s\&quot;&#125;,\n&quot;,$1,$2,$3&#125;&#x27;</span> err | less  <span class="comment">#description 不完整</span></span><br></pre></td></tr></table></figure>

<p>参考这两篇文章：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liuxiao723846/article/details/55003749">参考1</a>  <a target="_blank" rel="noopener" href="https://blog.csdn.net/imliuqun123/article/details/82978675">参考2</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;printf&quot;    &#123;%s, \&quot;%s\&quot;, &quot;,$1,$2; $1=&quot;&quot;; $2=&quot;&quot;; printf &quot;\&quot;%s\&quot;&#125;,\n&quot;, $0&#125;&#x27;</span> err | less</span><br></pre></td></tr></table></figure>

<p>把前两个字段赋值为空，这样就可以把剩下的打印出来了</p>
<p>然而多了 <code>^M</code> 这个特殊字符，这个是 <code>\r</code>，把文本转换成 <code>unix</code> 格式就行了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> ff=unix      <span class="comment">#在 vim 中</span></span><br></pre></td></tr></table></figure>

<p>还有一个问题，虽然前两个字段没有了，但是它们之间的空格还在，所以要用 <code>sub</code> 函数减去这两个空格：</p>
<p><a target="_blank" rel="noopener" href="https://www.iteye.com/blog/ama2000-1328090">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;printf&quot;    &#123;%s, \&quot;%s\&quot;, &quot;,$1,$2; $1=&quot;&quot;; $2=&quot;&quot;; sub(/^[[:blank:]]*/,&quot;&quot;,$0);printf &quot;\&quot;%s\&quot;&#125;,\n&quot;, $0&#125;&#x27;</span> err | less</span><br></pre></td></tr></table></figure>

<p>最后一点，<code>description</code> 里有一条有双引号，要找出来转义。</p>
<h4 id="删除某些前缀和后缀"><a href="#删除某些前缀和后缀" class="headerlink" title="删除某些前缀和后缀"></a>删除某些前缀和后缀</h4><p>想为 <code>ilabx</code> 保存的 <code>mhtml</code> 文件写一个目录</p>
<p>即把 <code>P0.1.1_Welcome to edX.mhtml</code> 这样的条目写到 <code>md</code> 文件里，像这样：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">Welcome to edX</span>](<span class="link">file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P0/P0.1.1_Welcome to edX.mhtml</span>)</span><br></pre></td></tr></table></figure>

<p>首先，把所有条目写到文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vi ls.sh</span><br><span class="line">---------------------------</span><br><span class="line">  1 <span class="comment">#! /bin/bash</span></span><br><span class="line">  2 <span class="keyword">for</span> part <span class="keyword">in</span> P0 P1 P2 P3 P4 P5 P6</span><br><span class="line">  3 <span class="keyword">do</span></span><br><span class="line">  4     ls <span class="variable">$part</span> &gt; ls<span class="variable">$part</span>.txt</span><br><span class="line">  5 <span class="keyword">done</span></span><br><span class="line">---------------------------</span><br><span class="line">$ chmod +x ls.sh</span><br><span class="line">$ ./ls.sh</span><br></pre></td></tr></table></figure>

<p>然后用 <code>awk</code> 命令把格式批量转换，像这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编 程/ilabx/P0/%s)\n&quot;,$0,whole&#125;&#x27;</span> lsP0.txt | less</span><br></pre></td></tr></table></figure>

<p>因为第一个文件名要去掉前缀和扩展名，第二个是完整的文件名，所以先把 <code>$0</code> 保存到 <code>whole</code> 变量，再把 <code>$0</code> 减去多余的东西。</p>
<p>批量导出到 <code>md</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P0/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> lsP0.txt &gt; demo.md</span><br><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P1/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> lsP1.txt &gt;&gt; demo.md</span><br><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P2/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> lsP2.txt &gt;&gt; demo.md</span><br><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P3/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> lsP3.txt &gt;&gt; demo.md</span><br><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P4/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> lsP4.txt &gt;&gt; demo.md</span><br><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P5/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> lsP5.txt &gt;&gt; demo.md</span><br><span class="line">$ awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/P6/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> lsP6.txt &gt;&gt; demo.md</span><br></pre></td></tr></table></figure>

<p>感觉可以写成循环脚本，但是我不知道怎么改变 <code>awk</code> 命令中字符串中的值</p>
<p>可以先写个脚本把这些命令输出到一个另一个脚本中再执行呀</p>
<p>像这样写在 <code>awk.sh</code> 脚本中，但是有点麻烦，因为双引号要转义，要慢慢调：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> P0 P1 P2 P3 P4 P5 P6</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ls <span class="variable">$part</span> &gt; ls<span class="variable">$part</span>.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">&gt; awkstr.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> P0 P1 P2 P3 P4 P5 P6</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> -E <span class="string">&quot;&#x27;&#123;whole=\$0; split(\$0,sp1,\&quot;_\&quot;); sub(sp1[1],\&quot;\&quot;); sub(/_/,\&quot;\&quot;); sub(/\.mhtml/,\&quot;\&quot;); printf\&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/&quot;</span><span class="variable">$part</span><span class="string">&quot;/%s)\n\n\&quot;,\$0,whole&#125; END&#123;printf\&quot;\n\n\&quot;&#125;&#x27;&quot;</span> &gt;&gt; awkstr.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">awk <span class="string">&#x27;BEGIN&#123;printf&quot;#!/bin/bash\n\n&gt; demo2.md\n&quot;&#125; &#123;printf&quot;awk %s lsP%d.txt &gt;&gt; demo2.md\n&quot;,$0,$(NR-1)&#125;&#x27;</span> awkstr.txt &gt; awkcmd.sh</span><br><span class="line"></span><br><span class="line">chmod +x awkcmd.sh</span><br><span class="line">./awkcmd.sh</span><br><span class="line">/bin/rm awkstr.txt awkcmd.sh lsP*.txt</span><br></pre></td></tr></table></figure>

<p>最后的结果输出在 <code>demo2.md</code> 中。</p>
<p><strong>最终版</strong>：</p>
<p><code>awk.sh</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">file=Index.md</span><br><span class="line">&gt; <span class="variable">$&#123;file&#125;</span></span><br><span class="line">&gt; ls.txt</span><br><span class="line"><span class="built_in">echo</span> -ne <span class="string">&quot;\n\n&quot;</span> &gt;&gt; ls.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> P0 P1 P2 P3 P4 P5 P6</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ls <span class="variable">$part</span> &gt; ls<span class="variable">$part</span>.txt</span><br><span class="line">    awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;- [%s](&#x27;</span><span class="variable">$part</span><span class="string">&#x27;/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> ls<span class="variable">$part</span>.txt &gt;&gt; <span class="variable">$&#123;file&#125;</span></span><br><span class="line">    sed -n <span class="string">&#x27;/P.\..\.1\|P.\.._/p&#x27;</span> ls<span class="variable">$part</span>.txt | sed <span class="string">&#x27;s/^/\/&amp;/g&#x27;</span> | sed <span class="string">&#x27;s/$/&amp;\/i/g&#x27;</span> &gt;&gt; ls.txt</span><br><span class="line">    <span class="built_in">echo</span> -ne <span class="string">&quot;\n&quot;</span> &gt;&gt; ls.txt</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">paste -d <span class="string">&#x27;&#x27;</span> ls.txt suffix.sed &gt; mo.sed</span><br><span class="line"></span><br><span class="line">./mo.sed <span class="variable">$&#123;file&#125;</span> &gt; tmp_index.md</span><br><span class="line"></span><br><span class="line">/bin/rm lsP*.txt ls.txt mo.sed <span class="variable">$&#123;file&#125;</span></span><br><span class="line">/bin/mv tmp_index.md <span class="variable">$&#123;file&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>复制的时候小心点，不该换行的时候不要换行</p>
<p><code>suffix.sed</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sed -f</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## Part 0: Course Structure\n\n### Welcome to TUMx iLabX\n</span></span><br><span class="line">\\n\n<span class="comment">### Introduction: The Layer model\n</span></span><br><span class="line">\\n\n<span class="comment">### Setting up the environment\n</span></span><br><span class="line">\\n\n<span class="comment">### Let&#x27;s go!\n</span></span><br><span class="line"></span><br><span class="line">\\n\n<span class="comment">## Part 1: Signals and Cables\n\n### Welcome to Part 1 fo iLabX\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Layer 1\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Layer 2\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: Signals\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: Ethernet\n</span></span><br><span class="line">\\n\n<span class="comment">### You reached the destination!\n</span></span><br><span class="line"></span><br><span class="line">\\n\n<span class="comment">## Part 2: Internet Protocol\n\n### Welcome to Part 2 of iLabX\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: The Internet Protocol\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: IPv4 Basics\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: IPv6\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Supporting Protocols IPv4 and IPv6\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Static Routing and Fragmentation\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: IPv6 - Stateless Address Autoconfiguration\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: IPv6 - Forwarding, Static Routing and Fragmentation\n</span></span><br><span class="line">\\n\n<span class="comment">### Outlook Part 3\n</span></span><br><span class="line"></span><br><span class="line">\\n\n<span class="comment">## Part 3: Routing\n\n### Welcome to Part 3 of iLabX\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Routing Basics\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Distance-Vector Routing (RIP)\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Link-State Routing (OSPF)\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: The Border Gateway Protocol\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: Routing\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: Dynamic Routing\n</span></span><br><span class="line">\\n\n<span class="comment">### Outlook Part 4\n</span></span><br><span class="line"></span><br><span class="line">\\n\n<span class="comment">## Part 4: TCP and UDP\n\n### Welcome to Part 4 of iLabX\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: Layer 4 Addressing with Ports\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: UDP\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: TCP\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: UDP\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab TCP\n</span></span><br><span class="line">\\n\n<span class="comment">### Outlook Part 5\n</span></span><br><span class="line"></span><br><span class="line">\\n\n<span class="comment">## Part 5: DNS and Webservers\n\n### Welcome to Part 5 of iLabX\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: HTTP and Webservers\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab: DNS\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: Webserver Part 1\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: DNS\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab: Webserver Part 2\n</span></span><br><span class="line">\\n\n<span class="comment">### Outlook Part 6\n</span></span><br><span class="line"></span><br><span class="line">\\n\n<span class="comment">## Part 6: DNS64/NAT64 and Firewalls\n\n### Welcome to Part 6 of iLabX\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab DNS64/NAT64\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab DNS64 NAT64 Workflow\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab Packet Filering\n</span></span><br><span class="line">\\n\n<span class="comment">### PreLab IP6tabes\n</span></span><br><span class="line">\\n\n<span class="comment">### Lab Packet Filtering\n</span></span><br><span class="line">\\n\n<span class="comment">### Outlook Internet\n</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样只需要执行 <code>awk.sh</code> 脚本就可以生成 <code>md</code> 文件了</p>
<h4 id="typora-生成的网页在新标签页打开链接"><a href="#typora-生成的网页在新标签页打开链接" class="headerlink" title="typora 生成的网页在新标签页打开链接"></a>typora 生成的网页在新标签页打开链接</h4><p>在 <code>vim</code> 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/\.mhtml<span class="string">&#x27;&gt;/\.mtml&#x27;</span> target=<span class="string">&#x27;_blank&#x27;</span>&gt;/g</span><br></pre></td></tr></table></figure>



<h4 id="awk-使用-Shell-变量"><a href="#awk-使用-Shell-变量" class="headerlink" title="awk 使用 Shell 变量"></a>awk 使用 Shell 变量</h4><p>突然发现不用那么麻烦。。</p>
<p>awk 的命令字符串中可以直接引用 shell 变量，<a target="_blank" rel="noopener" href="https://linux.cn/article-7668-1.html">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat test.sh</span><br><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">&gt; demo.md</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> part <span class="keyword">in</span> P0 P1 P2 P3 P4 P5 P6</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    ls <span class="variable">$part</span> &gt; ls<span class="variable">$part</span>.txt</span><br><span class="line">    awk <span class="string">&#x27;&#123;whole=$0; split($0,sp1,&quot;_&quot;); sub(sp1[1],&quot;&quot;); sub(/_/,&quot;&quot;); sub(/\.mhtml/,&quot;&quot;); printf&quot;[%s](file:///C:/Users/11638/Documents/Linux-C文档/网络编程/ilabx/&#x27;</span><span class="variable">$part</span><span class="string">&#x27;/%s)\n\n&quot;,$0,whole&#125; END&#123;printf&quot;\n\n&quot;&#125;&#x27;</span> ls<span class="variable">$part</span>.txt &gt;&gt; demo.md</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">/bin/rm lsP*.txt</span><br></pre></td></tr></table></figure>

<p>这样简单了呀</p>
<h4 id="print和printf"><a href="#print和printf" class="headerlink" title="print和printf"></a>print和printf</h4><p>print和printf都是打印输出的，不过两者用法和显示上有些不同而已。</p>
<blockquote>
<p>print 格式：<code>print item1,item2, ...</code><br>printf格式：<code>printf “FORMAT ”,item1,item2, ...</code></p>
</blockquote>
<p><strong>要点</strong>：<br>1.逗号为分隔符时，显示的是空格；<br>2.分隔符分隔的字段（域）标记称为域标识，用 $0,$1,$2,…,$n 表示，其中 $0 为所有域，$1 就是表示第一个字段（域），以此类推；<br>3.输出的各item可以字符串，也可以是数值，当前记录的字段，变量或 awk 的表达式等；<br>4.如果省略了 item ，相当于 print $0<br>5.对于 printf 来说，必须指定 FORMAT，即必须指出后面每个itemsN的输出格式，且还不会自动换行，需要显式则指明换行控制符”\n”。</p>
<p><strong>printf的格式说明符</strong></p>
<table>
<thead>
<tr>
<th>格式说明符</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>%c</td>
<td>打印单个ASCII 字符 printf(“The character is %c\n”,x) 输出: The character is A</td>
</tr>
<tr>
<td>%d</td>
<td>打印一个十进制数 printf(“The boy is %d years old\n”,y) 输出：The boy is 15 years old</td>
</tr>
<tr>
<td>%e</td>
<td>打印数字的e 记数法形式 printf(“z is %e\n”,z) 打印: z is 2.3e+0 1</td>
</tr>
<tr>
<td>%f</td>
<td>打印一个浮点数 printf(“z is %f\n”, 2.3 * 2) 输出: z is 4.600000</td>
</tr>
<tr>
<td>%o</td>
<td>打印数字的八进制 printf(“y is %o\n”,y) 输出：z is 17</td>
</tr>
<tr>
<td>%s</td>
<td>打印一个字符串 print(“The name of the culprit is %s\n”,$1) 输出：The name of the culprit is Bob Smith</td>
</tr>
<tr>
<td>%x</td>
<td>打印数字的十六进制值 printf(“y is %x\n”,y) 输出：x is f</td>
</tr>
</tbody></table>
<p>下面的这句话语法是对的，但是在 <code>Debian</code> 里不起作用，在 <code>Ubuntu</code> 里可以。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk <span class="string">&#x27;BEGIN &#123;printf &quot;%-15sBelt\n-----------------------------\n&quot;,&quot;Name&quot;&#125; &#123;printf &quot;%-15s%-15s\n&quot;,$1,$4&#125; END &#123;print &quot;End-of-report&quot;&#125;&#x27;</span> awk.de</span><br></pre></td></tr></table></figure>

<p>试了好久，还以为是 <code>awk</code> 语法的问题。</p>
<p>不关发行版的事，是zsh的问题，在bash里正常。</p>
<p>是 <code>.zshrc</code> 配置的问题，默认正常。</p>
<p>zsh shell 标题的问题，但是我不知道怎么改</p>
<p>找到 <a target="_blank" rel="noopener" href="http://blog.pengyifan.com/how-to-set-terminal-title-dynamically-to-the-current-working-directory/">解决办法</a> 了</p>
<h4 id="if条件语句"><a href="#if条件语句" class="headerlink" title="if条件语句"></a>if条件语句</h4><p><code>&#123;if(condition)&#123;statement;…&#125;&#125;</code>：条件满足就执行statement<br><code>&#123;if(condition)&#123;statement1;…&#125;&#123;else statement2&#125;&#125;</code>：条件满足执行statement1，不满足执行statement2<br><code>&#123;if(condition1)&#123;statement1&#125;else if(condition2)&#123;statement2&#125;else&#123;statement3&#125;&#125;</code>：条件1满足执行statement2，不满足条件1但满足条件2执行statement2，所用条件都不满足就执行statement3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ awk -F: <span class="string">&#x27;$NF~/zsh/ &#123;printf &quot;%-10s%s\n&quot;,$1,$NF&#125;&#x27;</span> /etc/passwd             </span><br><span class="line">root      /usr/bin/zsh</span><br><span class="line">purian    /usr/bin/zsh</span><br><span class="line">len       /usr/bin/zsh</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面两个是一样的，因为大括号里面只有一条语句，所以可以去掉大括号。必须要以分号分隔。</span></span><br><span class="line"><span class="comment">#注意，在加上大括号的时候，不可以加分号。</span></span><br><span class="line"><span class="comment">#这里和上面的 模式+行为 之间不同，要特别注意</span></span><br><span class="line">$ awk -F: <span class="string">&#x27;&#123;if($3&gt;=1000)&#123;printf &quot;Common user: %20s\n&quot;,$1&#125;else&#123;printf &quot;Root or Sysuser: %20s\n&quot;,$1&#125;&#125;&#x27;</span> /etc/passwd</span><br><span class="line">$ awk -F: <span class="string">&#x27;&#123;if($3&gt;=1000) printf &quot;Common user: %20s\n&quot;,$1;else printf &quot;Root or Sysuser: %20s\n&quot;,$1&#125;&#x27;</span> /etc/passwd</span><br><span class="line"></span><br><span class="line">$ awk -F: <span class="string">&#x27;&#123;if($3&gt;=1000 &amp;&amp; $3&lt;65530)&#123;printf &quot;%11s:  \t%-10s\n&quot;,&quot;Common user&quot;,$1&#125;else if($3==0)&#123;printf &quot;%11s:  \t%-10s\n&quot;,&quot;Super user&quot;,$1&#125;&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p><code>while(condition)&#123;statement;…&#125;</code>：条件为“真”时，进入循环；条件为“假”时， 退出循环</p>
<p><code>do &#123;statement;…&#125;while(condition)</code>：无论真假，至少执行一次循环体。当条件为“真”时，退出循环；条件为“假”时，继续循环</p>
<p><code>for(expr1;expr2;expr3) &#123;statement;…&#125;</code>：expr1为变量赋值，如var=value，初始进行变量赋值；expr2为条件判断语句，j&lt;=10，满足条件就继续执行statement；expr3为迭代语句，如j++，每次执行完statement后就迭代增加</p>
<p><code>for(var in array) &#123;for-body&#125;</code>：变量var遍历数组，每个数组中的var都会执行一次for-body。</p>
<h4 id="1和0"><a href="#1和0" class="headerlink" title="1和0"></a>1和0</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ seq 10 | awk <span class="string">&#x27;i=0&#x27;</span>           <span class="comment">#这里i被赋值为0，也就是说模式判定为假</span></span><br><span class="line">$ seq 10 | awk <span class="string">&#x27;i=1&#x27;</span>           <span class="comment">#真，其它数字都真</span></span><br><span class="line">$ seq 10 | awk <span class="string">&#x27;i=!i&#x27;</span>          <span class="comment">#输出奇数行</span></span><br><span class="line">$ seq 10 | awk <span class="string">&#x27;!(i=!i)&#x27;</span>       <span class="comment">#输出偶数行</span></span><br><span class="line">$ seq 10 | awk <span class="string">&#x27;BEGIN&#123;i=1&#125;; i=!i&#x27;</span>     <span class="comment">#输出偶数行</span></span><br></pre></td></tr></table></figure>

<p>在awk中，以下3种情况是“假”，其他情况都为“真” ( c 语言中不是这样，只有 0 和 NULL )</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1) 数字 0</span><br><span class="line">2) 空字符串</span><br><span class="line">3) 未定义的值</span><br></pre></td></tr></table></figure>
</blockquote>
<p>你或许想问下面的表达式为真还是为假：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ seq 10 | awk <span class="string">&#x27;i=0; i=1&#x27;</span></span><br><span class="line">$ seq 10 | awk <span class="string">&#x27;i=1; i=0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>它们好像都为真，因为它们都能输出所有的行。但是，并不是这样，</p>
<p>这两个式子都是由分号来分隔两个 <code>模式+行为</code> ，<a href="#%E6%80%BB%E7%BB%93">上面</a>讲过了。所以总是 <code>i=1</code> 的时候打印所有行，而 <code>i=0</code> 的时候不匹配。</p>
<p>所以，下面的才是一个 <code>模式+行为</code> 里的表达式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ seq 3 | awk <span class="string">&#x27;i=0, i=1&#x27;</span>                                                                </span><br><span class="line">$ seq 3 | awk <span class="string">&#x27;i=1, i=0&#x27;</span>                                                                 </span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<p>c语言提供一种特殊的运算符，逗号运算符，从左往右逐个计算表达式，整个表达式的值为最后一个表达式的值。</p>
<p>但是这里好像相反欸。而且这个式子写三项就报错。</p>
<h3 id="sed-文本过滤工具"><a href="#sed-文本过滤工具" class="headerlink" title="sed - 文本过滤工具"></a>sed - 文本过滤工具</h3><p>这个<a target="_blank" rel="noopener" href="https://www.runoob.com/linux/linux-comm-sed.html">讲解</a>比较好。</p>
<p>还有<a target="_blank" rel="noopener" href="https://blog.csdn.net/wdz306ling/article/details/80087889">这个</a>，虽然还没看，不过看上去讲得挺多的。</p>
<p><a target="_blank" rel="noopener" href="http://akaedu.github.io/book/ch32s03.html">Linux C 一站式编程</a> 这个讲得很系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;&#x27;</span> sed.de               <span class="comment">#默认打印</span></span><br><span class="line">1   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">4   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">5   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ sed -n <span class="string">&#x27;&#x27;</span> sed.de            <span class="comment">#只打印匹配的行</span></span><br><span class="line">$ sed <span class="string">&#x27;2p&#x27;</span> sed.de             <span class="comment">#把第二行多打印了一遍</span></span><br><span class="line">1   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">4   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">5   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ sed -n <span class="string">&#x27;2p&#x27;</span> sed.de          <span class="comment">#只打印匹配的第二行</span></span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">$ sed -n <span class="string">&#x27;1,3p&#x27;</span> sed.de        <span class="comment">#打印一到三行</span></span><br><span class="line">1   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印包含指定单词的一行并打印</span></span><br><span class="line"><span class="comment">#由此可见 p 可以写到单引号的外面</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/Bunny/&#x27;</span>p sed.de</span><br><span class="line">P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line"></span><br><span class="line"><span class="comment">#从第3行打印到第一次匹配的行</span></span><br><span class="line">$ sed -n <span class="string">&#x27;3,/Brown/&#x27;</span>p sed.de</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">4   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line"></span><br><span class="line"><span class="comment">#打印从第4行到最后一行</span></span><br><span class="line">$ sed -n <span class="string">&#x27;4,$&#x27;</span>p sed.de</span><br><span class="line">4   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">5   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"></span><br><span class="line"><span class="comment">#匹配任意字母(.)，重复0次或者无数次(*)，包含ow，后面跟着一个空格</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/.*ow /&#x27;</span>p sed.de</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line"></span><br><span class="line"><span class="comment">#只打印匹配的行号，注意没有 p</span></span><br><span class="line">$ sed -n <span class="string">&#x27;/.*ow /=&#x27;</span> sed.de</span><br><span class="line">3</span><br><span class="line"><span class="comment">#如果要打印行号及匹配行，必须使用两个sed命令</span></span><br><span class="line">$ sed -n -e <span class="string">&#x27;/.*ow /p&#x27;</span>  -e <span class="string">&#x27;/.*ow /=&#x27;</span> sed.de                                             </span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#添加新行</span></span><br><span class="line"><span class="comment">#注意，实际的文本并没有变化</span></span><br><span class="line"><span class="comment">#去掉 3a 后面的 \ 也可以，或者换成空格</span></span><br><span class="line"><span class="comment"># \n 被识别成换行符了。。</span></span><br><span class="line">$ sed -e <span class="string">&#x27;3a\newline1\newline2\newline3&#x27;</span> sed.de</span><br><span class="line">1   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">newline1</span><br><span class="line">ewline2</span><br><span class="line">ewline3</span><br><span class="line">4   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">5   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"><span class="comment">#加到第三行之前</span></span><br><span class="line">$ sed -e <span class="string">&#x27;3i newline1\newline2\newline3&#x27;</span> sed.de</span><br><span class="line"><span class="comment">#如果想要加两行要这样写</span></span><br><span class="line">$ sed <span class="string">&#x27;3i line1\</span></span><br><span class="line"><span class="string">&gt; line2&#x27;</span> sed.de</span><br><span class="line">1   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">4   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">5   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#将 /etc/passwd 的内容列出并且列印行号，同时，将第 3~25 行删除</span></span><br><span class="line"><span class="comment">#原本应该是 sed -e 才对，没有 -e 也可以</span></span><br><span class="line">$ nl /etc/passwd | sed <span class="string">&#x27;3,25d&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/usr/bin/zsh</span><br><span class="line">     2  daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</span><br><span class="line">    26  len:x:1001:1001::/home/len:/usr/bin/zsh</span><br><span class="line">    </span><br><span class="line"><span class="comment">#数据行整行取代</span></span><br><span class="line">$ sed  <span class="string">&#x27;2,4c No.2-4 Line&#x27;</span> sed.de</span><br><span class="line">1   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">No.2-4 Line</span><br><span class="line">5   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"></span><br><span class="line"><span class="comment">#搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把zsh替换为bash，再输出这行;    \/转义    p打印    q退出</span></span><br><span class="line">$ nl /etc/passwd | sed -n <span class="string">&#x27;/root/&#123;s/usr\/bin\/zsh/bin\/bash/;p;q&#125;&#x27;</span></span><br><span class="line">     1  root:x:0:0:root:/root:/bin/bash</span><br><span class="line">     </span><br><span class="line"><span class="comment">#本机ip</span></span><br><span class="line">$ ifconfig eth0 | grep <span class="string">&#x27;inet &#x27;</span> | sed <span class="string">&#x27;s/^.*inet //g&#x27;</span> | sed <span class="string">&#x27;s/netmask.*$//g&#x27;</span></span><br><span class="line">172.21.45.70</span><br><span class="line"><span class="comment">#ipv6</span></span><br><span class="line">$ ifconfig eth0 | grep <span class="string">&#x27;inet6 &#x27;</span> | sed <span class="string">&#x27;s/^.*inet6 //g&#x27;</span> | sed <span class="string">&#x27;s/prefixlen.*$//g&#x27;</span></span><br><span class="line">fe80::e01b:a9b1:deed:4505</span><br><span class="line"><span class="comment">#这个需要观察，然后根据输出的格式，来删除多余的内容</span></span><br></pre></td></tr></table></figure>

<p>如果想把上面两个命令设为别名，要把命令中的 <code>&#39;</code> 替换成 <code>&#39;&quot;&#39;&quot;&#39;</code> ，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ipv4=<span class="string">&#x27;ifconfig eth0 | grep &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;inet &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27; | sed &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;s/^.*inet //g&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27; | sed &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;s/netmask.*$//g&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ipv6=<span class="string">&#x27;ifconfig eth0 | grep &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;inet6 &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27; | sed &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;s/^.*inet6 //g&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27; | sed &#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;s/prefixlen.*$//g&#x27;</span><span class="string">&quot;&#x27;&quot;</span><span class="string">&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1250079/how-to-escape-single-quotes-within-single-quoted-strings">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ nl /etc/passwd | sed -e <span class="string">&#x27;3,$d&#x27;</span> -e <span class="string">&#x27;s/bash/blueshell/&#x27;</span>  <span class="comment">#这里执行了两个动作，删除3到最后一行，并替换bash</span></span><br><span class="line">1  root:x:0:0:root:/root:/bin/blueshell</span><br><span class="line">2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh</span><br></pre></td></tr></table></figure>

<h4 id="直接修改文件内容"><a href="#直接修改文件内容" class="headerlink" title="直接修改文件内容"></a>直接修改文件内容</h4><p>sed 可以使用 <code>-i</code> 选项直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万<strong>不要随便拿系统配置来测试</strong>！ 我们还是使用文件 sed.de 文件来测试看看吧！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cat sed.de                                                                             </span><br><span class="line">1   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">2   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">3   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">4   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">5   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line">$ sed -i <span class="string">&#x27;s/^.//g&#x27;</span> sed.de                                                                 </span><br><span class="line">$ cat sed.de                                                                             </span><br><span class="line">   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"><span class="comment">#添加最后一行</span></span><br><span class="line">$ sed -i <span class="string">&#x27;$a # End of the file&#x27;</span> sed.de</span><br><span class="line">$ cat sed.de                                                                             </span><br><span class="line">   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">   J.Lulu       06/99    48317    green    9    24    26</span><br><span class="line">   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"><span class="comment"># End of the file</span></span><br></pre></td></tr></table></figure>

<p>sed 的 <strong>-i</strong> 选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！</p>
<h4 id="替换字符串"><a href="#替换字符串" class="headerlink" title="替换字符串"></a>替换字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/Lulu/lulu/g&#x27;</span> sed.de                       <span class="comment">#打印所有行，g是全局替换</span></span><br><span class="line">   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">   J.lulu       06/99    48317    green    9    24    26</span><br><span class="line">   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"><span class="comment"># End of the file</span></span><br><span class="line">$ sed <span class="string">&#x27;s/Lulu/lulu/gp&#x27;</span> sed.de                      <span class="comment">#p把替换的那一行多打印了一份</span></span><br><span class="line">   M.Tansley    05/99    48311    Green    8    40    44</span><br><span class="line">   J.lulu       06/99    48317    green    9    24    26</span><br><span class="line">   J.lulu       06/99    48317    green    9    24    26</span><br><span class="line">   P.Bunny      02/99    48       Yellow   12   35    28</span><br><span class="line">   J.Troll      07/99    4842     Brown-3  12   26    26</span><br><span class="line">   L.Tansley    05/99    4712     Brown-2  12   30    28</span><br><span class="line"><span class="comment"># End of the file</span></span><br><span class="line">$ sed -n <span class="string">&#x27;s/Lulu/lulu/g&#x27;</span> sed.de                    <span class="comment">#n不打印，这个和上面的不一样呀</span></span><br><span class="line">$ sed -n <span class="string">&#x27;s/Lulu/lulu/gp&#x27;</span> sed.de                   <span class="comment">#同时有-n和p才能只打印修改行</span></span><br><span class="line">   J.lulu       06/99    48317    green    9    24    26                                 </span><br><span class="line">$ sed -n <span class="string">&#x27;s/Lulu/lulu/gw sed.out&#x27;</span> sed.de ; cat sed.out     <span class="comment">#w写入文件，可以看到输出的只有被替换的文本，和前面的标准输出无关，即无论前面用什么参数，文件里的内容都一样</span></span><br><span class="line">   J.lulu       06/99    48317    green    9    24    26</span><br></pre></td></tr></table></figure>

<p>这个可以用来删除字符串哒，删除整行用d参数，比如 <code>$d</code> 删除最后一行。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ awk <span class="string">&#x27;$1 ~ /ipv6/ &#123;printf(&quot;%s(%s) -&gt; %s(%s)\n&quot;,$6,$8,$7,$9)&#125;&#x27;</span> ipv.txt | sed <span class="string">&#x27;s/src=\|dst=//g&#x27;</span>  <span class="comment">#同时替换 src= 和 dst= 成空，也就是删除</span></span><br></pre></td></tr></table></figure>

<p>居然还支持转义符，没想到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | sed <span class="string">&#x27;s/:/\n/g&#x27;</span></span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | tr <span class="string">&quot;:&quot;</span> <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>



<h4 id="非贪婪匹配-处理带颜色日志"><a href="#非贪婪匹配-处理带颜色日志" class="headerlink" title="非贪婪匹配 - 处理带颜色日志"></a>非贪婪匹配 - 处理带颜色日志</h4><p>似乎正则表达式的非贪婪匹配很麻烦，但是有迂回方法：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[[1m^[[7m%^[[27m^[[1m^[[0m</span><br></pre></td></tr></table></figure>

<p>这个要把颜色标记去掉，</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;s|^[\[[^m]*m||g&#x27;</span> screenlog.1 &gt; scr.txt</span><br></pre></td></tr></table></figure>

<p>第一个 <code>^[</code> 是特殊字符，关键点在于用 <code>[^m]*m</code> 来实现非贪婪匹配</p>
<h4 id="指定行之间的内容替换"><a href="#指定行之间的内容替换" class="headerlink" title="指定行之间的内容替换"></a>指定行之间的内容替换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="string">&#x27;21,51s# &quot;.*$# #p&#x27;</span> vimrc   <span class="comment">#把21到51行之间，以空格、双引号开头，到这一行最后的内容全部替换掉</span></span><br><span class="line"><span class="built_in">set</span> number</span><br><span class="line"><span class="built_in">set</span> ruler</span><br><span class="line"><span class="built_in">set</span> showcmd</span><br><span class="line"><span class="built_in">set</span> tabstop</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> cindent</span><br><span class="line"><span class="built_in">set</span> ignorecase smartcase</span><br><span class="line"><span class="built_in">set</span> wrapscan</span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"><span class="built_in">set</span> incsearch</span><br><span class="line"><span class="built_in">set</span> showmatch</span><br><span class="line"><span class="built_in">set</span> matchtime=2</span><br><span class="line"><span class="built_in">set</span> scrolloff=5</span><br><span class="line"><span class="built_in">set</span> wildmenu</span><br><span class="line"><span class="built_in">set</span> showmode</span><br><span class="line"><span class="built_in">set</span> wrap</span><br><span class="line"><span class="built_in">set</span> noerrorbells</span><br><span class="line"><span class="built_in">set</span> updatetime=1000</span><br><span class="line"><span class="built_in">set</span> fdm=manual</span><br><span class="line"><span class="string">&quot;set list</span></span><br><span class="line"><span class="string">$ sed -i &#x27;21,51s# &quot;</span>.*<span class="variable">$#</span> <span class="comment">#&#x27; vimrc  #这才真正替换，注意后面没有p打印，不然每行会重复一遍</span></span><br></pre></td></tr></table></figure>

<h4 id="删掉所有汉字"><a href="#删掉所有汉字" class="headerlink" title="删掉所有汉字"></a>删掉所有汉字</h4><p>其实我本来是想删掉所有汉字注释的，在服务器里汉字显示得很诡异</p>
<p>但是，这条命令用不了（明明在我这里好好的）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ LANG=C sed -n <span class="string">&quot;s/[\x81-\xFE][\x40-\xFE]//g&quot;</span>p vimrc</span><br><span class="line">$ LANG=C sed -i <span class="string">&quot;s/[\x81-\xFE][\x40-\xFE]//g&quot;</span> vimrc</span><br></pre></td></tr></table></figure>



<h4 id="批量替换文本"><a href="#批量替换文本" class="headerlink" title="批量替换文本"></a>批量替换文本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#有两个文件，file1,file2</span></span><br><span class="line">$ cat file/file1 file/file2</span><br><span class="line">qwert</span><br><span class="line">qwert</span><br><span class="line"></span><br><span class="line"><span class="comment">#批量替换</span></span><br><span class="line">$ sed <span class="string">&#x27;s/qwert/yuiop/g&#x27;</span> `grep qwert -rl ./file`  <span class="comment">#-r 表示搜索子目录，-l 表示输出匹配的文件名</span></span><br><span class="line">yuiop</span><br><span class="line">yuiop</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接修改文本用-i选项</span></span><br><span class="line">$ sed -i <span class="string">&#x27;s/qwert/yuiop/g&#x27;</span> `ls file/*`   <span class="comment">#把要修改的文件放在单独的目录然后用 ls dir/* 列出路径，这样既安全不会出错，速度又快，你不知道用grep查找所有文件里的内容的速度有多慢</span></span><br><span class="line">$ cat file/*</span><br><span class="line">yuiop</span><br><span class="line">yuiop</span><br></pre></td></tr></table></figure>

<h4 id="批量修改文件名"><a href="#批量修改文件名" class="headerlink" title="批量修改文件名"></a>批量修改文件名</h4><p>把当前目录下所有文件名的有2的，换成3</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="string">&#x27;s/2/3/&#x27;</span> *</span><br></pre></td></tr></table></figure>



<h4 id="附加字符串"><a href="#附加字符串" class="headerlink" title="附加字符串"></a>附加字符串</h4><p>命令类似于替换，但是加了 <code>&amp;</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/[0-9][0-9]*/&amp; Passed/g&#x27;</span> ok.txt   <span class="comment">#这里的&amp;，就代表前面匹配的内容，注意[0-9][0-9]*,这样写保证至少匹配一次</span></span><br><span class="line">AC343 Passed</span><br><span class="line">AC3843 Passed</span><br><span class="line">AC39832 Passed</span><br><span class="line">AKD38 Passed</span><br><span class="line">$ sed <span class="string">&#x27;s/[0-9][0-9]*/ Passed &amp;/g&#x27;</span> ok.txt  <span class="comment">#换一下&amp;的位置</span></span><br><span class="line">AC Passed 343</span><br><span class="line">AC Passed 3843</span><br><span class="line">AC Passed 39832</span><br><span class="line">AKD Passed 38</span><br></pre></td></tr></table></figure>

<h4 id="添加、删除扩展名"><a href="#添加、删除扩展名" class="headerlink" title="添加、删除扩展名"></a>添加、删除扩展名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;demo&quot;</span> | sed <span class="string">&#x27;s/$/&amp;.txt/g&#x27;</span>  <span class="comment">#$表示尾字符</span></span><br><span class="line">demo.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;demo&quot;</span> | sed <span class="string">&#x27;s/$/&amp;.txt/g&#x27;</span> | sed <span class="string">&#x27;s/\..*//g&#x27;</span> <span class="comment">#\.是转义的.，后面的.是匹配任意字符</span></span><br><span class="line">demo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#突然发现下面两个也可以</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;demo&quot;</span> | sed <span class="string">&#x27;s/$/.txt/g&#x27;</span></span><br><span class="line">demo.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;demo&quot;</span> | sed <span class="string">&#x27;s/$/.txt&amp;/g&#x27;</span></span><br><span class="line">demo.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#所以这个就是加前缀咯</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;demo&quot;</span> | sed <span class="string">&#x27;s/^/txt./g&#x27;</span>   <span class="comment">#这里的.可不是元字符呀，前面是模式匹配，后面就是单纯的字符串</span></span><br><span class="line">txt.demo</span><br></pre></td></tr></table></figure>



<h4 id="替换控制字符（sed-脚本）"><a href="#替换控制字符（sed-脚本）" class="headerlink" title="替换控制字符（sed 脚本）"></a>替换控制字符（sed 脚本）</h4><p>输入控制字符</p>
<ul>
<li>vi file</li>
<li>进入输入模式</li>
<li><kbd>Ctrl</kbd>+<kbd>v</kbd></li>
<li>输入控制字符，比如说 <code>F1</code> 或者 <code>Enter</code></li>
<li>文件中就会出现类似于 <code>^[OP</code>  <code>^M</code> 这样的字符</li>
<li>这些就是控制字符，用cat命令显示不出来，只是空白</li>
<li>但是用 <code>cat -v file</code> 就可以显示出来</li>
</ul>
<p>替换</p>
<ul>
<li>输入 <code>sed &#39;s/</code> </li>
<li><kbd>Ctrl</kbd>+<kbd>v</kbd></li>
<li>按下控制字符</li>
<li>然后输入 <code>//g&#39; file</code> 补完就可以了</li>
</ul>
<p>如果要替换一个文件里的很多处内容，在shell里命令很麻烦，因为要用管道线不断地处理。写在 sed 脚本里会好很多。下面是一个例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#! /bin/sed -f</span></span><br><span class="line">s/<span class="comment">##//g</span></span><br><span class="line">s/^0*//g</span><br><span class="line">s/^M//g                <span class="comment">#这里的^M是控制字符，要用Ctrl+v,再按Enter输入</span></span><br><span class="line"><span class="comment">#注意要给这个文件执行权限</span></span><br></pre></td></tr></table></figure>

<p>还有一个综合的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ cat sql.de                <span class="comment">#这个是原始的数据文件</span></span><br><span class="line">database    size(MB)    date created</span><br><span class="line">------------------------------------</span><br><span class="line">gosouth     2244        12/11/97</span><br><span class="line">trisud      5632        8/9/99</span><br><span class="line"></span><br><span class="line">(2 rows affected)</span><br><span class="line">$ cat sql.sed               <span class="comment">#用sed脚本把乱七八糟的行删掉</span></span><br><span class="line"><span class="meta">#! /bin/sed -f</span></span><br><span class="line">s/-*//g                     <span class="comment">#删除----线</span></span><br><span class="line">/^$/d                       <span class="comment">#删除空行</span></span><br><span class="line"><span class="variable">$d</span>                          <span class="comment">#删除最后一行</span></span><br><span class="line">1d                          <span class="comment">#删除第一行</span></span><br><span class="line">$ cat sql.sh                <span class="comment">#用shell脚本调用sed和awk命令打印出处理后的第一列</span></span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">./sql.sed sql.de | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">$ ./sql.sh                  <span class="comment">#将两个脚本赋予执行权限，再直接执行就可以了</span></span><br><span class="line">gosouth</span><br><span class="line">trisud</span><br><span class="line"><span class="comment">#感觉很有意思有没有</span></span><br></pre></td></tr></table></figure>

<h4 id="从shell向sed传字符串"><a href="#从shell向sed传字符串" class="headerlink" title="从shell向sed传字符串"></a>从shell向sed传字符串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ NAME=<span class="string">&quot;Is&#x27;s a go situation&quot;</span></span><br><span class="line">$ REPLACE=<span class="string">&quot;GO&quot;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$NAME</span> | sed <span class="string">&quot;s/go/<span class="variable">$REPLACE</span>/g&quot;</span></span><br><span class="line">Is<span class="string">&#x27;s a GO situation</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">#知道为什么要用双引号吗？</span></span><br><span class="line"><span class="string">$ echo $NAME | sed &#x27;</span>s/go/<span class="variable">$REPLACE</span>/g<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Is&#x27;</span>s a <span class="variable">$REPLACE</span> situation</span><br><span class="line"></span><br><span class="line">$ NEWNAME=`<span class="built_in">echo</span> <span class="variable">$NAME</span> | sed <span class="string">&quot;s/go/<span class="variable">$REPLACE</span>/g&quot;</span>` <span class="comment">#把这条语句执行结果赋值给NEWNAME</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$NEWNAME</span></span><br><span class="line">Is<span class="string">&#x27;s a GO situation</span></span><br></pre></td></tr></table></figure>

<h4 id="将换行符转换为空格"><a href="#将换行符转换为空格" class="headerlink" title="将换行符转换为空格"></a>将换行符转换为空格</h4><p>本来我以为这样就可以了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="string">&#x27;s/\n/ /g&#x27;</span> tmp.txt</span><br></pre></td></tr></table></figure>

<p>但是，sed是按行处理文本数据的，每次处理一行数据后，都会在行尾自动添加trailing newline，其实就是行的分隔符即换行符。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36462472/article/details/80370719">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://my.oschina.net/shelllife/blog/118337">这个</a> 更详细一点</p>
<p>所以还是用 <code>tr</code> 更方便一点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat tmp.txt | tr <span class="string">&quot;\n&quot;</span> <span class="string">&quot; &quot;</span> &gt; tmp2.txt       <span class="comment">#将换行符转换成空格</span></span><br></pre></td></tr></table></figure>



<h4 id="添加空行"><a href="#添加空行" class="headerlink" title="添加空行"></a>添加空行</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangsuxia/p/3382410.html">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed G tmp.txt       <span class="comment">#每行后面添加一行空行</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">一、每行前后添加空行</span><br><span class="line"></span><br><span class="line">1.每行后面添加一行空行：</span><br><span class="line"></span><br><span class="line">  sed  G  tmp</span><br><span class="line"></span><br><span class="line"> 每行前面添加一行空行：</span><br><span class="line"></span><br><span class="line">  sed  ‘&#123;x;p;x;&#125;’ tmp</span><br><span class="line"></span><br><span class="line">2.每行后面添加两行空行：</span><br><span class="line"></span><br><span class="line">  sed  ‘G;G’  tmp</span><br><span class="line"></span><br><span class="line"> 每行前面添加两行空行：</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;&#123;x;p;x;x;p;x;&#125;&#x27;</span> tmp</span><br><span class="line"></span><br><span class="line">3.每行后面添加三行空行：</span><br><span class="line"></span><br><span class="line">  sed  ‘G;G;G’  tmp</span><br><span class="line"></span><br><span class="line">  每行前面添加三行空行：</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;&#123;x;p;x;x;p;x;x;p;x&#125;&#x27;</span> tmp</span><br><span class="line"></span><br><span class="line">依次类推，添加几行空行，就有几个G或者x;p;x</span><br><span class="line"></span><br><span class="line">二、如果行后有空行，则删除，然后每行后面添加空行</span><br><span class="line"></span><br><span class="line">  sed  <span class="string">&#x27;/^$/d;G&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line">三、在匹配行前后添加空行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;/shui/G&#x27;</span> tmp  如果一行里面有shui这个单词，那么在他后面会添加一个空行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;/shui/&#123;x;p;x;G&#125;&#x27;</span> tmp 如果一行里面有shui这个单词，那么在他前后各添加一个空行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;/shui/&#123;x;p;x;&#125;&#x27;</span> tmp 如果一行里面有shui这个单词，那么在他前面添加一个空行</span><br><span class="line"></span><br><span class="line">  sed ‘1&#123;x;p;x;&#125;’ tmp 在第一行前面添加空行，想在第几行，命令中的1就改成几</span><br><span class="line"></span><br><span class="line">  sed ‘1G’ tmp 在第一行后面添加空行，想在第几行，命令中的1就改成几</span><br><span class="line"></span><br><span class="line">四、每几行后面添加一个空行</span><br><span class="line"></span><br><span class="line">1.每两行后面增加一个空行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;N;/^$/d;G&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line"> 每两行前面添加一个空行</span><br><span class="line"></span><br><span class="line">  sed  <span class="string">&#x27;N;/^$/d;&#123;x;p;x;&#125;&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line">2.每三行后面增加一个空行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;N;N;/^$/d;G&#x27;</span> file.txt</span><br><span class="line"></span><br><span class="line">  每三行前面增加一个空行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;N;N;/^$/d;&#123;x;p;x;&#125;&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line">五、以x为开头或以x为结尾的行前后添加空行</span><br><span class="line"></span><br><span class="line">1.以xi为开头的行后面添加空行</span><br><span class="line"></span><br><span class="line">   sed  <span class="string">&#x27;/^xi/G;&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line"> 以xi为结尾的行前面添加空行</span><br><span class="line"></span><br><span class="line">   sed  <span class="string">&#x27;/^xi/&#123;x;p;x;&#125;&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line">2.以xi为结尾的行后面添加空行</span><br><span class="line"></span><br><span class="line">   sed  <span class="string">&#x27;/xi$/G;&#x27;</span> tmp</span><br><span class="line"></span><br><span class="line"> 以xi为结尾的行后面添加空行</span><br><span class="line"></span><br><span class="line">   sed  <span class="string">&#x27;/xi$/&#123;x;p;x;&#125;&#x27;</span> tmp</span><br></pre></td></tr></table></figure>

<h4 id="打印和删除特定行"><a href="#打印和删除特定行" class="headerlink" title="打印和删除特定行"></a>打印和删除特定行</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yangsuxia/p/3382897.html">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">一、打印打印奇数行（删除偶数行）或者偶数行（删除奇数行）</span><br><span class="line"></span><br><span class="line">1.仅打印奇数行</span><br><span class="line"></span><br><span class="line">  sed ‘n;d’ tmp</span><br><span class="line"></span><br><span class="line">2.仅打印偶数行</span><br><span class="line"></span><br><span class="line">  sed -n ‘n;p’ tmp</span><br><span class="line"></span><br><span class="line">二、打印包含某单词的行</span><br><span class="line"></span><br><span class="line">  sed -n ‘/word/p’ tmp</span><br><span class="line"></span><br><span class="line">三、打印以某单词开头的行</span><br><span class="line"></span><br><span class="line">  sed -n ‘/^word/p’ tmp</span><br><span class="line"></span><br><span class="line">四、打印以某单词结尾的行</span><br><span class="line"></span><br><span class="line">  sed -n ‘/word$/p’ tmp</span><br><span class="line"></span><br><span class="line">五、删除所有空行</span><br><span class="line"></span><br><span class="line">  sed ‘/^$/d’ tmp</span><br><span class="line"></span><br><span class="line">六、显示第1行或第2行到第5行</span><br><span class="line"></span><br><span class="line">  sed -n ‘1p’ tmp</span><br><span class="line"></span><br><span class="line">  sed -n ‘2,5p’ tmp 或者 sed -n ‘6q,2,5p’ tmp  后者比前者效率高很多</span><br><span class="line"></span><br><span class="line">当只需要显示文件的前面的部分或需要删除后面的内容时，可以在脚本中使用“q”命令（退出命令）。在处理大的文件时，这会节省大量时间。</span><br><span class="line"></span><br><span class="line">七、打印同时匹配xiang和le（只有两者同时出现时，才能打印出来）的行</span><br><span class="line"></span><br><span class="line">  sed -n ‘/xiang/&#123;/le/p&#125;’ tmp</span><br><span class="line"></span><br><span class="line">八、打印匹配xiang或le（当一行中有xiang或者le或者既有xiang也有le的行匹配出来并打印）的行</span><br><span class="line"></span><br><span class="line">  sed -n ‘/\(xiang\|le\)/p’ tmp </span><br><span class="line"></span><br><span class="line">九、打印特定行（匹配文本中第一个出现wo的单词的行，到第一个出现jia的单词的行之间的行，如果只有wo的单词的行，没有jia的单词匹配的行，则匹配wo单词的行到后面所有的行，如果没有wo的单词的行，那么就哪行也匹配不上）</span><br><span class="line"></span><br><span class="line">  sed -n <span class="string">&#x27;/wo/,/jia/p&#x27;</span> tmp</span><br><span class="line"></span><br><span class="line">十、打印匹配wo或者Wo的行</span><br><span class="line"></span><br><span class="line">  sed -n ‘/[w|W]o/p’tmp</span><br><span class="line"></span><br><span class="line">十一、打印不挨着也没有规律的行（例如第2行和第5行）</span><br><span class="line"></span><br><span class="line">  sed -n <span class="string">&#x27;2p;5p&#x27;</span> tmp</span><br><span class="line"></span><br><span class="line">十二、 删除文件顶部的所有空行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;/./,$!d&#x27;</span> tmp 或者   sed -n <span class="string">&#x27;/./,$p&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line">十三、显示包含特定字符个数的行</span><br><span class="line"></span><br><span class="line"> 1.显示包含50个或以上字符的行</span><br><span class="line"></span><br><span class="line">  sed -n <span class="string">&#x27;/^.\&#123;50\&#125;/p&#x27;</span> tmp</span><br><span class="line"></span><br><span class="line"> 2.显示包含50个以下字符的行</span><br><span class="line"></span><br><span class="line">  sed -n <span class="string">&#x27;/^.\&#123;50\&#125;/!p&#x27;</span> tmp 或者 sed <span class="string">&#x27;/^.\&#123;50\&#125;/d&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line">十四、显示或删除特定倍数的行</span><br><span class="line"></span><br><span class="line"> 1.显示3的倍数的行</span><br><span class="line"></span><br><span class="line">  sed -n <span class="string">&#x27;n;n;p;&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line"> 2.删除3的倍数的行</span><br><span class="line"></span><br><span class="line">  sed <span class="string">&#x27;n;n;d;&#x27;</span>  tmp</span><br><span class="line"></span><br><span class="line">十五、从第3行开始，每4行显示一次</span><br><span class="line"></span><br><span class="line">  sed -n <span class="string">&#x27;3,$&#123;p;n;n;n;&#125;&#x27;</span> tmp</span><br></pre></td></tr></table></figure>



<h4 id="把文章每一句话换一行"><a href="#把文章每一句话换一行" class="headerlink" title="把文章每一句话换一行"></a>把文章每一句话换一行</h4><p>两个脚本要赋予分行权限</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat mo.sh</span><br><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line">cat tmp.txt | tr <span class="string">&quot;\n&quot;</span> <span class="string">&quot; &quot;</span> &gt; tmp2.txt       <span class="comment">#将换行符转换成空格</span></span><br><span class="line">./mo.sed tmp2.txt</span><br><span class="line">sed G tmp2.txt       <span class="comment">#每行后面添加一行空行</span></span><br><span class="line"></span><br><span class="line">$ cat mo.sed</span><br><span class="line"><span class="meta">#! /bin/sed -f</span></span><br><span class="line">s/e\.g\. /e+g/g                            <span class="comment">#e.g. 应该排除，先把它转换成文章中不会出现的 e+g</span></span><br><span class="line">s/\. /\.\n/g</span><br><span class="line">s/e+g/e\.g\. /g                            <span class="comment">#再换过来</span></span><br><span class="line">s/\? /\?\n/g</span><br><span class="line">s/! /!\n/g</span><br></pre></td></tr></table></figure>

<p>把原文章复制到 <code>tmp.txt</code> 中，执行 <code>./mo.sh</code> 就可以了</p>
<h4 id="匹配行之前-后添加一-多行"><a href="#匹配行之前-后添加一-多行" class="headerlink" title="匹配行之前/后添加一/多行"></a>匹配行之前/后添加一/多行</h4><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011304615/article/details/71450847">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配行前加</span></span><br><span class="line">sed -i <span class="string">&#x27;/allow 361way.com/iallow www.361way.com&#x27;</span> the.conf.file</span><br><span class="line"><span class="comment">#匹配行前后</span></span><br><span class="line">sed -i <span class="string">&#x27;/allow 361way.com/aallow www.361way.com&#x27;</span> the.conf.file</span><br></pre></td></tr></table></figure>

<p>这里的 <code>i</code> 和 <code>a</code> 居然没有任何转义，<del>也就是说，在替换时也小心</del>，不用担心，替换的格式和这个不一样</p>
<p>在书写的时候为便与区分，往往会在 i 和 a 前面加一个反加一个反斜扛（在 sed 脚本里不能这么写）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配行前加</span></span><br><span class="line">sed -i <span class="string">&#x27;/allow 361way.com/i\allow www.361way.com&#x27;</span> the.conf.file</span><br><span class="line"><span class="comment">#匹配行前后</span></span><br><span class="line">sed -i <span class="string">&#x27;/allow 361way.com/a\allow www.361way.com&#x27;</span> the.conf.file</span><br></pre></td></tr></table></figure>

<p>添加多行只需要加 <code>\n</code> 就行了：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed <span class="string">&#x27;/P0.1.1_Welcome to edX.mhtml/i## Part 0: Course Structure\n\n### Welcome to TUMx iLabX\n&#x27;</span> demo.md</span><br></pre></td></tr></table></figure>

<p>另外，如果在 <code>sed</code> 脚本中，在 <code>i</code> 之后加换行符 <code>\n</code>，需要转义，我也不知道为什么： </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/P0.2.1_Some history.mhtml/i\\n\n<span class="comment">### Introduction: The Layer model\n</span></span><br></pre></td></tr></table></figure>

<p>如果写成这样：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/P0.2.1_Some history.mhtml/i\n\n<span class="comment">### Introduction: The Layer model\n</span></span><br></pre></td></tr></table></figure>

<p>那么第一个 <code>\n</code> 会被当成 <code>n</code> 打印出来</p>
<h4 id="文本的行尾或行首添加字符"><a href="#文本的行尾或行首添加字符" class="headerlink" title="文本的行尾或行首添加字符"></a>文本的行尾或行首添加字符</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在每行的头添加字符，比如<span class="string">&quot;HEAD&quot;</span>，命令如下：</span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/^/HEAD&amp;/g&#x27;</span> test.file</span><br><span class="line"></span><br><span class="line">在每行的行尾添加字符，比如“TAIL”，命令如下：</span><br><span class="line"></span><br><span class="line">sed <span class="string">&#x27;s/$/&amp;TAIL/g&#x27;</span> test.file</span><br></pre></td></tr></table></figure>





<h3 id="sort-排序"><a href="#sort-排序" class="headerlink" title="sort - 排序"></a>sort - 排序</h3><p>我以为 sort 的用法很简单，直到我看了 man sort 。。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/51linux/archive/2012/05/23/2515299.html">参考</a></p>
<ol>
<li><p>直接排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ cat sort.de</span><br><span class="line">Name            Belt</span><br><span class="line">--------------------</span><br><span class="line">M.Tansley       Green</span><br><span class="line">J.Lulu          green</span><br><span class="line">P.Bunny         Yellow</span><br><span class="line">J.Troll         Brown-3</span><br><span class="line">L.Tansley       Brown-2</span><br><span class="line">$ sort sort.de              <span class="comment">#大致是按照每行第一个字符的ASCII顺序..才怪嘞，明明是字典顺序</span></span><br><span class="line">--------------------</span><br><span class="line">J.Lulu          green</span><br><span class="line">J.Troll         Brown-3</span><br><span class="line">L.Tansley       Brown-2</span><br><span class="line">M.Tansley       Green</span><br><span class="line">Name            Belt</span><br><span class="line">P.Bunny         Yellow</span><br><span class="line">$ sort abc                 <span class="comment">#小写字母在前，大写字母在后</span></span><br><span class="line">a</span><br><span class="line">A</span><br><span class="line">b</span><br><span class="line">B</span><br><span class="line">c</span><br><span class="line">C</span><br><span class="line">d</span><br><span class="line">D</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定分隔符，指定排序列</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="string">&#x27;s/[ 	][ 	]*/:/g&#x27;</span> sort.de <span class="comment">#中括号里面的是空格和控制符Tab</span></span><br><span class="line">$ sort -t : -k 2 sort.de            <span class="comment">#指定以冒号作为分隔符，指定以第二列来排序</span></span><br><span class="line">--------------------</span><br><span class="line">Name:Belt</span><br><span class="line">l.tansley:Brown-2</span><br><span class="line">J.Troll:Brown-3</span><br><span class="line">j.lulu:green</span><br><span class="line">M.Tansley:Green</span><br><span class="line">P.Bunny:Yellow</span><br></pre></td></tr></table></figure>
</li>
<li><p>多优先级逆序排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cat sort.de</span><br><span class="line">google 110 5000</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br><span class="line">$ sort -k2rn -k3n sort.de <span class="comment">#先对第二列按数字大小逆序排，如果第二列数字相同，就再对第三列按照数字大小正序排列</span></span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">guge 50 3000</span><br><span class="line"></span><br><span class="line"><span class="comment">#结合一下awk，嘿嘿</span></span><br><span class="line">$ sort -k2rn -k3n sort.de | awk <span class="string">&#x27;&#123;printf&quot;%6s: %3s %4s\n&quot;,$1,$2,$3&#125;&#x27;</span> <span class="comment">#不写\n的话很奇怪</span></span><br><span class="line">google: 110 5000</span><br><span class="line">  sohu: 100 4500</span><br><span class="line"> baidu: 100 5000</span><br><span class="line">  guge:  50 3000</span><br><span class="line">$ sort -k2rn -k3n sort.de | awk <span class="string">&#x27;&#123;printf&quot;%6s公司: %6s人    每人平均%-4s元/月\n&quot;,$1,$2,$3&#125;&#x27;</span></span><br><span class="line">google公司:    110人    每人平均5000元/月</span><br><span class="line">  sohu公司:    100人    每人平均4500元/月</span><br><span class="line"> baidu公司:    100人    每人平均5000元/月</span><br><span class="line">  guge公司:     50人    每人平均3000元/月</span><br></pre></td></tr></table></figure>
</li>
<li><p>对一列中某些字符开始排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sort -k1.2 sort.de <span class="comment">#对第一个域的第二个字符开始到本域的最后一个字符为止的字符串进行排序</span></span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 3000</span><br><span class="line">$ sort -k1.2,1.2 sort.de <span class="comment">#只对第一个域的第二个字符排序</span></span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">guge 50 3000</span><br></pre></td></tr></table></figure>
</li>
<li><p>-k 和 -u 一起用</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ sort -u -k2n sort.de <span class="comment">#第二列相同的被删掉后面的一行，即只有第一次出现才保留</span></span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">$ sort -u  sort.de     <span class="comment">#如果不指定只有全部相同才删除一行</span></span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果只指定一个字符的话，也一样</span></span><br><span class="line">$ sort -k1.1,1.1 -u sort.de</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line"><span class="comment">#设置了两层排序优先级的情况下，使用-u就没有删除任何行。原来-u是会权衡所有-k选项，将都相同的才会删除，只要其中有一级不同都不会轻易删除的</span></span><br><span class="line">$ sort -k2n -k3n -u sort.de</span><br><span class="line">guge 50 3000</span><br><span class="line">sohu 100 4500</span><br><span class="line">baidu 100 5000</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure>
</li>
<li><p>最诡异的排序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#虽然这样写没有报错，但是它实际上只计算2.2到2.$，相同的话，它自动比较第一个域去了</span></span><br><span class="line">$ sort -k2.2,3.1n sort.de</span><br><span class="line">guge 50 3000</span><br><span class="line">baidu 100 5000</span><br><span class="line">sohu 100 4500</span><br><span class="line">google 110 5000</span><br></pre></td></tr></table></figure>
</li>
<li><p>目前仍未理解的排序。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sort -k2.2 pai.de</span><br><span class="line">aa 2413</span><br><span class="line">bb 3322</span><br><span class="line">cc 4231</span><br><span class="line">$ sort -t<span class="string">&#x27; &#x27;</span> -k2.2 pai.de <span class="comment">#为啥这里必须要用-t声明分隔符，不是默认为空格的吗？</span></span><br><span class="line">cc 4231</span><br><span class="line">bb 3322</span><br><span class="line">aa 2413</span><br></pre></td></tr></table></figure>

<p>我发现好多命令的细节都有可能有些不一样，实际上用的时候一定要仔细检查一下</p>
</li>
<li><p>查看前几行和最后几行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sort number | head -3</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">$ sort number | tail -3</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>uniq 有点像 sort -u，但是有点不一样。sort -u 去除所有的重复行，不管它的位置在哪，只要文本一样就删掉多余的；而 uniq 只删除连续在一起的多余的部分，如果两行一样，但是不紧挨着，uniq 并不把它们删去。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ cat uniq.de</span><br><span class="line">the fux</span><br><span class="line">the fux</span><br><span class="line">ih lala</span><br><span class="line">the fux</span><br><span class="line">$ sort -u uniq.de</span><br><span class="line">ih lala</span><br><span class="line">the fux</span><br><span class="line">$ uniq uniq.de</span><br><span class="line">the fux</span><br><span class="line">ih lala</span><br><span class="line">the fux</span><br></pre></td></tr></table></figure>

<h3 id="tr-translate"><a href="#tr-translate" class="headerlink" title="tr - translate"></a>tr - translate</h3><p><a target="_blank" rel="noopener" href="https://man.linuxde.net/tr">参考</a></p>
<p>通过使用 tr，可以非常容易地实现 sed 的许多最基本功能。可以将 tr 看作为 sed 的（极其）简化的变体：它可以用一个字符来替换另一个字符，或者可以完全除去一些字符。您也可以用它来除去重复字符。这就是所有 tr 所能够做的。 </p>
<p>tr用来从标准输入中通过替换或删除操作进行字符转换。tr主要用于删除文件中控制字符或进行字符转换。使用tr时要转换两个字符串：字符串1用于查询， 字符串2用于处理各种转换。tr刚执行时，字符串1中的字符被映射到字符串2中的字符，然后转换操作开始。<br>带有最常用选项的tr命令格式为：<br><code>tr -c -d -s [&quot;string1_to_translate_from&quot;] [&quot;string2_to_translate_to&quot;] &lt; input-file</code><br>这里：<br><code>-c</code> 用字符串1中字符集的补集替换此字符集，要求字符集为ASCII。<br><code>-d</code> 删除字符串1中所有输入字符。<br><code>-s</code> 删除所有重复出现字符序列，只保留第一个；即将重复出现字符串压缩为一个字符串。<br>input-file是转换文件名。虽然可以使用其他格式输入，但这种格式最常用。</p>
<p>例子：</p>
<ol>
<li><p>去除 <code>tr.de</code> 里面的重复的小写字符</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tr -s <span class="string">&quot;[a-z]&quot;</span> &lt;tr.de &gt;tr.out1</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除空行(如果空行在第一行，则没有办法删掉)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ tr -s <span class="string">&quot;[\012]&quot;</span> &lt;tr.de &gt;tr.out21            </span><br><span class="line">$ cat tr.de ; <span class="built_in">echo</span> <span class="string">&quot;----------分隔线------------&quot;</span> ; cat tr.out21</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wooooo mf dou ui hc py  <span class="comment">#可以看到上面有三行空行</span></span><br><span class="line"></span><br><span class="line">hi everyeveryone</span><br><span class="line"></span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">----------分隔线------------</span><br><span class="line"></span><br><span class="line">wooooo mf dou ui hc py  <span class="comment">#在这里，第一行空行是无论如何也不会被删掉的</span></span><br><span class="line">hi everyeveryone</span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p><code>\012</code> 就是 <code>\n</code> ，因为 <code>-s</code> 是删除重复的元素，所有如果空行在第一行则没法删除。</p>
<p>假设每一行的结尾都有 <code>\n</code> ，空行的一整行中只有 <code>\n</code> ，所以，所有不在第一行的空行都会与它上一行结尾的 <code>\n</code> 重复，从而被删掉。而如果不是空行，它们的 <code>\n</code> 就不会相连，就不会被删掉。</p>
<p>如果用 <code>-d</code> 的话，所有的 <code>\n</code> 都被删掉，即，所有行合并成一行。</p>
</li>
<li><p>替换控制字符 <code>^M</code> 为换行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不用 -s 是因为 -s 只替换重复的呀</span></span><br><span class="line">$ tr <span class="string">&quot;[\015]&quot;</span> <span class="string">&quot;[\n]&quot;</span> &lt;tr.de &gt;tr.out3  <span class="comment">#这里&quot;[\015]&quot; &quot;[\n]&quot;中间如果没有空格就会报错</span></span><br><span class="line">$ cat -v tr.de ; <span class="built_in">echo</span> <span class="string">&quot;----------分隔线------------&quot;</span> ; cat -v tr.out3</span><br><span class="line">wooooo mf dou ui hc py</span><br><span class="line"></span><br><span class="line">hi everyeveryone^M        <span class="comment">#这里的 ^M</span></span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br><span class="line">----------分隔线------------</span><br><span class="line">wooooo mf dou ui hc py</span><br><span class="line"></span><br><span class="line">hi everyeveryone</span><br><span class="line">                          <span class="comment">#被替换成 \n 了</span></span><br><span class="line">line5</span><br><span class="line">line6</span><br><span class="line">line7</span><br></pre></td></tr></table></figure>



</li>
</ol>
<h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c或——complerment：取代所有不属于第一字符集的字符；</span><br><span class="line">-d或——delete：删除所有属于第一字符集的字符；</span><br><span class="line">-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。</span><br></pre></td></tr></table></figure>

<p><strong>tr可以使用的字符类：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[:alnum:]：字母和数字</span><br><span class="line">[:alpha:]：字母</span><br><span class="line">[:cntrl:]：控制（非打印）字符</span><br><span class="line">[:digit:]：数字</span><br><span class="line">[:graph:]：图形字符</span><br><span class="line">[:lower:]：小写字母</span><br><span class="line">[:<span class="built_in">print</span>:]：可打印字符</span><br><span class="line">[:punct:]：标点符号</span><br><span class="line">[:space:]：空白字符</span><br><span class="line">[:upper:]：大写字母</span><br><span class="line">[:xdigit:]：十六进制字符</span><br><span class="line"></span><br><span class="line">[a-z] a-z内的字符组成的字符串。</span><br><span class="line">[A-Z] A-Z内的字符组成的字符串。</span><br><span class="line">[0-9] 数字串。</span><br><span class="line">\octal 一个三位的八进制数，对应有效的ASCII字符。</span><br><span class="line">[O*n] 表示字符O重复出现指定次数n。因此[O*2]匹配OO的字符串。  <span class="comment">#匹配多于一个字符</span></span><br><span class="line"><span class="comment">#tr中特定控制字符的不同表达方式</span></span><br><span class="line"><span class="comment">#速记符含义八进制方式</span></span><br><span class="line">\a Ctrl-G  铃声\007</span><br><span class="line">\b Ctrl-H  退格符\010</span><br><span class="line">\f Ctrl-L  走行换页\014</span><br><span class="line">\n Ctrl-J  新行\012</span><br><span class="line">\r Ctrl-M  回车\015</span><br><span class="line">\t Ctrl-I  tab键\011</span><br><span class="line">\v Ctrl-X  \030</span><br></pre></td></tr></table></figure>

<p>下面的例子更简洁一点：</p>
<p>将输入字符由大写转换为小写：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;HELLO WORLD&quot;</span> | tr <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>‘A-Z’ 和 ‘a-z’都是集合，集合是可以自己制定的，例如：’ABD-}’、’bB.,’、’a-de-h’、’a-c0-9’都属于集合，集合里可以使用’\n’、’\t’，可以可以使用其他ASCII字符。</p>
<p>使用tr删除字符：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;hello 123 world 456&quot;</span> | tr -d <span class="string">&#x27;0-9&#x27;</span></span><br><span class="line">hello  world </span><br></pre></td></tr></table></figure>

<p>将制表符转换为空格：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat text | tr <span class="string">&#x27;\t&#x27;</span> <span class="string">&#x27; &#x27;</span></span><br></pre></td></tr></table></figure>

<p>字符集补集，从输入文本中将不在补集中的所有字符删除：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;aa.,a 1 b # $bb 2 c*/cc 3 ddd 4&#x27;</span> | tr -d -c <span class="string">&#x27;0-9 \n&#x27;</span></span><br><span class="line"> 1  2  3  4</span><br></pre></td></tr></table></figure>

<p>此例中，补集中包含了数字0~9、空格和换行符\n，所以没有被删除，其他字符全部被删除了。</p>
<p>用tr压缩字符，可以压缩输入中重复的字符：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;thissss is      a text linnnnnnne.&quot;</span> | tr -s <span class="string">&#x27; sn&#x27;</span></span><br><span class="line">this is a text line.</span><br></pre></td></tr></table></figure>

<p>巧妙使用tr做数字相加操作：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 2 3 4 5 6 7 8 9 | xargs -n1 | <span class="built_in">echo</span> $[ $(tr <span class="string">&#x27;\n&#x27;</span> <span class="string">&#x27;+&#x27;</span>) 0 ]</span><br></pre></td></tr></table></figure>

<p>删除Windows文件“造成”的’^M’字符：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat file | tr -s <span class="string">&quot;\r&quot;</span> <span class="string">&quot;\n&quot;</span> &gt; new_file   <span class="comment">#这个不明白欸</span></span><br><span class="line"><span class="comment">#或</span></span><br><span class="line">cat file | tr -d <span class="string">&quot;\r&quot;</span> &gt; new_file</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span> | tr <span class="string">&quot;:&quot;</span> <span class="string">&quot;\n&quot;</span></span><br><span class="line">/usr/share/safe-rm/bin</span><br><span class="line">/usr/<span class="built_in">local</span>/sbin</span><br><span class="line">/usr/<span class="built_in">local</span>/bin</span><br><span class="line">/usr/sbin</span><br><span class="line">/usr/bin</span><br><span class="line">/sbin</span><br><span class="line">/bin</span><br><span class="line">/usr/games</span><br><span class="line">/usr/<span class="built_in">local</span>/games</span><br><span class="line">/home/purian/.antigen/bundles/sorin-ionescu/prezto</span><br><span class="line">/home/purian/.antigen/bundles/Vifon/deer</span><br><span class="line">/home/purian/.antigen/bundles/zdharma/fast-syntax-highlighting</span><br><span class="line">/home/purian/.antigen/bundles/willghatch/zsh-cdr</span><br></pre></td></tr></table></figure>



<h3 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span></span><br><span class="line">sudo tar -zcvf purian.tgz purian/</span><br></pre></td></tr></table></figure>











<h2 id="文本编辑"><a href="#文本编辑" class="headerlink" title="文本编辑"></a>文本编辑</h2><h3 id="vim-替换"><a href="#vim-替换" class="headerlink" title="vim 替换"></a>vim 替换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/Line/line/g</span><br></pre></td></tr></table></figure>

<p>我们把这个命令分解为几个单独的部分，看一下每部分的含义：</p>
<table>
<thead>
<tr>
<th><strong>条目</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>:</td>
<td>冒号字符运行一个 ex 命令。</td>
</tr>
<tr>
<td>%</td>
<td>指定要操作的行数。% 是一个快捷方式，表示从第一行到最后一行。另外，操作范围也 可以用 1,5 来代替（因为我们的文件只有5行文本），或者用 1,$ 来代替，意思是 “ 从第一行到文件的最后一行。” 如果省略了文本行的范围，那么操作只对当前行生效。</td>
</tr>
<tr>
<td>s</td>
<td>指定操作。在这种情况下是，替换（查找与替代）。</td>
</tr>
<tr>
<td>/Line/line</td>
<td>查找类型与替代文本。</td>
</tr>
<tr>
<td>g</td>
<td>这是“全局”的意思，意味着对文本行中所有匹配的字符串执行查找和替换操作。如果省略 g，则 只替换每个文本行中第一个匹配的字符串。</td>
</tr>
</tbody></table>
<p>查找是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Line</span><br></pre></td></tr></table></figure>

<p>没有 <code>:</code> ，按 <code>n</code> 查找下一个。</p>
<p>把两行</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">crt.Screen.Send <span class="built_in">chr</span>(<span class="number">13</span>)</span><br><span class="line">crt.Screen.Send <span class="built_in">chr</span>(<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>替换成一行</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crt.Screen.Send <span class="built_in">chr</span>(<span class="number">13</span>) &amp; <span class="built_in">chr</span>(<span class="number">13</span>)</span><br></pre></td></tr></table></figure>

<p>在 vim 里这样执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/crt.Screen.Send chr(13)\ncrt.Screen.Send chr(13)/crt.Screen.Send chr(13) \&amp; chr(13)/g</span><br></pre></td></tr></table></figure>

<p>注意，文件格式要是 unix，还有转义符号也要考虑</p>
<h3 id="vim-配置"><a href="#vim-配置" class="headerlink" title="vim 配置"></a>vim 配置</h3><p>/etc/vim/vimrc</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot; vimrc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set pastetoggle=&lt;F9&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> tab宽度为4</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 显示行号</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 在编辑过程中右下角显示光标的行列信息</span><br><span class="line"><span class="built_in">set</span> ruler</span><br><span class="line"></span><br><span class="line"><span class="string">&quot; 在状态栏显示正在输入的命令</span></span><br><span class="line"><span class="string">set showcmd</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span> 打开语法高亮</span><br><span class="line">:syntax on</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;同步滚动(在第二个窗口输命令才可以)</span></span><br><span class="line"><span class="string">:set scrollbind</span></span><br><span class="line"><span class="string">:set noscrollbind</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set ignorecase</span></span><br><span class="line"><span class="string">&quot;</span>继承上面的缩进</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> hlsearch     <span class="string">&quot;查找匹配高亮</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936</span></span><br><span class="line"><span class="string">set termencoding=utf-8</span></span><br><span class="line"><span class="string">set encoding=utf-8</span></span><br></pre></td></tr></table></figure>



<p>上面的设置还是不能用右键粘贴，解决方法：</p>
<p>编辑 vim 的默认配置文件 <code>vim /usr/share/vim/vim80/defaults.vim</code></p>
<p>把 <code>set mouse=a</code> 改为：<code>set mouse-=a</code>。</p>
<p>还不行就在 <code>.vimrc</code> 里加</p>
<p>如果自动缩进老是缩进8个空格，就关掉 <code>filetype indent on</code> ，或者设定自动缩进为4个字符 <code>set shiftwidth=4</code> 。</p>
<p>还有两个可能会用到</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> expandtab 用space替代tab的输入</span><br><span class="line">:<span class="built_in">set</span> noexpandtab 不用space替代tab的输入</span><br></pre></td></tr></table></figure>

<p>粘贴时的缩进：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">set</span> paste</span><br></pre></td></tr></table></figure>

<p>我的 <code>~/.vimrc</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ! has(<span class="string">&quot;gui_running&quot;</span>)</span><br><span class="line">    <span class="built_in">set</span> t_Co=256</span><br><span class="line">endif</span><br><span class="line"><span class="string">&quot; feel free to choose :set background=light for a different style</span></span><br><span class="line"><span class="string">set background=dark</span></span><br><span class="line"><span class="string">colors peaksea</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set pastetoggle=&lt;F9&gt;</span></span><br><span class="line"><span class="string">set mouse-=a</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">set tabstop=4</span></span><br><span class="line"><span class="string">set number</span></span><br><span class="line"><span class="string">syntax on</span></span><br><span class="line"><span class="string">set ruler</span></span><br><span class="line"><span class="string">set showcmd</span></span><br><span class="line"><span class="string">set shiftwidth=4</span></span><br><span class="line"><span class="string">set expandtab    &quot;</span>用space替代tab的输入</span><br><span class="line"><span class="built_in">set</span> incsearch    <span class="string">&quot;在查找过程中逐字匹配高亮</span></span><br><span class="line"><span class="string">set hlsearch     &quot;</span>查找匹配高亮 ，用 :noh 取消</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;</span>status line settings</span><br><span class="line"><span class="string">&quot;set laststatus=2</span></span><br><span class="line"><span class="string">&quot;</span>highlight StatusLine cterm=bold ctermfg=255 ctermbg=242    <span class="string">&quot;white</span></span><br><span class="line"><span class="string">&quot;</span><span class="string">&quot;highlight StatusLine cterm=bold ctermfg=87 ctermbg=242    &quot;</span>blue</span><br><span class="line"><span class="string">&quot;set statusline=[%n]\ %f%m%r%h\ \ %=\|\ %l,%c\ %p%%\ \|\ ASCII=%b,HEX=%B\ \|\ %&#123;((&amp;fenc==\&quot;\&quot;)?\&quot;\&quot;:\&quot;\&quot;.&amp;fenc)&#125;,%&#123;&amp;ff&#125;\</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;</span>status line settings</span><br><span class="line"><span class="built_in">set</span> laststatus=2</span><br><span class="line"><span class="string">&quot;highlight StatusLine cterm=bold ctermfg=49 ctermbg=240</span></span><br><span class="line"><span class="string">highlight StatusLine cterm=bold ctermfg=251 ctermbg=240</span></span><br><span class="line"><span class="string">set statusline=%1*[%*%n</span></span><br><span class="line"><span class="string">set statusline+=%2*]%*</span></span><br><span class="line"><span class="string">set statusline+=%3*\ %f%m%r%h\ \ %=%*</span></span><br><span class="line"><span class="string">set statusline+=\|%4*\ %l,%c\ %p%%\ %*</span></span><br><span class="line"><span class="string">set statusline+=\|%5*\ ASCII=%b,HEX=%B%*</span></span><br><span class="line"><span class="string">set statusline+=\ \|\ %6*%&#123;((&amp;fenc==\&quot;\&quot;)?\&quot;\&quot;:\&quot;\&quot;.&amp;fenc)&#125;,%&#123;&amp;ff&#125;\ %*</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">hi User1 cterm=bold ctermfg=251 ctermbg=240</span></span><br><span class="line"><span class="string">hi User2 cterm=bold ctermfg=251 ctermbg=240</span></span><br><span class="line"><span class="string">hi User3 cterm=bold ctermfg=39 ctermbg=240   &quot;</span>ctermfg=169 39</span><br><span class="line">hi User4 cterm=None ctermfg=251 ctermbg=240</span><br><span class="line">hi User5 cterm=None ctermfg=251 ctermbg=240</span><br><span class="line">hi User6 cterm=None ctermfg=251 ctermbg=240</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&quot; Uncomment the following to have Vim jump to the last position when</span></span><br><span class="line"><span class="string">&quot;</span> reopening a file</span><br><span class="line"><span class="keyword">if</span> has(<span class="string">&quot;autocmd&quot;</span>)</span><br><span class="line">  au BufReadPost * <span class="keyword">if</span> line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &gt; 1 &amp;&amp; line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &lt;= line(<span class="string">&quot;$&quot;</span>) | exe <span class="string">&quot;normal! g&#x27;\&quot;&quot;</span> | endif</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>



<h3 id="vim-注释"><a href="#vim-注释" class="headerlink" title="vim 注释"></a>vim 注释</h3><p>方法一 ：块选择模式</p>
<p>批量注释：</p>
<p><strong>Ctrl + v</strong> 进入块选择模式，然后移动光标选中你要注释的行，再按大写的 <strong>I</strong> 进入行首插入模式输入注释符号如 <strong>//</strong> 或 <strong>#**，输入完毕之后，按两下 **ESC</strong>，<strong>Vim</strong> 会自动将你选中的所有行首都加上注释，保存退出完成注释。</p>
<p>取消注释：</p>
<p><strong>Ctrl + v</strong> 进入块选择模式，选中你要删除的行首的注释符号，注意 <strong>//</strong> 要选中两个，选好之后按 <strong>d</strong> 即可删除注释，<strong>ESC</strong> 保存退出。</p>
<p>方法二: 替换命令</p>
<p>批量注释。</p>
<p>使用下面命令在指定的行首添加注释。</p>
<p>使用名命令格式： <strong>:起始行号,结束行号s/^/注释符/g</strong>（注意冒号）。</p>
<p>取消注释：</p>
<p>使用名命令格式： <strong>:起始行号,结束行号s/^注释符//g</strong>（注意冒号）。</p>
<p>例子：</p>
<p>1、在 10 - 20 行添加 <strong>//</strong> 注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:10,20s#^#&#x2F;&#x2F;#g</span><br></pre></td></tr></table></figure>

<p>2、在 10 - 20 行删除 <strong>//</strong> 注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:10,20s#^&#x2F;&#x2F;##g</span><br></pre></td></tr></table></figure>

<p>3、在 10 - 20 行添加 <strong>#</strong> 注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:10,20s&#x2F;^&#x2F;#&#x2F;g</span><br></pre></td></tr></table></figure>

<p>4、在 <strong>10 - 20</strong> 行删除 # 注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:10,20s&#x2F;#&#x2F;&#x2F;g</span><br></pre></td></tr></table></figure>

<h3 id="vim-文本折叠"><a href="#vim-文本折叠" class="headerlink" title="vim 文本折叠"></a>vim 文本折叠</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_36053757/article/details/78183681">参考</a></p>
<blockquote>
<p>:set fdm=indent</p>
<p>zc  折叠</p>
<p>zo  打开</p>
</blockquote>
<h3 id="打开多窗口、多文件"><a href="#打开多窗口、多文件" class="headerlink" title="打开多窗口、多文件"></a>打开多窗口、多文件</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014015972/article/details/50708360">参考</a></p>
<p><strong>纵向</strong>分割显示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -O filename1 filename2</span><br></pre></td></tr></table></figure>

<p>横向分割显示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ vim -o filename1 filename2  </span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">打开多个文件：</span><br><span class="line">一、vim还没有启动的时候：</span><br><span class="line"><span class="number">1.</span>在终端里输入 </span><br><span class="line">vim file1 file2 ... filen便可以打开所有想要打开的文件</span><br><span class="line"><span class="number">2.</span>vim已经启动</span><br><span class="line">输入</span><br><span class="line">:e file</span><br><span class="line">可以再打开一个文件，并且此时vim里会显示出file文件的内容。</span><br><span class="line"><span class="number">3.</span>同时显示多个文件：</span><br><span class="line">:sp         <span class="comment">//水平切分窗口</span></span><br><span class="line">:vs :vsplit  CTRL-w v     <span class="comment">//垂直切分窗口</span></span><br><span class="line">:<span class="keyword">new</span>                          <span class="comment">//水平分割窗口，创建空文件</span></span><br><span class="line">:vnew                         <span class="comment">//垂直分割窗口，创建空文件</span></span><br><span class="line"></span><br><span class="line">二、在文件之间切换：</span><br><span class="line"><span class="number">1.</span>文件间切换</span><br><span class="line">Ctrl+<span class="number">6</span>  <span class="comment">//两文件间的切换</span></span><br><span class="line">:bn      <span class="comment">//下一个文件</span></span><br><span class="line">:bp      <span class="comment">//上一个文件</span></span><br><span class="line">:ls       <span class="comment">//列出打开的文件，带编号</span></span><br><span class="line">:b1~n  <span class="comment">//切换至第n个文件</span></span><br><span class="line">对于用(v)split在多个窗格中打开的文件，这种方法只会在当前窗格中切换不同的文件。</span><br><span class="line"><span class="number">2.</span>在窗格间切换的方法</span><br><span class="line">Ctrl+w+方向键——切换到前／下／上／后一个窗格</span><br><span class="line">Ctrl+w+h/j/k/l ——同上</span><br><span class="line">Ctrl+ww——依次向后切换到下一个窗格中</span><br><span class="line">CTRL-w o 关闭其他所有窗口</span><br><span class="line">三、同步滚动(好像两个窗口都要输一遍)</span><br><span class="line"><span class="built_in">set</span> scrollbind</span><br><span class="line"><span class="built_in">set</span> noscrollbind</span><br></pre></td></tr></table></figure>

<h4 id="Taglist-左"><a href="#Taglist-左" class="headerlink" title="Taglist(左)"></a>Taglist(左)</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">:Tlist 打开/关闭侧栏</span><br><span class="line">Ctrl+m   打开Taglist</span><br><span class="line">Ctrl+ww  左右切换</span><br><span class="line"></span><br><span class="line">在taglist窗口中，可以使用下面的快捷键：</span><br><span class="line">&lt;CR&gt;          跳到光标下tag所定义的位置，用鼠标双击此tag功能也一样</span><br><span class="line">o             在一个新打开的窗口中显示光标下tag</span><br><span class="line">&lt;Space&gt;       显示光标下tag的原型定义</span><br><span class="line">u             更新taglist窗口中的tag</span><br><span class="line">s             更改排序方式，在按名字排序和按出现顺序排序间切换</span><br><span class="line">x             taglist窗口放大和缩小，方便查看较长的tag</span><br><span class="line">+             打开一个折叠，同zo</span><br><span class="line">-             将tag折叠起来，同zc</span><br><span class="line">*             打开所有的折叠，同zR</span><br><span class="line">=             将所有tag折叠起来，同zM</span><br><span class="line">[[            跳到前一个文件</span><br><span class="line">]]            跳到后一个文件</span><br><span class="line">q             <span class="comment">//关闭taglist窗口</span></span><br><span class="line">&lt;F1&gt;          显示帮助</span><br></pre></td></tr></table></figure>

<h4 id="nerdtree-右"><a href="#nerdtree-右" class="headerlink" title="nerdtree(右)"></a>nerdtree(右)</h4><blockquote>
<p>TlistToggle <F10></F10></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">ctrl + n        <span class="comment">//打开</span></span><br><span class="line">    </span><br><span class="line">ctrl + w + h    光标 focus 左侧树形目录</span><br><span class="line">ctrl + w + l    光标 focus 右侧文件显示窗口</span><br><span class="line">ctrl + w + w    光标自动在左右侧窗口切换</span><br><span class="line">ctrl + w + r    移动当前窗口的布局位置</span><br><span class="line">o       在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go      在已有窗口 中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t       在新 Tab 中打开选中文件/书签，并跳到新 Tab</span><br><span class="line">T       在新 Tab 中打开选中文件/书签，但不跳到新 Tab</span><br><span class="line">i       split 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi      split 一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s       vsplit 一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs      vsplit 一个新 窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!       执行当前文件</span><br><span class="line">O       递归打开选中 结点下的所有目录</span><br><span class="line">x       合拢选中结点的父目录</span><br><span class="line">X       递归 合拢选中结点下的所有目录</span><br><span class="line">e       Edit the current dif</span><br><span class="line">双击    相当于 NERDTree-o</span><br><span class="line">中键    对文件相当于 NERDTree-i，对目录相当于 NERDTree-e</span><br><span class="line">D       删除当前书签</span><br><span class="line">P       跳到根结点</span><br><span class="line">p       跳到父结点</span><br><span class="line">K       跳到当前目录下同级的第一个结点</span><br><span class="line">J       跳到当前目录下同级的最后一个结点</span><br><span class="line">k       跳到当前目录下同级的前一个结点</span><br><span class="line">j       跳到当前目录下同级的后一个结点</span><br><span class="line">C       将选中目录或选中文件的父目录设为根结点</span><br><span class="line">u       将当前根结点的父目录设为根目录，并变成合拢原根结点</span><br><span class="line">U       将当前根结点的父目录设为根目录，但保持展开原根结点</span><br><span class="line">r       递归刷新选中目录</span><br><span class="line">R       递归刷新根结点</span><br><span class="line">m       显示文件系统菜单</span><br><span class="line">cd      将 CWD 设为选中目录</span><br><span class="line">I       切换是否显示隐藏文件</span><br><span class="line">f       切换是否使用文件过滤器</span><br><span class="line">F       切换是否显示文件</span><br><span class="line">B       切换是否显示书签</span><br><span class="line">q       <span class="comment">//关闭 NerdTree 窗口</span></span><br><span class="line">?       切换是否显示 Quick Help</span><br><span class="line"></span><br><span class="line">切换标签页</span><br><span class="line">:tabnew [++opt选项] ［＋cmd］ 文件      建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的 tab</span><br><span class="line">:tabo   关闭所有其他的 tab</span><br><span class="line">:tabs   查看所有打开的 tab</span><br><span class="line">:tabp   前一个 tab</span><br><span class="line">:tabn   后一个 tab</span><br></pre></td></tr></table></figure>



<h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a><em><code>cscope</code></em></h3><p>首先需要生成一个 cscope 数据库。在项目根目录运行下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cscope -Rbq</span><br></pre></td></tr></table></figure>

<p>打开项目中的一个文件，在 vim 中输入:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:cs add /path/cscope.out /path</span><br></pre></td></tr></table></figure>

<p>或者写到 <code>.vimrc</code> 中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cs add /path/cscope.out /path</span><br></pre></td></tr></table></figure>

<p>但是这样每次打开 vim，都会提示加载这个数据库，但是如果不写在 .vimrc 中，每次打开项目中的源文件都要手动加载，自己决定吧。</p>
<p>多加两行就没这个问题了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> nocsverb</span><br><span class="line">cs add /path/cscope.out /path</span><br><span class="line"><span class="built_in">set</span> csverb</span><br></pre></td></tr></table></figure>



<p>下表中列出了 cscope 的常用选项：</p>
<ul>
<li><strong>-R</strong>: 在生成索引文件时，搜索子目录树中的代码</li>
<li><strong>-b</strong>: 只生成索引文件，不进入 cscope 的界面</li>
<li><strong>-q</strong>: 生成 cscope.in.out 和 cscope.po.out 文件，加快 cscope 的索引速度</li>
<li><strong>-k</strong>: 在生成索引文件时，不搜索 /usr/include 目录</li>
<li><strong>-i</strong>: 如果保存文件列表的文件名不是 cscope.files 时，需要加此选项告诉 cscope 到哪儿去找源文件列表。可以使用 “<strong>-</strong>“ ，表示由标准输入获得文件列表。</li>
<li><strong>-I</strong> <em>dir</em>: 在 <strong>-I</strong> 选项指出的目录中查找头文件</li>
<li><strong>-u</strong>: 扫描所有文件，重新生成交叉索引文件</li>
<li><strong>-C</strong>: 在搜索时忽略大小写</li>
<li><strong>-P</strong> <em>path</em>: 在以相对路径表示的文件前加上的 path，这样，你不用切换到你数据库文件所在的目录也可以使用它了。</li>
</ul>
<p>在 vim 中，使用 <code>:cs find</code> 命令查找：</p>
<ul>
<li><strong>s:</strong> 查找C语言符号，即查找函数名、宏、枚举值等出现的地方</li>
<li><strong>g:</strong> 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能</li>
<li><strong>d:</strong> 查找本函数调用的函数</li>
<li><strong>c:</strong> 查找调用本函数的函数</li>
<li><strong>t:</strong> 查找指定的字符串</li>
<li><strong>e:</strong> 查找egrep模式，相当于egrep功能，但查找速度快多了</li>
<li><strong>f:</strong> 查找并打开文件，类似vim的find功能</li>
<li><strong>i:</strong> 查找包含本文件的文件</li>
</ul>
<p>帮助：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:cs <span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#前面是数据库文件，后面是相对根目录，因为前面数据库里面是相对路径名，所以要指定相对根目录，如果数据库和正在编辑的文件不在同一目录的话。</span></span><br><span class="line">:cscope add /projects/cscope.out /projects  <span class="comment">#在vim里手动输，或者写到.vimrc里(没有:)</span></span><br></pre></td></tr></table></figure>



<h3 id="可视化模式"><a href="#可视化模式" class="headerlink" title="可视化模式"></a>可视化模式</h3><p>使用 Vim 编辑文本时，可视化模式对于识别要操作的文本块非常有用。</p>
<p>Vim 的可视模式有三个模式：字符、行和块。进入每种模式的按键是：</p>
<ul>
<li>字符模式: <code>v</code> （小写）</li>
<li>行模式: <code>V</code> （大写）(就是 <code>Shift+v</code> 啦)</li>
<li>块模式: <code>Ctrl+v</code></li>
</ul>
<h4 id="字符模式"><a href="#字符模式" class="headerlink" title="字符模式"></a>字符模式</h4><p><code>Ctrl+o</code> 光标回到刚才的位置</p>
<p>更改文本：</p>
<ul>
<li>按 <code>v</code> 进入可视化模式，高亮文本</li>
<li>按 <code>c</code> ，文本会消失并进入插入模式</li>
</ul>
<h4 id="行模式"><a href="#行模式" class="headerlink" title="行模式"></a>行模式</h4><p>缩进：</p>
<ul>
<li>按 <code>Shift+v</code> 进入行模式，高亮文本</li>
<li>按 <code>Shift+&gt;</code> 缩进选中的行</li>
<li>或者按 <code>Shift+&lt;</code> 减少缩进</li>
</ul>
<h4 id="块模式"><a href="#块模式" class="headerlink" title="块模式"></a>块模式</h4><p>按 <code>Ctrl</code> 进入块模式</p>
<p>[注释](#vim 注释)</p>
<h3 id="当前挂起和恢复"><a href="#当前挂起和恢复" class="headerlink" title="当前挂起和恢复"></a>当前挂起和恢复</h3><ul>
<li><p><code>ctrl-z</code>  挂起</p>
</li>
<li><p><code>fg</code>          恢复</p>
</li>
</ul>
<h3 id="vimdiff"><a href="#vimdiff" class="headerlink" title="vimdiff"></a>vimdiff</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ vimdiff file1 file2      <span class="comment">#垂直</span></span><br><span class="line">$ vimdiff -o file1 file2   <span class="comment">#水平</span></span><br><span class="line"><span class="comment">#或者：</span></span><br><span class="line">$ vim -d  file1 file2</span><br></pre></td></tr></table></figure>

<h4 id="对比差异"><a href="#对比差异" class="headerlink" title="对比差异"></a>对比差异</h4><ul>
<li><p>只在某一文件中存在的行的背景色被设置为蓝色，而在另一文件中的对应位置被显示为绿色。</p>
</li>
<li><p>两个文件中都存在，但是包含差异的行显示为粉色背景，引起差异的文字用红色背景加以突出。</p>
</li>
<li><p><code>+-- 7 lines: #include &lt;stdio.h&gt;-------------------</code> 表示折叠的行 可以用<code>zo</code>（open）可以把折叠的行打开,使用<code>zc</code>(close)可以把折叠的行关闭</p>
</li>
<li><p><code>-------------------------------------------</code> 表示删除的行</p>
</li>
<li><p>上下文的展开和查看：比较和合并文件的时候经常需要结合上下文来确定最终要采取的操作。Vimdiff 缺省是会把不同之处上下各 6 行的文本都显示出来以供参考。其他的相同的文本行被自动折叠。如果希望修改缺省的上下文行数，可以这样设置(设置上下文为3行)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set diffopt&#x3D;context:3</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="光标"><a href="#光标" class="headerlink" title="光标"></a>光标</h4><p>可以使用快捷键在各个差异点之间快速移动。</p>
<ul>
<li><code>]c</code> 跳转到下一个差异点</li>
<li><code>[c</code> 跳转到上一个差异点</li>
<li><code>2]c</code>如果在命令前加上数字的话，可以跳过一个或数个差异点，从而实现跳的更远。比如如果在位于第一个差异点的行输入<code>2]c</code>，将越过下一个差异点，跳转到第三个差异点。</li>
</ul>
<h4 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h4><ul>
<li><p><code>dp</code> （diff “put”）</p>
<p>把一个差异点中当前文件的内容复制到另一个文件里</p>
</li>
<li><p><code>do</code> (diff “get”，之所以不用dg，是因为dg已经被另一个命令占用了)</p>
<p>把另一个文件的内容复制到当前行中</p>
</li>
<li><p><code>:diffupdate</code> </p>
<p>在修改一个或两个文件之后，vimdiff会试图自动来重新比较文件，来实时反映比较结果。但是也会有处理失败的情况，这个时候需要<strong>手动刷新</strong>比较结果</p>
</li>
<li><p><code>&lt;ESC&gt;, u</code> 如果希望撤销修改，可以和平常用vim编辑一样，直接但是要注意一定要将<strong>光标移动到需要撤销修改的文件窗口</strong>中。</p>
</li>
</ul>
<p>备注： 如果有多个窗口的话只要在<code>dp</code>、<code>do</code>命令前加数字代表把当前行复制到哪个窗口中或者把哪个窗口中的复制到当前窗口</p>
<h2 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h2><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make 2&gt;&amp;1 | tee log.txt</span><br></pre></td></tr></table></figure>



<h3 id="查看版本号"><a href="#查看版本号" class="headerlink" title="查看版本号"></a>查看版本号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ lsb_release -a                                                                         </span><br><span class="line">No LSB modules are available.</span><br><span class="line">Distributor ID: Debian</span><br><span class="line">Description:    Debian GNU/Linux bullseye/sid</span><br><span class="line">Release:        testing</span><br><span class="line">Codename:       bullseye</span><br><span class="line">$ uname -a                                                                               </span><br><span class="line">Linux 11638-NB1 4.4.0-17134-Microsoft <span class="comment">#706-Microsoft Mon Apr 01 18:13:00 PST 2019 x86_64 GNU/Linux</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>它的选项也太多了。。</p>
<p>而且加不加短横线含义居然不一样，也就是说 <code>ps -ef</code>、<code>ps -e f</code>、<code>ps e -f</code>、<code>ps ef</code> 和 <code>ps -ef f</code> 是不一样的</p>
<p>经常使用 <code>ps aux</code> 或 <code>ps -ef</code> 来收集有关正在运行的进程的信息。</p>
<p><a target="_blank" rel="noopener" href="https://www.linuxidc.com/Linux/2019-08/159959.htm">查看更多</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">-a：显示所有终端机下执行的程序，除了阶段作业领导者之外。</span><br><span class="line">a：显示现行终端机下的所有程序，包括其他用户的程序。</span><br><span class="line">-A：显示所有程序。</span><br><span class="line">-c：显示CLS和PRI栏位。</span><br><span class="line">c：列出程序时，显示每个程序真正的指令名称，而不包含路径，选项或常驻服务的标示。</span><br><span class="line">-C&lt;指令名称&gt;：指定执行指令的名称，并列出该指令的程序的状况。</span><br><span class="line">-d：显示所有程序，但不包括阶段作业领导者的程序。</span><br><span class="line">-e：此选项的效果和指定<span class="string">&quot;A&quot;</span>选项相同。</span><br><span class="line">e：列出程序时，显示每个程序所使用的环境变量。</span><br><span class="line">-f：显示UID,PPIP,C与STIME栏位。</span><br><span class="line">f：用ASCII字符显示树状结构，表达程序间的相互关系。</span><br><span class="line">-g&lt;群组名称&gt;：此选项的效果和指定<span class="string">&quot;-G&quot;</span>选项相同，当亦能使用阶段作业领导者的名称来指定。</span><br><span class="line">g：显示现行终端机下的所有程序，包括群组领导者的程序。</span><br><span class="line">-G&lt;群组识别码&gt;：列出属于该群组的程序的状况，也可使用群组名称来指定。</span><br><span class="line">h：不显示标题列。</span><br><span class="line">-H：显示树状结构，表示程序间的相互关系。</span><br><span class="line">-j或j：采用工作控制的格式显示程序状况。</span><br><span class="line">-l或l：采用详细的格式来显示程序状况。</span><br><span class="line">L：列出栏位的相关信息。</span><br><span class="line">-m或m：显示所有的执行绪。</span><br><span class="line">n：以数字来表示USER和WCHAN栏位。</span><br><span class="line">-N：显示所有的程序，除了执行ps指令终端机下的程序之外。</span><br><span class="line">-p&lt;程序识别码&gt;：指定程序识别码，并列出该程序的状况。</span><br><span class="line">p&lt;程序识别码&gt;：此选项的效果和指定<span class="string">&quot;-p&quot;</span>选项相同，只在列表格式方面稍有差异。</span><br><span class="line">r：只列出现行终端机正在执行中的程序。</span><br><span class="line">-s&lt;阶段作业&gt;：指定阶段作业的程序识别码，并列出隶属该阶段作业的程序的状况。</span><br><span class="line">s：采用程序信号的格式显示程序状况。</span><br><span class="line">S：列出程序时，包括已中断的子程序资料。</span><br><span class="line">-t&lt;终端机编号&gt;：指定终端机编号，并列出属于该终端机的程序的状况。</span><br><span class="line">t&lt;终端机编号&gt;：此选项的效果和指定<span class="string">&quot;-t&quot;</span>选项相同，只在列表格式方面稍有差异。</span><br><span class="line">-T：显示现行终端机下的所有程序。</span><br><span class="line">-u&lt;用户识别码&gt;：此选项的效果和指定<span class="string">&quot;-U&quot;</span>选项相同。</span><br><span class="line">u：以用户为主的格式来显示程序状况。</span><br><span class="line">-U&lt;用户识别码&gt;：列出属于该用户的程序的状况，也可使用用户名称来指定。</span><br><span class="line">U&lt;用户名称&gt;：列出属于该用户的程序的状况。</span><br><span class="line">v：采用虚拟内存的格式显示程序状况。</span><br><span class="line">-V或V：显示版本信息。</span><br><span class="line">-w或w：采用宽阔的格式来显示程序状况。　</span><br><span class="line">x：显示所有程序，不以终端机来区分。</span><br><span class="line">X：采用旧式的Linux i386登陆格式显示程序状况。</span><br><span class="line">-y：配合选项<span class="string">&quot;-l&quot;</span>使用时，不显示F(flag)栏位，并以RSS栏位取代ADDR栏位　。</span><br><span class="line">-&lt;程序识别码&gt;：此选项的效果和指定<span class="string">&quot;p&quot;</span>选项相同。</span><br><span class="line">--cols&lt;每列字符数&gt;：设置每列的最大字符数。</span><br><span class="line">--columns&lt;每列字符数&gt;：此选项的效果和指定<span class="string">&quot;--cols&quot;</span>选项相同。</span><br><span class="line">--cumulative：此选项的效果和指定<span class="string">&quot;S&quot;</span>选项相同。</span><br><span class="line">--deselect：此选项的效果和指定<span class="string">&quot;-N&quot;</span>选项相同。</span><br><span class="line">--forest：此选项的效果和指定<span class="string">&quot;f&quot;</span>选项相同。</span><br><span class="line">--headers：重复显示标题列。</span><br><span class="line">--<span class="built_in">help</span>：在线帮助。</span><br><span class="line">--info：显示排错信息。</span><br><span class="line">--lines&lt;显示列数&gt;：设置显示画面的列数。</span><br><span class="line">--no-headers：此选项的效果和指定<span class="string">&quot;h&quot;</span>选项相同，只在列表格式方面稍有差异。</span><br><span class="line">--group&lt;群组名称&gt;：此选项的效果和指定<span class="string">&quot;-G&quot;</span>选项相同。</span><br><span class="line">--Group&lt;群组识别码&gt;：此选项的效果和指定<span class="string">&quot;-G&quot;</span>选项相同。</span><br><span class="line">--pid&lt;程序识别码&gt;：此选项的效果和指定<span class="string">&quot;-p&quot;</span>选项相同。</span><br><span class="line">--rows&lt;显示列数&gt;：此选项的效果和指定<span class="string">&quot;--lines&quot;</span>选项相同。</span><br><span class="line">--sid&lt;阶段作业&gt;：此选项的效果和指定<span class="string">&quot;-s&quot;</span>选项相同。</span><br><span class="line">--tty&lt;终端机编号&gt;：此选项的效果和指定<span class="string">&quot;-t&quot;</span>选项相同。</span><br><span class="line">--user&lt;用户名称&gt;：此选项的效果和指定<span class="string">&quot;-U&quot;</span>选项相同。</span><br><span class="line">--User&lt;用户识别码&gt;：此选项的效果和指定<span class="string">&quot;-U&quot;</span>选项相同。</span><br><span class="line">--version：此选项的效果和指定<span class="string">&quot;-V&quot;</span>选项相同。</span><br><span class="line">--widty&lt;每列字符数&gt;：此选项的效果和指定<span class="string">&quot;-cols&quot;</span>选项相同。</span><br></pre></td></tr></table></figure>



<h3 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kaituorensheng/p/3980334.html">参考</a></p>
<p>jobs 查看后台进程</p>
<p><code>kill</code> %编号</p>
<p><code>killall</code> 程序名</p>
<h3 id="命令执行顺序"><a href="#命令执行顺序" class="headerlink" title="命令执行顺序"></a>命令执行顺序</h3><table>
<thead>
<tr>
<th>字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>;</td>
<td>在前一个命令结束时，而忽略其返回值，继续执行下一个命令。 *</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>在前一个命令结束时，若返回值为 true，继续执行下一个命令。 *</td>
</tr>
<tr>
<td>||</td>
<td>在前一个命令结束时，若返回值为 false，继续执行下一个命令。 *</td>
</tr>
</tbody></table>
<h3 id="zsh提示符"><a href="#zsh提示符" class="headerlink" title="zsh提示符"></a>zsh提示符</h3><p>下面是一些比较常用的转义变量</p>
<table>
<thead>
<tr>
<th align="center">转义变量</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">%T</td>
<td align="center">系统时间（时：分）</td>
</tr>
<tr>
<td align="center">%*</td>
<td align="center">系统时间（时：分：秒）</td>
</tr>
<tr>
<td align="center">%D</td>
<td align="center">系统日期（年-月-日）</td>
</tr>
<tr>
<td align="center">%n</td>
<td align="center">你的用户名</td>
</tr>
<tr>
<td align="center">%B - %b</td>
<td align="center">开始到结束使用粗体打印</td>
</tr>
<tr>
<td align="center">%U - %u</td>
<td align="center">开始到结束使用下划线打印</td>
</tr>
<tr>
<td align="center">%d</td>
<td align="center">你目前的工作目录</td>
</tr>
<tr>
<td align="center">%~</td>
<td align="center">你目前的工作目录相对于～的相对路径（可能在某些zsh版本可能造成乱码）</td>
</tr>
<tr>
<td align="center">%M</td>
<td align="center">计算机的主机名</td>
</tr>
<tr>
<td align="center">%m</td>
<td align="center">计算机的主机名（在第一个句号之前截断）</td>
</tr>
<tr>
<td align="center">%l</td>
<td align="center">你当前的tty</td>
</tr>
</tbody></table>
<p>更多详细的转义指令可以到<a target="_blank" rel="noopener" href="http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html">zsh Prompt-Expansion</a>查询。</p>
<p>下面是配置：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提示符,颜色分别为红黄青蓝</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$UID</span>&quot;</span> -eq 0  ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> PROMPT=<span class="string">&quot;%F&#123;red&#125;%# %f&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$UID</span>&quot;</span> -eq 1000 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> PROMPT=<span class="string">&quot;%&#123;^[[33m%&#125;\$ %f&quot;</span></span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">&quot;<span class="variable">$UID</span>&quot;</span> -eq 1001 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> PROMPT=<span class="string">&quot;%F&#123;118&#125;\$ %f&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">export</span> PROMPT=<span class="string">&quot;%&#123;^[[32m%&#125;\$ %f&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置这个会让 awk printf 出错</span></span><br><span class="line"><span class="comment">#------------------------------</span></span><br><span class="line"><span class="comment"># Window title</span></span><br><span class="line"><span class="comment">#------------------------------</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$TERM</span> <span class="keyword">in</span></span><br><span class="line">  termite|*xterm*|rxvt|rxvt-unicode|rxvt-256color|rxvt-unicode-256color|(dt|k|E)term)</span><br><span class="line">    <span class="function"><span class="title">precmd</span></span> () &#123;</span><br><span class="line">        <span class="built_in">print</span> -Pn <span class="string">&quot;\e]0;%n: %~%(!.#.$)\a&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">preexec</span></span> () &#123; <span class="built_in">print</span> -Pn <span class="string">&quot;\e]0;%n: %~%(!.#.$)  (<span class="variable">$1</span>)\a&quot;</span> &#125;</span><br><span class="line">    ;;</span><br><span class="line">  screen|screen-256color)</span><br><span class="line">    <span class="function"><span class="title">precmd</span></span> () &#123;</span><br><span class="line">      <span class="built_in">print</span> -Pn <span class="string">&quot;\e]83;title \&quot;<span class="variable">$1</span>\&quot;\a&quot;</span></span><br><span class="line">      <span class="built_in">print</span> -Pn <span class="string">&quot;\e]0;<span class="variable">$TERM</span> - (%L) [%n]%# [%~]\a&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">preexec</span></span> () &#123;</span><br><span class="line">      <span class="built_in">print</span> -Pn <span class="string">&quot;\e]83;title \&quot;<span class="variable">$1</span>\&quot;\a&quot;</span></span><br><span class="line">      <span class="built_in">print</span> -Pn <span class="string">&quot;\e]0;<span class="variable">$TERM</span> - (%L) [%n]%# [%~] (<span class="variable">$1</span>)\a&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>

<p><code>%#</code>:  A ‘<code>#</code>’ if the shell is running with privileges, a ‘<code>%</code>’ if not. Equivalent to ‘<code>%(!.#.%%)</code>’. </p>
<p>所以我把 <code>%#</code> 换成 <code>%(!.#.$)</code> 了。</p>
<p>虽然不知道为啥会出错，但是换一个就好了：<a target="_blank" rel="noopener" href="http://blog.pengyifan.com/how-to-set-terminal-title-dynamically-to-the-current-working-directory/">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="variable">$TERM</span> <span class="keyword">in</span></span><br><span class="line">  xterm*)</span><br><span class="line">    <span class="function"><span class="title">precmd</span></span> () &#123;<span class="built_in">print</span> -Pn <span class="string">&quot;\e]0;%~\a&quot;</span>&#125;</span><br><span class="line">    ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#https://askubuntu.com/questions/324725/getting-command-not-found-working-under-zsh</span></span><br><span class="line"><span class="keyword">if</span> [[ -s <span class="string">&#x27;/etc/zsh_command_not_found&#x27;</span> ]]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">source</span> <span class="string">&#x27;/etc/zsh_command_not_found&#x27;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#这个不行啊，数据库找不到的就不提示了</span></span><br><span class="line"><span class="comment">#找到问题了，配置文件有问题，加了</span></span><br><span class="line">$ sudo vi /etc/zsh_command_not_found</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ -x /usr/lib/command-not-found ]] ; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> (( ! <span class="variable">$&#123;+functions[command_not_found_handler]&#125;</span> )) ; <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">function</span> command_not_found_handler &#123;</span><br><span class="line">            [[ -x /usr/lib/command-not-found ]] || <span class="built_in">return</span> 1</span><br><span class="line">            /usr/lib/command-not-found -- <span class="variable">$&#123;1+&quot;$1&quot;&#125;</span> &amp;&amp; :</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#因为--no-failure-msg会导致不显示信息，把它删掉就好了</span></span><br></pre></td></tr></table></figure>

<h3 id="WSL字体永久生效"><a href="#WSL字体永久生效" class="headerlink" title="WSL字体永久生效"></a>WSL字体永久生效</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/MobiuX/article/details/82194028">参考</a></p>
<p>Win+r     <code>regedit</code></p>
<p>在注册表项目：<br><code>HKEY_CURRENT_USER\Console\C:_Program Files_WindowsApps_CanonicalGroupLimited.Ubuntu18.04onWindows_1804.2018.817.0_x64__79rhkp1fndgsc_ubuntu1804.exe</code></p>
<p>添加：<code>CodePage</code>（<code>DWORD类型</code>、值0x<code>01b5</code>）就是437。</p>
<p><code>FaceName</code> 改为 <code>Consolas</code>。</p>
<p>这是修改 Ubuntu 的。</p>
<p>或者 <code>计算机\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Console\TrueTypeFont</code> 里 636 的值改成 <code>Consolas</code></p>
<p>布局里 <code>调整大小时对输出的文本换行</code> 取消勾选。</p>
<h4 id="wsl-环境变量"><a href="#wsl-环境变量" class="headerlink" title="wsl 环境变量"></a>wsl 环境变量</h4><p><a target="_blank" rel="noopener" href="https://lengthmin.me/posts/install-arch-wsl/#%E9%85%8D%E7%BD%AE-path-%E5%8F%98%E9%87%8F">删除win10的本地环境变量</a></p>
<h4 id="vim-粘贴时缩进错乱"><a href="#vim-粘贴时缩进错乱" class="headerlink" title="vim 粘贴时缩进错乱"></a>vim 粘贴时缩进错乱</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/ayanmw/p/3645183.html">解决方法</a></p>
<h3 id="date时间输出"><a href="#date时间输出" class="headerlink" title="date时间输出"></a>date时间输出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ date <span class="string">&quot;+%Y-%m-%d&quot;</span></span><br><span class="line">2019-08-02</span><br><span class="line">$ date <span class="string">&quot;+%H:%M:%S&quot;</span></span><br><span class="line">13:55:39</span><br><span class="line">$ date <span class="string">&quot;+%Y%m%d_%H%M%S&quot;</span></span><br><span class="line">20190802_135707</span><br></pre></td></tr></table></figure>

<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>每一个变量的值都是字符串，无论你给变量赋值时有没有使用引号，值都会以字符串的形式存储。</p>
<p>这意味着，Bash shell 在默认情况下不会区分变量类型，即使你将整数和小数赋值给变量，它们也会被视为字符串，这一点和大部分的编程语言不同。\</p>
<p><strong>赋值号的周围不能有空格</strong></p>
<p>使用变量时可以把变量<strong>用花括号括起来</strong>，帮助解释器识别变量的边界，推荐这么做。</p>
<h4 id="清除变量"><a href="#清除变量" class="headerlink" title="清除变量"></a>清除变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#你可以试试..</span></span><br><span class="line"><span class="built_in">unset</span> PATH                   <span class="comment">#无法清除只读变量</span></span><br></pre></td></tr></table></figure>

<h4 id="显示所有本地-shell-变量"><a href="#显示所有本地-shell-变量" class="headerlink" title="显示所有本地 shell 变量"></a>显示所有本地 shell 变量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure>

<h4 id="测试变量是否已经设置"><a href="#测试变量是否已经设置" class="headerlink" title="测试变量是否已经设置"></a>测试变量是否已经设置</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果设置了变量值，则使用它，如果未设置，则取新值</span></span><br><span class="line">$ COLOUR=blue                            <span class="comment">#等号两边不能有空格</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;The sky is <span class="variable">$&#123;COLOUR:-grey&#125;</span> today&quot;</span></span><br><span class="line">The sky is blue today</span><br></pre></td></tr></table></figure>

<h4 id="设置只读变量-常量"><a href="#设置只读变量-常量" class="headerlink" title="设置只读变量(常量)"></a>设置只读变量(常量)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ COLOUR=blue</span><br><span class="line">$ <span class="built_in">readonly</span> COLOUR</span><br><span class="line"></span><br><span class="line">$ COLOUR=grey</span><br><span class="line">zsh: read-only variable: COLOUR</span><br><span class="line">$ <span class="built_in">unset</span> COLOUR</span><br><span class="line">zsh: read-only variable: COLOUR</span><br></pre></td></tr></table></figure>

<h4 id="将命令的结果赋值给变量"><a href="#将命令的结果赋值给变量" class="headerlink" title="将命令的结果赋值给变量"></a>将命令的结果赋值给变量</h4><p>Shell 也支持将命令的执行结果赋值给变量，常见的有以下两种方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">variable=`<span class="built_in">command</span>`</span><br><span class="line">variable=$(<span class="built_in">command</span>)</span><br></pre></td></tr></table></figure>

<p>第一种方式把命令用反引号包围起来，反引号和单引号非常相似，容易产生混淆，所以不推荐使用这种方式；</p>
<p>第二种方式把命令用<code>$()</code>包围起来，区分更加明显，所以推荐使用这种方式。</p>
<h4 id="特殊变量-系统保留变量"><a href="#特殊变量-系统保留变量" class="headerlink" title="特殊变量(系统保留变量)"></a>特殊变量(系统保留变量)</h4><table>
<thead>
<tr>
<th align="center">变量</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">$0</td>
<td>当前脚本的文件名</td>
</tr>
<tr>
<td align="center">$n</td>
<td>传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。</td>
</tr>
<tr>
<td align="center">$#</td>
<td>传递给脚本或函数的参数个数。</td>
</tr>
<tr>
<td align="center">$*</td>
<td>传递给脚本或函数的所有参数。</td>
</tr>
<tr>
<td align="center">$@</td>
<td>传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。</td>
</tr>
<tr>
<td align="center">$?</td>
<td>上个命令的退出状态，或函数的返回值。</td>
</tr>
<tr>
<td align="center">$$</td>
<td>当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。</td>
</tr>
</tbody></table>
<h4 id="export"><a href="#export" class="headerlink" title="export"></a>export</h4><p><a target="_blank" rel="noopener" href="http://www.linuxso.com/command/export.html">参考</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/dreamcoding/article/details/8519689">父 shell，子 shell ，export 与 变量传递</a></p>
<h3 id="运算符-1"><a href="#运算符-1" class="headerlink" title="运算符"></a>运算符</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/2736.html">参考</a></p>
<h4 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>加法</td>
<td><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td>-</td>
<td>减法</td>
<td><code>expr $a - $b</code> 结果为 10。</td>
</tr>
<tr>
<td>*</td>
<td>乘法</td>
<td><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td>/</td>
<td>除法</td>
<td><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td>%</td>
<td>取余</td>
<td><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td>=</td>
<td>赋值</td>
<td>a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td>==</td>
<td>相等。用于比较两个数字，相同则返回 true。</td>
<td>[ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>不相等。用于比较两个数字，不相同则返回 true。</td>
<td>[ $a != $b ] 返回 true。</td>
</tr>
</tbody></table>
<ul>
<li>表达式和运算符之间要有<strong>空格</strong>，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li>
<li>乘号 <code>*</code> 前边必须加反斜杠 <code>\</code> 才能实现乘法运算；</li>
<li>条件表达式要放在方括号之间，并且<strong>要有空格</strong>，例如 [$a==$b] 是错误的，必须写成 [ $a == $b ]。</li>
</ul>
<h4 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h4><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-eq</td>
<td>检测两个数是否相等，相等返回 true。</td>
<td>[ $a -eq $b ] 返回 true。</td>
</tr>
<tr>
<td>-ne</td>
<td>检测两个数是否相等，不相等返回 true。</td>
<td>[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td>-gt</td>
<td>检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td>[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td>-lt</td>
<td>检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td>[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td>-ge</td>
<td>检测左边的数是否大等于右边的，如果是，则返回 true。</td>
<td>[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td>-le</td>
<td>检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td>[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
<h4 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>!</td>
<td>非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td>[ ! false ] 返回 true。</td>
</tr>
<tr>
<td>-o</td>
<td>或运算，有一个表达式为 true 则返回 true。</td>
<td>[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td>-a</td>
<td>与运算，两个表达式都为 true 才返回 true。</td>
<td>[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
<h4 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h4><table>
<thead>
<tr>
<th>运算符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>检测两个字符串是否相等，相等返回 true。</td>
<td>[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td>!=</td>
<td>检测两个字符串是否相等，不相等返回 true。</td>
<td>[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td>-z</td>
<td>检测字符串长度是否为0，为0返回 true。</td>
<td>[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td>-n</td>
<td>检测字符串长度是否为0，不为0返回 true。</td>
<td>[ -z $a ] 返回 true。</td>
</tr>
<tr>
<td>str</td>
<td>检测字符串是否为空，不为空返回 true。</td>
<td>[ $a ] 返回 true。</td>
</tr>
</tbody></table>
<h4 id="文件测试运算符"><a href="#文件测试运算符" class="headerlink" title="文件测试运算符"></a>文件测试运算符</h4><table>
<thead>
<tr>
<th>操作符</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>-b file</td>
<td>检测文件是否是块设备文件，如果是，则返回 true。</td>
<td>[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-c file</td>
<td>检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td>[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td>-d file</td>
<td>检测文件是否是目录，如果是，则返回 true。</td>
<td>[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td>-f file</td>
<td>检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td>[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td>-g file</td>
<td>检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td>[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td>-k file</td>
<td>检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td>[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td>-p file</td>
<td>检测文件是否是具名管道，如果是，则返回 true。</td>
<td>[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td>-u file</td>
<td>检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td>[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td>-r file</td>
<td>检测文件是否可读，如果是，则返回 true。</td>
<td>[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td>-w file</td>
<td>检测文件是否可写，如果是，则返回 true。</td>
<td>[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td>-x file</td>
<td>检测文件是否可执行，如果是，则返回 true。</td>
<td>[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td>-s file</td>
<td>检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td>[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td>-e file</td>
<td>检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td>[ -e $file ] 返回 true。</td>
</tr>
</tbody></table>
<h3 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h3><p>这个和 <code>awk</code> 的 <code>printf</code> 不是同一个，但是类似</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/1499.html">参考</a></p>
<h3 id="Shell-if-else语句"><a href="#Shell-if-else语句" class="headerlink" title="Shell if else语句"></a>Shell if else语句</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/7005.html">参考</a></p>
<h3 id="Shell-test命令"><a href="#Shell-test命令" class="headerlink" title="Shell test命令"></a>Shell test命令</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/7004.html">参考</a></p>
<p>可以用 <code>[]</code> 代替呀，经常看到</p>
<h3 id="Shell-case-esac语句"><a href="#Shell-case-esac语句" class="headerlink" title="Shell case esac语句"></a>Shell case esac语句</h3><p>类似于 C 语言中的 switch … case 语句</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/7006.html">参考</a></p>
<h3 id="Shell-循环"><a href="#Shell-循环" class="headerlink" title="Shell 循环"></a>Shell 循环</h3><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/7007.html">for 循环</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/7008.html">while 循环</a></p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/7009.html">until 循环</a></p>
<p>记下来等于我会了，，看都不用看的。。</p>
<p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/view/7010.html">break和continue命令</a> </p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下载最新的安装</span></span><br><span class="line">$ wget https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/man-pages-5.02.tar.gz</span><br><span class="line">$ wget https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/man-pages-posix/man-pages-posix-2013-a.tar.gz</span><br></pre></td></tr></table></figure>

<p>关于 <code>man gcc</code> 在 Debian 里找不到的问题。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ls /usr/share/man/man1 | grep gcc</span><br><span class="line">$ file /usr/share/man/man1/gcc.1.gz</span><br><span class="line">/usr/share/man/man1/gcc.1.gz: symbolic link to gcc-8.1.gz</span><br><span class="line">$ file /usr/share/man/man1/gcc-8.1.gz</span><br><span class="line">/usr/share/man/man1/gcc-8.1.gz: symbolic link to x86_64-linux-gnu-gcc-8.1.gz</span><br></pre></td></tr></table></figure>

<p>然而我发现 Debian 真的没有，去 Ubuntu 里面拷一份吧。。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#### Ubuntu</span></span><br><span class="line">$ <span class="built_in">cd</span> /usr/share/man</span><br><span class="line">$ tar cf ~/gcc.tar man1/*gcc*</span><br><span class="line">$ <span class="built_in">cd</span></span><br><span class="line">$ ls</span><br><span class="line">$ mv gcc.tar /mnt/d</span><br><span class="line"></span><br><span class="line"><span class="comment">#### Debian</span></span><br><span class="line">$ mv /mnt/d/gcc.tar ./</span><br><span class="line">$ su</span><br><span class="line">Password:</span><br><span class="line"><span class="comment"># tar xf gcc.tar</span></span><br><span class="line"><span class="comment"># mv man1/* /usr/share/man/man1</span></span><br></pre></td></tr></table></figure>



<p><strong>man 彩色显示</strong>:</p>
<p>加入 <code>.bashrc</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Highlight the man manual</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_mb=$<span class="string">&#x27;\E[01;31m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_md=$<span class="string">&#x27;\E[01;31m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_me=$<span class="string">&#x27;\E[0m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_se=$<span class="string">&#x27;\E[0m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_so=$<span class="string">&#x27;\E[00;47;30m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_ue=$<span class="string">&#x27;\E[0m&#x27;</span></span><br><span class="line"><span class="built_in">export</span> LESS_TERMCAP_us=$<span class="string">&#x27;\E[01;32m&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>实际上在刚接触 Linux 的时候就知道有这个东西了，但是一直用的是 man。今天尝试了一下 info，感觉有些东西很不错，但是它的手册页没有 man 全，而且我也不知道怎么让它彩色显示，所以总体来说还是比不上 man。</p>
<p>它的快捷键用起来很不习惯，所以改了一下。</p>
<p>新建 <code>~/.infokey</code>：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">j       next-line</span><br><span class="line">k       prev-line</span><br><span class="line">v       <span class="keyword">get</span>-info-help-node</span><br><span class="line">o       history-node</span><br><span class="line">h       backward-char</span><br><span class="line">l       forward-char</span><br><span class="line">\mn     move-to-prev-xref        #\m 是 Alt</span><br><span class="line">\mm     move-to-next-xref</span><br><span class="line">\mh     beginning-of-line</span><br><span class="line">\mj     scroll-half-screen-down</span><br><span class="line">\mk     scroll-half-screen-up</span><br><span class="line">\ml     end-of-line</span><br><span class="line">w       next-node</span><br><span class="line">n       search-next</span><br><span class="line">N       search-previous</span><br></pre></td></tr></table></figure>

<p>主要仿照 <code>vim</code> 更改了方向键，还有连续搜索。和原来冲突的键要记得给它绑定另一个键位，当然不这么做也没啥，就是它原来的功能没法用了。</p>
<h3 id="fish配置"><a href="#fish配置" class="headerlink" title="fish配置"></a>fish配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.config/fish/config.fish</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fish_greeting</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fish_title</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Debian GNU/Linux: &quot;</span> (__fish_pwd)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> fish_prompt --description <span class="string">&quot;Write out the prompt&quot;</span></span><br><span class="line">    set_color 66FFCC</span><br><span class="line">    <span class="built_in">echo</span> -n -s <span class="string">&#x27;$ &#x27;</span></span><br><span class="line">    set_color normal</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">bind</span> \el accept-autosuggestion</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ls --description <span class="string">&quot;lists files&quot;</span></span><br><span class="line">    /bin/ls --color=auto --group-directories-first <span class="variable">$argv</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ll --description <span class="string">&quot;lists files with a long listing format&quot;</span></span><br><span class="line">    ls -lh <span class="variable">$argv</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> la --description <span class="string">&#x27;lists hidden files&#x27;</span></span><br><span class="line">    ls -A <span class="variable">$argv</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lf --description <span class="string">&#x27;lists files with indicator&#x27;</span></span><br><span class="line">    ls -F <span class="variable">$argv</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lc --description <span class="string">&#x27;lists sorted by date, most recent last, shows change time&#x27;</span></span><br><span class="line">    ll -c <span class="variable">$argv</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> lu --description <span class="string">&#x27;lists sorted by date, most recent last, shows access time&#x27;</span></span><br><span class="line">    ll -u <span class="variable">$argv</span></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="只把fish设为交互式shell"><a href="#只把fish设为交互式shell" class="headerlink" title="只把fish设为交互式shell"></a>只把fish设为交互式shell</h4><p>在<code>.bashrc</code> 中最后加一行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;<span class="variable">$BASH_EXECUTION_STRING</span>&quot;</span> ]; <span class="keyword">then</span> <span class="built_in">exec</span> fish; <span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<p>在这种情况下，要启动 bash，要输入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ bash --norc</span><br></pre></td></tr></table></figure>



<h3 id="wireshark-权限不足，找不到网络接口"><a href="#wireshark-权限不足，找不到网络接口" class="headerlink" title="wireshark 权限不足，找不到网络接口"></a>wireshark 权限不足，找不到网络接口</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qfhyadx/article/details/78647806">参考</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo chgrp wireshark /usr/bin/dumpcap</span><br><span class="line">$ sudo chmod 4755 /usr/bin/dumpcap</span><br><span class="line">$ sudo gpasswd -a puraro wireshark</span><br></pre></td></tr></table></figure>



<h3 id="解决WSL更改默认字体为consolas，进入文件后退出文件字体又变为宋体"><a href="#解决WSL更改默认字体为consolas，进入文件后退出文件字体又变为宋体" class="headerlink" title="解决WSL更改默认字体为consolas，进入文件后退出文件字体又变为宋体"></a>解决WSL更改默认字体为consolas，进入文件后退出文件字体又变为宋体</h3><p>解决方法如下</p>
<p>输入regedit进入注册表编辑器<br>HKEY_CURRENT_USER\Console\C:_Program Files_WindowsApps_CanonicalGroupLimited.UbuntuonWindows_1804.2019.521.0_x64__79rhkp1fndgsc_ubuntu.exe，高亮部分很可能是Ubuntu的安装版本<br>新建CodePage值，输入值为65001，十进制</p>
<h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1><h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p>TCP/IP 首部中所有的二进制整数在网络中传输时采用 big endian 字节序，因此它又称作网络字节序。以其他形式存储二进制整数的机器，如 little endian 格式(符合人的认知)，则必须在传输数据之前把首部转换成网络字节序。</p>
<h3 id="net-tools-和-iproute2"><a href="#net-tools-和-iproute2" class="headerlink" title="net-tools 和 iproute2"></a>net-tools 和 iproute2</h3><p>net-tools 工具箱包括 ifconfig 、 route 、 arp 和 netstat ，2001年起已经不再维护，取而代之的是 iproute2 。</p>
<p><a target="_blank" rel="noopener" href="https://linux.cn/article-4326-1.html">详细说明</a></p>
<h3 id="配置双网卡路由表"><a href="#配置双网卡路由表" class="headerlink" title="配置双网卡路由表"></a>配置双网卡路由表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">route -p ADD 192.168.3.0 MASK 255.255.255.0  192.168.3.1 METRIC 4 IF 6</span><br><span class="line">route -p ADD 0.0.0.0 MASK 0.0.0.0  172.26.10.248 METRIC 2 IF 18</span><br><span class="line"></span><br><span class="line">route -p ADD 172.31.34.31 MASK 255.255.255.0  192.168.1.1 METRIC 4 IF 6</span><br><span class="line">route DELETE 172.31.34.31</span><br><span class="line"><span class="comment">#这个才有用</span></span><br><span class="line">route ADD 172.31.34.0 MASK 255.255.255.0  192.168.1.1 METRIC 4 IF 58</span><br><span class="line">route ADD 172.31.50.164 MASK 255.255.255.255  192.168.1.1 METRIC 7 IF 58</span><br><span class="line">route ADD 59.111.0.251 MASK 255.255.255.255  192.168.1.1 METRIC 7 IF 21</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再把连到板子的 eth0 配置成 fix，只要填 ip 和 mask</p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p><a target="_blank" rel="noopener" href="http://c.biancheng.net/cpp/html/3030.html">参考1</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/L-hq815/archive/2012/07/09/2583043.html">参考2</a></p>
<h3 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ socs1 &amp;</span><br><span class="line">[1] 22434</span><br><span class="line">$ socc1</span><br><span class="line">Message form server: Hello World!</span><br><span class="line">[1]  + 22434 <span class="keyword">done</span>       socs1</span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<p>虽然不是我写的，原理我还没看，但是第一个可以运行的程序很有意义，我已经成功一半了。。(做梦呐)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socs1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> serv_sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将套接字和IP、端口绑定</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line"><span class="comment">// 这个用不到，监听socket只需要端口就好了    </span></span><br><span class="line"><span class="comment">//    serv_addr.sin_addr.s_addr = inet_addr(&quot;127.0.0.1&quot;);  //具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    bind(serv_sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//进入监听状态，等待用户发起请求</span></span><br><span class="line">    listen(serv_sock, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收客户端请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="keyword">int</span> clnt_sock = accept(serv_sock, (struct sockaddr*)&amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向客户端发送数据</span></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">&quot;Hi, Snoire!&quot;</span>;</span><br><span class="line">    write(clnt_sock, str, <span class="keyword">sizeof</span>(str)); <span class="comment">//send(clnt_sock, str, sizeof(str),0);</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    close(clnt_sock);   <span class="comment">//为什么server要创建两个socket，我看用py写的只用一个啊</span></span><br><span class="line">    close(serv_sock);   <span class="comment">//在 参考2 的 11）accept()函数 部分好像有讲，一个用于监听，一个发送</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关于上面绑定自己的ip那个，事实证明</span></span><br><span class="line"><span class="comment">//不写可以，写127.0.0.1可以，但是乱写不行</span></span><br><span class="line"><span class="comment">//或者 sockAddr.sin_addr.s_addr = htonl(INADDR_ANY);  //使用自己的IP地址</span></span><br><span class="line"><span class="comment">//说明ip是必须要的，但是默认是自己的地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//网上说，有可能有多个网卡，所以要填自己的ip</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//参考2</span></span><br><span class="line"><span class="comment">//my_addr.sin_port = htons(0); /* 随机选择一个没有使用的端口 */</span></span><br><span class="line"><span class="comment">//my_addr.sin_addr.s_addr = htonl(INADDR_ANY);/* 使用自己的IP地址 */</span></span><br><span class="line"><span class="comment">//inet_addr()返回的地址已经是网络字节格式，所以你无需再调用函数htonl()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//首先服务器IP肯定是对客户端公开的</span></span><br><span class="line"><span class="comment">//服务器怎么知道客户端IP呢？就是客户端登录时，先给服务器IP发登录消息，服务器收到该消息，该消息的来源自然就是客户端IP了</span></span><br><span class="line"><span class="comment">//双方IP都互相知道了，怎么通信都没问题了</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//socc1.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//创建套接字</span></span><br><span class="line">    <span class="keyword">int</span> sock = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器（特定的IP和端口）发起请求</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(serv_addr));  <span class="comment">//每个字节都用0填充</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;  <span class="comment">//使用IPv4地址</span></span><br><span class="line">    serv_addr.sin_addr.s_addr = inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//具体的IP地址</span></span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">1234</span>);  <span class="comment">//端口</span></span><br><span class="line">    connect(sock, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//读取服务器传回的数据</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">40</span>];</span><br><span class="line">    read(sock, buffer, <span class="keyword">sizeof</span>(buffer)<span class="number">-1</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Message form server: %s\n&quot;</span>, buffer);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//关闭套接字</span></span><br><span class="line">    close(sock);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ socs1.cpp -o socs1</span><br><span class="line">$ g++ socc1.cpp -o socc1</span><br></pre></td></tr></table></figure>

<p>上面的源文件后缀为<code>.cpp</code>，是C++代码，所以要用<code>g++</code>命令来编译。</p>
<blockquote>
<p>C++和C语言的一个重要区别是：在C语言中，变量必须在函数的开头定义；而在C++中，变量可以在函数的任何地方定义，使用更加灵活。这里之所以使用C++代码，是不希望在函数开头堆砌过多变量。</p>
</blockquote>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># makefile</span></span><br><span class="line"></span><br><span class="line">all : socs1 socc1</span><br><span class="line">.PHONY : all</span><br><span class="line"></span><br><span class="line">socs1 : socs1.o</span><br><span class="line">    @g++ -o socs1 socs1.o</span><br><span class="line">    @echo <span class="string">&quot;generate socs1&quot;</span></span><br><span class="line">socs1.o : socs1.cpp</span><br><span class="line">    @g++ -c socs1.cpp</span><br><span class="line">    @echo <span class="string">&quot;generate socs1.o&quot;</span></span><br><span class="line"></span><br><span class="line">socc1 : socc1.o</span><br><span class="line">    @g++ -o socc1 socc1.o</span><br><span class="line">    @echo <span class="string">&quot;generate socc1&quot;</span></span><br><span class="line">socc1.o : socc1.cpp</span><br><span class="line">    @g++ -c socc1.cpp</span><br><span class="line">    @echo <span class="string">&quot;generate socc1.o&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.PHONY : run</span><br><span class="line">run : all</span><br><span class="line">    socs1 &amp;</span><br><span class="line">    socc1</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    rm -f *.o *.test</span><br></pre></td></tr></table></figure>



<blockquote>
<p>为什么基于TCP的服务端程序要创建两个套接字，而基于UDP的只需要创建一个套接字？<br>这是因为TCP的程序进行通信需要建立连接，所以必须有一个套接字是专门用来监听客户端的连接请求的，接受请求后就创建新的套接字与客户端通信；而UDP的程序是无连接通信，所以只要有一个套接字用来接收或发送数据就可以了。</p>
</blockquote>
<h3 id="转换大小写程序"><a href="#转换大小写程序" class="headerlink" title="转换大小写程序"></a>转换大小写程序</h3><p>ser.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">&#x27;&#x27;</span>, serverPort))</span><br><span class="line">print(<span class="string">&quot;The server is ready to receive&quot;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMessage = message.decode().lower()    <span class="comment">#upper</span></span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br></pre></td></tr></table></figure>

<p>cli.py</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">&#x27;localhost&#x27;</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">message = <span class="built_in">input</span>(<span class="string">&#x27;Input uppercase sentence:\n&#x27;</span>)</span><br><span class="line">clientSocket.sendto(message.encode(),(serverName, serverPort))</span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">print(<span class="string">&quot;The lowercase is:&quot;</span>)</span><br><span class="line">print(modifiedMessage.decode())</span><br><span class="line">clientSocket.close()</span><br><span class="line"><span class="built_in">str</span> = <span class="built_in">input</span>(<span class="string">&quot;press..算了，按任意键退出。。 &quot;</span>)</span><br></pre></td></tr></table></figure>



<h3 id="sockaddr-in结构体"><a href="#sockaddr-in结构体" class="headerlink" title="sockaddr_in结构体"></a>sockaddr_in结构体</h3><p><img src="/passages/Learning-notes/sockaddr_in%E7%BB%93%E6%9E%84%E4%BD%93.jpg" alt="sockaddr_in结构体"></p>
<p><img src="/passages/Learning-notes/sockaddr%E4%B8%8Esockaddr_in.jpg" alt="sockaddr_in结构体"></p>
<p>sockaddr_in 与 sockaddr 长度相同，强制转换不会丢失数据。</p>
<p>因为给 sa_data 赋值很难，所以需要这样转换，而且还有 ipv6 的地址呢，使用sockaddr_in6，这样也方便一点。</p>
<p><strong>send()</strong> 返回实际发送的数据的字节数–它可能小于你要求发送的数目！</p>
<p><strong>recv()</strong> 返回实际读入缓冲的数据的字节数。</p>
<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="blog"><a href="#blog" class="headerlink" title="blog"></a>blog</h2><h3 id="npm-版本太低"><a href="#npm-版本太低" class="headerlink" title="npm 版本太低"></a>npm 版本太低</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm uninstall -g npm</span><br><span class="line">sudo npm i -g npm@next</span><br></pre></td></tr></table></figure>

<p>可能会用到:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm update core-js</span><br></pre></td></tr></table></figure>



<h3 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用apt安装的需要这样设置 ~/.profile</span></span><br><span class="line"><span class="comment">#fish没法用。。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># set GOPATH</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$HOME</span>/go&quot;</span> ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">export</span> GOPATH=<span class="variable">$HOME</span>/go</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">export</span> GOROOT=/usr/lib/go</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$GOROOT</span>/bin</span><br></pre></td></tr></table></figure>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E9%A1%BA%E5%BA%8F"><span class="toc-text">学习顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80"><span class="toc-text">C语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASCII-%E8%A1%A8"><span class="toc-text">ASCII 表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-%E8%AF%AD%E8%A8%80%E7%9A%84%E9%98%B4%E6%9A%97%E8%A7%92%E8%90%BD"><span class="toc-text">C 语言的阴暗角落</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementation-defined%E3%80%81Unspecified%E5%92%8CUndefined"><span class="toc-text">Implementation-defined、Unspecified和Undefined</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Side-Effect%E4%B8%8ESequence-Point"><span class="toc-text">Side Effect与Sequence Point</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8D%A2%E8%A1%8C"><span class="toc-text">换行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%92%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">变量和数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8D%A0%E7%94%A8%E7%9A%84%E5%86%85%E5%AD%98%E5%AD%97%E8%8A%82"><span class="toc-text">不同数据类型占用的内存字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA"><span class="toc-text">不同进制表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E5%88%B6%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">不同进制的格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#printf-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA%E7%AC%A6%E5%8F%B7"><span class="toc-text">printf 格式化输出符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">整数在内存中的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4%E4%BB%A5%E5%8F%8A%E6%95%B0%E5%80%BC%E6%BA%A2%E5%87%BA"><span class="toc-text">整数取值范围以及数值溢出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E6%95%B0%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BA"><span class="toc-text">小数的格式化输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E7%9A%84%E5%90%8E%E7%BC%80"><span class="toc-text">数字的后缀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%A4%E6%B3%95%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">除法注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%8F%96%E4%BD%99%E8%BF%90%E7%AE%97%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-text">对取余运算的说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%A2%9E-%E5%92%8C%E8%87%AA%E5%87%8F-%E2%80%93"><span class="toc-text">自增(++)和自减(–)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%88%9D%E5%A7%8B%E5%80%BC"><span class="toc-text">变量的定义位置以及初始值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">数据类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">自动数据类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制数据类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-text">输入输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#printf-%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6"><span class="toc-text">printf 格式控制符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84%E5%92%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-text">循环结构和选择结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#break-%E8%B7%B3%E5%87%BA%E5%BE%AA%E7%8E%AF"><span class="toc-text">break 跳出循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%96%E5%9C%B0%E5%9D%80"><span class="toc-text">对字符串取地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-%E7%BB%93%E6%9D%9F%E7%AC%A6"><span class="toc-text">\0 结束符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E4%B8%8E%E4%BF%AE%E6%94%B9"><span class="toc-text">赋值与修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof-%E5%92%8C-strlen"><span class="toc-text">sizeof 和 strlen</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-text">多维数组的赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C-%E8%AE%BF%E9%97%AE"><span class="toc-text">数组越界 - 访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%BA%A2%E5%87%BA-%E8%B5%8B%E5%80%BC"><span class="toc-text">数组溢出 - 赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84"><span class="toc-text">变长数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E4%B8%8D%E5%AE%9A%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">输入不定长字符串</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#return"><span class="toc-text">return</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E"><span class="toc-text">函数声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E5%92%8C%E8%BF%AD%E4%BB%A3"><span class="toc-text">递归和迭代</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">指针变量作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">用数组作函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E6%95%B0%E7%BB%84"><span class="toc-text">从函数返回数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0"><span class="toc-text">指针函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">可变参数的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90"><span class="toc-text">命令行参数解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-text">预处理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#define"><span class="toc-text">#define</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F%E5%8F%82%E6%95%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%96%E5%92%8C%E8%BF%9E%E6%8E%A5"><span class="toc-text">宏参数的字符串化和连接</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%AE%8F%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">将宏参数转换为字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E5%AE%8F%E5%8F%82%E6%95%B0"><span class="toc-text">连接宏参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%AE%9A%E4%B9%89%E5%AE%8F"><span class="toc-text">预定义宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-text">条件编译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#if-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">#if 的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ifdef-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">#ifdef 的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ifndef-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-text">#ifndef 的用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">数组指针（指向数组的指针）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8C%87%E9%92%88"><span class="toc-text">字符串指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-1"><span class="toc-text">指针变量作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%95%B0%E7%BB%84%E4%BD%9C%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0-1"><span class="toc-text">用数组作函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">指针作为函数返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88"><span class="toc-text">二级指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88-NULL"><span class="toc-text">空指针 NULL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88"><span class="toc-text">void 指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E4%B8%8D%E7%AD%89%E4%BB%B7"><span class="toc-text">数组和指针不等价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%8C%87%E9%92%88"><span class="toc-text">数组在什么时候会转换为指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%95%B0%E7%BB%84%E5%90%8D%E5%8F%96%E5%9D%80-amp-arr"><span class="toc-text">对数组名取址 &amp;arr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87"><span class="toc-text">数组下标[ ]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%EF%BC%88%E6%95%B0%E7%BB%84%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E9%83%BD%E6%98%AF%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">指针数组（数组每个元素都是指针）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">二维数组指针（指向二维数组的指针）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%92%8C%E6%89%80%E5%8D%A0%E5%AD%97%E8%8A%82%E6%95%B0%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">类型和所占字节数的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84-%E5%92%8C-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-text">指针数组 和 二维数组指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%88%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%89"><span class="toc-text">函数指针（指向函数的指针）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">函数指针的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-text">数组与指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E4%B8%8E%E9%87%8E%E6%8C%87%E9%92%88"><span class="toc-text">空指针与野指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93"><span class="toc-text">指针总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-text">赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E7%BB%93%E6%9E%84%E4%BD%93%E6%88%90%E5%91%98"><span class="toc-text">获取结构体成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef-struct"><span class="toc-text">typedef struct</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89"><span class="toc-text">结构体的递归定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-text">结构体指针作为函数参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E5%A6%82%E4%BD%95%E5%8C%85%E5%90%AB%E5%87%BD%E6%95%B0"><span class="toc-text">C语言结构体中如何包含函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E7%94%A8%E4%BD%93"><span class="toc-text">共用体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF%E4%BB%A5%E5%8F%8A%E5%88%A4%E5%88%AB%E6%96%B9%E5%BC%8F"><span class="toc-text">大端小端以及判别方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F%EF%BC%88%E4%BD%8D%E6%AE%B5%EF%BC%89"><span class="toc-text">位域（位段）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8D%E4%BD%8D%E5%9F%9F"><span class="toc-text">无名位域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-text">位运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97%EF%BC%88-amp-%EF%BC%89"><span class="toc-text">按位与运算（&amp;）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%88-%EF%BC%89"><span class="toc-text">按位或运算（|）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97%EF%BC%88-%EF%BC%89"><span class="toc-text">按位异或运算（^）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85"><span class="toc-text">重要知识点补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E8%BF%90%E7%AE%97%E7%AC%A6-%E3%80%81-%E3%80%81"><span class="toc-text">C语言预处理运算符 #、##、#@</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">字符串化运算符 #</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">连接运算符 ##</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%8C%96%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">字符化运算符 #@</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typedef-%E5%92%8C-define-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">typedef 和 #define 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">const 和指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%92%8C%E5%87%BD%E6%95%B0%E5%BD%A2%E5%8F%82"><span class="toc-text">const 和函数形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const-%E5%92%8C%E9%9D%9E-const-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">const 和非 const 类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E4%B8%80%E5%AE%9A%E8%8C%83%E5%9B%B4%E5%86%85%E7%9A%84%E9%9A%8F%E6%9C%BA%E6%95%B0"><span class="toc-text">生成一定范围内的随机数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84-1"><span class="toc-text">变长数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fopen-%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-text">fopen() 函数的返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E6%98%AF%E5%90%A6%E6%89%93%E5%BC%80%E6%88%90%E5%8A%9F"><span class="toc-text">判断文件是否打开成功</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-text">关闭文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">文本文件和二进制文件的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fopen-%E4%B8%AD%E7%9A%84%E6%96%87%E6%9C%AC%E6%96%B9%E5%BC%8F%E5%92%8C%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B9%E5%BC%8F"><span class="toc-text">fopen() 中的文本方式和二进制方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E9%97%B4%E5%B1%82%E6%80%9D%E6%83%B3"><span class="toc-text">中间层思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90"><span class="toc-text">内存对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-text">C语言程序的内存布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%E6%94%BB%E5%87%BB-%E6%95%B0%E7%BB%84%E6%BA%A2%E5%87%BA"><span class="toc-text">栈溢出攻击(数组溢出)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%90%91%E9%87%8A%E6%94%BE%E6%8E%89%E7%9A%84%E5%86%85%E5%AD%98"><span class="toc-text">指向释放掉的内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A4%96%E9%83%A8%E6%8C%87%E9%92%88%E6%8C%87%E5%90%91%E5%87%BD%E6%95%B0%E5%86%85%E9%83%A8%E7%9A%84%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-text">函数外部指针指向函数内部的变量、数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%EF%BC%88Memory-Leak%EF%BC%89"><span class="toc-text">内存泄露（Memory Leak）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E5%AD%98%E5%82%A8%E7%B1%BB%E5%88%AB%E5%92%8C%E7%94%9F%E5%AD%98%E6%9C%9F"><span class="toc-text">变量的存储类别和生存期</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#auto"><span class="toc-text">auto</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#static"><span class="toc-text">static</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#register"><span class="toc-text">register</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile"><span class="toc-text">volatile</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">头文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#extern%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">extern关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Windows%E5%92%8CLinux%E4%B8%8B%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F"><span class="toc-text">Windows和Linux下的可执行文件格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%BC%B1%E7%AC%A6%E5%8F%B7"><span class="toc-text">强符号和弱符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E5%92%8C%E5%BC%B1%E5%BC%95%E7%94%A8"><span class="toc-text">强引用和弱引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%B4%E6%96%87%E4%BB%B6-1"><span class="toc-text">头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%96%E6%8B%AC%E5%8F%B7-%E5%92%8C-%E5%8F%8C%E5%BC%95%E5%8F%B7"><span class="toc-text">尖括号 和 双引号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB"><span class="toc-text">防止头文件被重复包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-text">static全局变量和函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux-Programming"><span class="toc-text">Linux Programming</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#priority-and-nice-value"><span class="toc-text">priority and nice value</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#C%E7%BC%96%E8%AF%91"><span class="toc-text">C编译</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#GCC"><span class="toc-text">GCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5"><span class="toc-text">链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gcc%E6%8C%87%E5%AE%9A%E5%A4%B4%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E5%8F%8A%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93%E8%B7%AF%E5%BE%84"><span class="toc-text">gcc指定头文件路径及动态链接库路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gdb-%E8%B0%83%E8%AF%95"><span class="toc-text">gdb 调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#makefile%E4%BB%8B%E7%BB%8D"><span class="toc-text">makefile介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8F-MACRO"><span class="toc-text">宏(MACRO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A9make%E8%87%AA%E5%8A%A8%E6%8E%A8%E5%AF%BC-%E9%9A%90%E6%99%A6%E8%A7%84%E5%88%99"><span class="toc-text">让make自动推导(隐晦规则)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E7%B1%BB%E9%A3%8E%E6%A0%BC%E7%9A%84makefiles"><span class="toc-text">另类风格的makefiles</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E5%AE%8F"><span class="toc-text">内部宏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E7%BC%80%E4%BE%9D%E8%B5%96"><span class="toc-text">后缀依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E7%A9%BA%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text">清空目标文件的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">Makefile里有什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Makefile%E7%9A%84%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">Makefile的文件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E5%85%B6%E5%AE%83%E7%9A%84Makefile"><span class="toc-text">引用其它的Makefile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E8%A7%84%E5%88%99"><span class="toc-text">书写规则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E4%B8%BE%E4%BE%8B"><span class="toc-text">规则举例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">规则的语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%A7%84%E5%88%99%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">在规则中使用通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%90%9C%E5%AF%BB"><span class="toc-text">文件搜寻</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E7%9B%AE%E6%A0%87"><span class="toc-text">伪目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%9B%AE%E6%A0%87"><span class="toc-text">多目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%A8%A1%E5%BC%8F"><span class="toc-text">静态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BE%9D%E8%B5%96%E6%80%A7"><span class="toc-text">自动生成依赖性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%A6%E5%86%99%E5%91%BD%E4%BB%A4"><span class="toc-text">书写命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%91%BD%E4%BB%A4"><span class="toc-text">显示命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-text">命令执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E5%87%BA%E9%94%99"><span class="toc-text">命令出错</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E6%89%A7%E8%A1%8Cmake"><span class="toc-text">嵌套执行make</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4%E5%8C%85"><span class="toc-text">定义命令包</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-text">使用变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux-%E5%91%BD%E4%BB%A4"><span class="toc-text">Linux 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-text">文件操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cp%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%88%B0%E5%A4%9A%E4%B8%AA%E7%9B%AE%E5%BD%95"><span class="toc-text">cp一个文件到多个目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%B9%E5%A4%A7%E5%B0%8F"><span class="toc-text">查看文件夹大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%B9%E6%9D%83%E9%99%90"><span class="toc-text">文件夹权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%9D%83%E9%99%90"><span class="toc-text">特殊权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#safe-rm"><span class="toc-text">safe-rm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shell-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-text">shell 通配符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#POSIX-%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-text">POSIX 字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRE-%E5%92%8C-ERE"><span class="toc-text">BRE 和 ERE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E6%84%8F%E5%AD%97%E7%AC%A6"><span class="toc-text">. 任意字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E9%9B%B6%E4%B8%AA%E6%88%96%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E4%BD%BF%E5%89%8D%E9%9D%A2%E7%9A%84%E5%85%83%E7%B4%A0%E5%8F%AF%E6%9C%89%E5%8F%AF%E6%97%A0"><span class="toc-text">? - 匹配零个或一个元素，使前面的元素可有可无</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E9%9B%B6%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">* - 匹配零个或多个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E4%B8%80%E4%B8%AA%E6%88%96%E5%A4%9A%E4%B8%AA%E5%85%83%E7%B4%A0"><span class="toc-text">+ - 匹配一个或多个元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E7%89%B9%E5%AE%9A%E4%B8%AA%E6%95%B0%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">&amp;#123; &amp;#125; - 匹配特定个数的元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#find-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">find - 查找文件名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#grep-%E6%9F%A5%E6%89%BE%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">grep - 查找文件内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#awk-%E6%8A%BD%E5%8F%96%E5%9F%9F"><span class="toc-text">awk - 抽取域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#awk%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F"><span class="toc-text">awk内置变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk-%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0-split"><span class="toc-text">awk 内置函数 split</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E6%9F%90%E5%88%97%E4%BB%A5%E5%90%8E%E7%9A%84%E6%89%80%E6%9C%89%E5%88%97"><span class="toc-text">打印某列以后的所有列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%9F%90%E4%BA%9B%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80"><span class="toc-text">删除某些前缀和后缀</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typora-%E7%94%9F%E6%88%90%E7%9A%84%E7%BD%91%E9%A1%B5%E5%9C%A8%E6%96%B0%E6%A0%87%E7%AD%BE%E9%A1%B5%E6%89%93%E5%BC%80%E9%93%BE%E6%8E%A5"><span class="toc-text">typora 生成的网页在新标签页打开链接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#awk-%E4%BD%BF%E7%94%A8-Shell-%E5%8F%98%E9%87%8F"><span class="toc-text">awk 使用 Shell 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#print%E5%92%8Cprintf"><span class="toc-text">print和printf</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#if%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5"><span class="toc-text">if条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E5%92%8C0"><span class="toc-text">1和0</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sed-%E6%96%87%E6%9C%AC%E8%BF%87%E6%BB%A4%E5%B7%A5%E5%85%B7"><span class="toc-text">sed - 文本过滤工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9"><span class="toc-text">直接修改文件内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">替换字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%B4%AA%E5%A9%AA%E5%8C%B9%E9%85%8D-%E5%A4%84%E7%90%86%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%97%A5%E5%BF%97"><span class="toc-text">非贪婪匹配 - 处理带颜色日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E8%A1%8C%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%85%E5%AE%B9%E6%9B%BF%E6%8D%A2"><span class="toc-text">指定行之间的内容替换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E6%8E%89%E6%89%80%E6%9C%89%E6%B1%89%E5%AD%97"><span class="toc-text">删掉所有汉字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%9B%BF%E6%8D%A2%E6%96%87%E6%9C%AC"><span class="toc-text">批量替换文本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E5%90%8D"><span class="toc-text">批量修改文件名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">附加字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E3%80%81%E5%88%A0%E9%99%A4%E6%89%A9%E5%B1%95%E5%90%8D"><span class="toc-text">添加、删除扩展名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6%EF%BC%88sed-%E8%84%9A%E6%9C%AC%EF%BC%89"><span class="toc-text">替换控制字符（sed 脚本）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8Eshell%E5%90%91sed%E4%BC%A0%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">从shell向sed传字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%8D%A2%E8%A1%8C%E7%AC%A6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%A9%BA%E6%A0%BC"><span class="toc-text">将换行符转换为空格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%A9%BA%E8%A1%8C"><span class="toc-text">添加空行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%93%E5%8D%B0%E5%92%8C%E5%88%A0%E9%99%A4%E7%89%B9%E5%AE%9A%E8%A1%8C"><span class="toc-text">打印和删除特定行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%8A%E6%96%87%E7%AB%A0%E6%AF%8F%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%8D%A2%E4%B8%80%E8%A1%8C"><span class="toc-text">把文章每一句话换一行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%B9%E9%85%8D%E8%A1%8C%E4%B9%8B%E5%89%8D-%E5%90%8E%E6%B7%BB%E5%8A%A0%E4%B8%80-%E5%A4%9A%E8%A1%8C"><span class="toc-text">匹配行之前&#x2F;后添加一&#x2F;多行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%9A%84%E8%A1%8C%E5%B0%BE%E6%88%96%E8%A1%8C%E9%A6%96%E6%B7%BB%E5%8A%A0%E5%AD%97%E7%AC%A6"><span class="toc-text">文本的行尾或行首添加字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort-%E6%8E%92%E5%BA%8F"><span class="toc-text">sort - 排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uniq"><span class="toc-text">uniq</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tr-translate"><span class="toc-text">tr - translate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E9%A1%B9"><span class="toc-text">选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tar"><span class="toc-text">tar</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91"><span class="toc-text">文本编辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vim-%E6%9B%BF%E6%8D%A2"><span class="toc-text">vim 替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim-%E9%85%8D%E7%BD%AE"><span class="toc-text">vim 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim-%E6%B3%A8%E9%87%8A"><span class="toc-text">vim 注释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vim-%E6%96%87%E6%9C%AC%E6%8A%98%E5%8F%A0"><span class="toc-text">vim 文本折叠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%A4%9A%E7%AA%97%E5%8F%A3%E3%80%81%E5%A4%9A%E6%96%87%E4%BB%B6"><span class="toc-text">打开多窗口、多文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Taglist-%E5%B7%A6"><span class="toc-text">Taglist(左)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nerdtree-%E5%8F%B3"><span class="toc-text">nerdtree(右)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cscope"><span class="toc-text">cscope</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A8%A1%E5%BC%8F"><span class="toc-text">可视化模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%A8%A1%E5%BC%8F"><span class="toc-text">字符模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%8C%E6%A8%A1%E5%BC%8F"><span class="toc-text">行模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%97%E6%A8%A1%E5%BC%8F"><span class="toc-text">块模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E5%89%8D%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D"><span class="toc-text">当前挂起和恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vimdiff"><span class="toc-text">vimdiff</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%B7%AE%E5%BC%82"><span class="toc-text">对比差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E6%A0%87"><span class="toc-text">光标</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%88%E5%B9%B6"><span class="toc-text">合并</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shell"><span class="toc-text">shell</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tee"><span class="toc-text">tee</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">查看版本号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ps"><span class="toc-text">ps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B"><span class="toc-text">后台进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text">命令执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zsh%E6%8F%90%E7%A4%BA%E7%AC%A6"><span class="toc-text">zsh提示符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WSL%E5%AD%97%E4%BD%93%E6%B0%B8%E4%B9%85%E7%94%9F%E6%95%88"><span class="toc-text">WSL字体永久生效</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#wsl-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-text">wsl 环境变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#vim-%E7%B2%98%E8%B4%B4%E6%97%B6%E7%BC%A9%E8%BF%9B%E9%94%99%E4%B9%B1"><span class="toc-text">vim 粘贴时缩进错乱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#date%E6%97%B6%E9%97%B4%E8%BE%93%E5%87%BA"><span class="toc-text">date时间输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-text">变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E5%8F%98%E9%87%8F"><span class="toc-text">清除变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%89%80%E6%9C%89%E6%9C%AC%E5%9C%B0-shell-%E5%8F%98%E9%87%8F"><span class="toc-text">显示所有本地 shell 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E5%B7%B2%E7%BB%8F%E8%AE%BE%E7%BD%AE"><span class="toc-text">测试变量是否已经设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8F%AA%E8%AF%BB%E5%8F%98%E9%87%8F-%E5%B8%B8%E9%87%8F"><span class="toc-text">设置只读变量(常量)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BB%93%E6%9E%9C%E8%B5%8B%E5%80%BC%E7%BB%99%E5%8F%98%E9%87%8F"><span class="toc-text">将命令的结果赋值给变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%8F%98%E9%87%8F-%E7%B3%BB%E7%BB%9F%E4%BF%9D%E7%95%99%E5%8F%98%E9%87%8F"><span class="toc-text">特殊变量(系统保留变量)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#export"><span class="toc-text">export</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">关系运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">布尔运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">字符串运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E6%B5%8B%E8%AF%95%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">文件测试运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#printf"><span class="toc-text">printf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-if-else%E8%AF%AD%E5%8F%A5"><span class="toc-text">Shell if else语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-test%E5%91%BD%E4%BB%A4"><span class="toc-text">Shell test命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-case-esac%E8%AF%AD%E5%8F%A5"><span class="toc-text">Shell case esac语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shell-%E5%BE%AA%E7%8E%AF"><span class="toc-text">Shell 循环</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#man"><span class="toc-text">man</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#info"><span class="toc-text">info</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fish%E9%85%8D%E7%BD%AE"><span class="toc-text">fish配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AA%E6%8A%8Afish%E8%AE%BE%E4%B8%BA%E4%BA%A4%E4%BA%92%E5%BC%8Fshell"><span class="toc-text">只把fish设为交互式shell</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wireshark-%E6%9D%83%E9%99%90%E4%B8%8D%E8%B6%B3%EF%BC%8C%E6%89%BE%E4%B8%8D%E5%88%B0%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3"><span class="toc-text">wireshark 权限不足，找不到网络接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3WSL%E6%9B%B4%E6%94%B9%E9%BB%98%E8%AE%A4%E5%AD%97%E4%BD%93%E4%B8%BAconsolas%EF%BC%8C%E8%BF%9B%E5%85%A5%E6%96%87%E4%BB%B6%E5%90%8E%E9%80%80%E5%87%BA%E6%96%87%E4%BB%B6%E5%AD%97%E4%BD%93%E5%8F%88%E5%8F%98%E4%B8%BA%E5%AE%8B%E4%BD%93"><span class="toc-text">解决WSL更改默认字体为consolas，进入文件后退出文件字体又变为宋体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP-IP"><span class="toc-text">TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#net-tools-%E5%92%8C-iproute2"><span class="toc-text">net-tools 和 iproute2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%8C%E7%BD%91%E5%8D%A1%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="toc-text">配置双网卡路由表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Socket"><span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F"><span class="toc-text">第一个程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E5%A4%A7%E5%B0%8F%E5%86%99%E7%A8%8B%E5%BA%8F"><span class="toc-text">转换大小写程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sockaddr-in%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">sockaddr_in结构体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#git"><span class="toc-text">git</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#blog"><span class="toc-text">blog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#npm-%E7%89%88%E6%9C%AC%E5%A4%AA%E4%BD%8E"><span class="toc-text">npm 版本太低</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#golang"><span class="toc-text">golang</span></a></li></ol></li></ol></li></ol>
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/C/"><i class="fa fa-tags"></i>C</a>
     
      <a href="/tags/notes/"><i class="fa fa-tags"></i>notes</a>
     
      <a href="/tags/Linux/"><i class="fa fa-tags"></i>Linux</a>
     
      <a href="/tags/Makefile/"><i class="fa fa-tags"></i>Makefile</a>
    
    </div>
  
</div>

    </main>
    
      
<div class="site-comment-contanier" data-plateform="leancloud">
  
    <p id="site-comment-info">
      <i class="fa fa-spinner fa-spin"></i> 评论加载中
    </p>
    <div id="site-comment"></div>
  
</div>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
      <div class="site-footer-info">
        <i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客
      </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: snoire@qq.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2020 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>

    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <div class="site-layer-input-choose">
          <a href="javascript:void(0);" title="Change Search Engine">Google</a>
        </div>
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      
        <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
          
            <div>
              <img src="/images/wechat.png" alt="WeChat">
              
                <p>WeChat</p>
              
            </div>
          
            <div>
              <img src="/images/alipay.png" alt="AliPay">
              
                <p>AliPay</p>
              
            </div>
          
        </div>
      
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/passages/Walden-whjxxl/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/passages/Debian-cmd/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
      <a href="#site-comment" data-enable="true">
        <i class="fa fa-commenting"></i>
      </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    
      <a href="javascript:void(0);" id="site-reward">
        <i class="fa fa-thumbs-up"></i>
      </a>
    
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
  
  
  
  
</div>
    





    
  </body>
</html>